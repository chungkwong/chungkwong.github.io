====== 人的价值 ======


我具有世界上最先进的文明。做我的朋友本来应该是一件容易的事，可我却很不容易找到一个朋友，因为很少有人具有跟我匹配的“个人价值”。我对人的“估价”，不是取决于他拥有多少金钱或者知识，而是取决于他的内心认为自己有多大价值，取决于他有多尊重和爱戴他自己。具有高价值的人，不需要通过外在事物来凸显自己。如果A崇拜我看不起的B，那么A会被我同样的看不起。也就是说，一个人崇拜的人的价值，决定了这个人价值的上限。很多人在我面前吹捧和膜拜其它人和事物，结果是贬低了他们自己的价值，也让我感觉跟他们说话是降低了身份。

那么是不是说藐视一切的人，在我心目中就有最大的价值呢？是的，如果他真的能发自心底的做到藐视一切。然而可惜的是，只有非常少的人能够做到这一点。很多人看似目中无人，而其实只是自欺欺人，他们的心底其实很在乎一些人和事物。这些人对自己的估价，其实在很多东西之下。比如很多人认为豪车或者名牌服饰是自己身份的象征，所以总想显示这些。一旦有了这种特征，这人的价值就被我定位在了汽车，衣服这类物品之下。有些人喜欢显示自己为某知名公司工作，穿印有公司徽标的衣服，张口闭口拍公司的马屁。这些人的价值，就被我定义在了那被我鄙视的公司之下。

在我的心目中，物质是卑贱的，是为人服务的。所以我不怜惜钱，车子或者其它物品，不觉得穿了什么衣服或者开了什么车，就凸显了自己的价值。在我的心里，我的价值大于所有的这些：名牌车子，名牌衣服，名牌大学，知名教授，高深的理论，知名公司，亿万富翁，甚至民族传统。我的个人价值如此之大，所以我不惜抛弃名牌大学的学位，我不屑为某些知名大公司工作。我毫不在意别人怎么看我，我毫不在意别人定义的所谓“成功”。我最得意的成就，其实就是我自己。这就是我所谓的“个人价值”，这跟一个人对于其它人的“利用价值”，是完全不同的两回事。

我多希望面前的人能够跟我一样，实际上我总是不切实际的假设他是这样的人。我会在他面前拿各种事物和权威开玩笑，因为我一般都善良的假设这个人是一个朋友，他尊重他自己胜过任何其它事物，所以我尊重他这个人，胜过他穿的衣服，胜过他待过的学校，胜过他所服务的公司。很可惜的是，只有非常少的人能够做到尊重他自己，并且能够理解我的做法。有人甚至因为我拿他们崇拜的人，学校，公司，甚至学术理论开玩笑而感到恼怒。对人的个人价值的高度尊重，反而引起了他的反感。我很遗憾，但却并不可惜，因为他贬低了他自己，而我只在乎那些具有跟我有同等价值的人。

====== 什么是“对用户友好”======

当我提到一个工具“对用户不友好”(user-unfriendly)的时候，我总是被人“鄙视”。难道这就叫“以其人之道还治其人之身”？想当年有人对我抱怨 Linux 或者 TeX 对用户不友好的时候，我貌似也差不多的态度吧。现在当我指出 TeX 的各种缺点，提出新的解决方案的时候，往往会有美国同学眼角一抬，说：“菜鸟们抱怨工具不好用，那是因为他们不会用。LaTeX 是‘所想即所得’，所以不像 Word 之类的上手。”

殊不知他面前这个“菜鸟”，其实早已把 TeX 的配置搞得滚瓜烂熟，把 TeXbook 翻来覆去看了两遍，"double bend" 的习题都全部完成，可以用 TeX 的语言来写宏包。而他被叫做“菜鸟”，这是一个非常有趣的问题。所以现在抛开个人感情不谈，我们来探讨一下这种“鄙视”现象产生的原因，以及什么叫做“对用户友好”。

首先我们从心理的角度来分析一下为什么有人对这种“对用户不友好”的事实视而不见，而称抱怨的用户为“菜鸟”。这个似乎很明显，答案是“优越感”。如果每个人都会做一件事情，如何能体现出我的超群智力？所以我就是要专门选择那种最难用，最晦涩，最显得高深的东西，把它折腾会。这样我就可以被称为“高手”，就可以傲视群雄。我不得不承认，我以前也有类似的思想。从上本科以来我就一直在想，同样都会写程序，是什么让计算机系的学生与非计算机系的学生有所不同？经过多年之后的今天，我终于得到了答案（以后再告诉你）。可是在多年以前，我犯了跟很多人一样的错误：把“难度”与“智力”或者“专业程度”相等同。但是其实，一个人会用难用的工具，并不等于他智力超群或者更加专业。

可惜的是，我发现世界上有非常少的人明白这个道理。在大学里，公司里，彰显自己对难用的工具的掌握程度的人比比皆是。这不只是对于计算机系统，这也针对数学以及逻辑等抽象的学科。经常听人很自豪的说：“我准备用XX逻辑设计一个公理化的系统……”可是这些人其实只知道这个逻辑的皮毛，他们会用这个逻辑，却不知道它里面所有含混晦涩的规则都可以用更简单更直观的方法推导出来。

爱因斯坦说：“Any intelligent fool can make things bigger and more complex... It takes a touch of genius - and a lot of courage to move in the opposite direction.”我现在深深的体会到这句话的道理。想要简化一个东西，让它更“好用”，你确实需要很大的勇气。而且你必须故意的忽略这个东西的一些细节。但是由于你的身边都是不理解这个道理的人，他们会把你当成菜鸟或者白痴。即使你成功了，可能也很难说服他们去尝试这个简化后的东西。

那么现在我们来谈一下什么是“对用户友好”。如何定义“对用户友好”？如何精确的判断一个东西是否对用户友好？我觉得这是一个现在仍然非常模糊的概念，但是程序语言的设计思想，特别是其中的类型理论(type theory)可以比较好的解释它。我们可以把机器和人看作同一个系统：

    - 这个系统有多个模块，包括机器模块和人类模块。
    - 机器模块之间的界面使用通常的程序接口。
    - 人机交互的界面就是机器模块和人类模块之间的接口。
    - 每个界面必须提供一定的抽象，用于防止使用者得到它不该知道的细节。这个使用者可能是机器模块，也可能是人类模块。
    - 抽象使得系统具有可扩展性。因为只要界面不变，模块改动之后，它的使用者完全不用修改。

在机器的各个模块间，抽象表现为函数或者方法的类型(type)，程序的模块(module)定义，操作系统的系统调用(system call)，等等。但是它们的本质都是一样的：他们告诉使用者“你能用我来干什么”。很多程序员都会注意到这些机器界面的抽象，让使用者尽量少的接触到实现细节。可是他们却往往忽视了人和机器之间的界面。也许他们没有忽视它，但是他们却用非常不一样的设计思想来考虑这个问题。他们没有真正把人当成这个系统的一部分，没有像对待其它机器模块一样，提供具有良好抽象的界面给人。他们貌似觉得人应该可以多做一些事情，所以把纷繁复杂的程序内部结构暴露给人（包括他们自己）。所以人对“我能用这个程序干什么”这个问题总是很糊涂。当程序被修改之后，还经常需要让人的操作发生改变，所以这个系统对于人的可扩展性就差。通常程序员都考虑到机器各界面之间的扩展性，却没有考虑到机器与人之间界面的可扩展性。

举个例子。很多 Unix 程序都有配置文件，它们也设置环境变量，它们还有命令行参数。这样每个用户都得知道配置文件的名字，位置和格式，环境变量的名字以及意义，命令行参数的意义。一个程序还好，如果有很多程序，每个程序都在不同的位置放置不同名字的配置文件，每个配置文件的格式都不一样，这些配置会把人给搞糊涂。经常出现程序说找不到配置文件，看手册吧，手册说配置文件的位置是某某环境变量 FOO 决定的。改了环境变量却发现没有解决问题。没办法，只好上论坛问，终于发现配置文件起作用当且仅当在同一个目录里没有一个叫 ".bar" 的文件。好不容易记住了这条规则，这个程序升级之后，又把规则给改了，所以这个用户又继续琢磨，继续上论坛，如此反复。也许这就叫做“折腾”？他何时才能干自己的事情？

TeX 系统的配置就更为麻烦。成千上万个小文件，很少有人理解 kpathsea 的结构和用法，折腾好久才会明白。但是其实它只是解决一个非常微不足道的问题。TeX 的语言也有很大问题，使得扩展起来非常困难。这个以后再讲。

一个良好的界面不应该是这样的。它给予用户的界面，应该只有一些简单的设定。用户应该用同样的方法来设置所有程序的所有参数，因为它们只不过是一个从变量到值的映射（map）。至于系统要在什么地方存储这些设定，如何找到它们，具体的格式，用户根本不应该知道。这跟高级语言的运行时系统(runtime system)的内存管理是一个道理。程序请求建立一个对象，系统收到指令后分配一块内存，进行初始化，然后把对象的引用(reference)返回给程序。程序并不知道对象存在于内存的哪个位置，而且不应该知道。程序不应该使用对象的地址来进行运算。

所以我们看到，“对用户不友好”的背后，其实是程序设计的不合理使得它们缺少抽象，而不是用户的问题。这种对用户不友好的现象在 Windows，Mac，iPhone, Android 里也普遍存在。比如几乎所有 iPhone 用户都被洗脑的一个错误是“iPhone 只需要一个按钮”。一个按钮其实是不够的。还有就是像 Photoshop, Illustrator, Flash 之类的软件的菜单界面，其实把用户需要的功能和设置给掩藏了起来，分类也经常出现不合理现象，让他们很难找到这些功能。

如何对用户更加友好，是一两句话说不清楚的事情。所以这里只粗略说一下我想到过的要点：

    - 统一：随时注意，人是一个统一的系统的一部分，而不是什么古怪的神物。基本上可以把人想象成一个程序模块。
    - 抽象：最大限度的掩盖程序内部的实现，尽量不让人知道他不必要知道的东西。不愿意暴露给其它程序模块的细节，也不要暴露给人。“机所不欲，勿施于人”。
    - 充要：提供给人充分而必要（不多于）的机制来完成人想完成的任务。
    - 正交：机制之间应该尽量减少冗余和重叠，保持正交(orthogonal)。
    - 组合：机制之间应该可以组合(compose)，尽量使得干同一件事情只有一种组合。
    - 理性：并不是所有人想要的功能都是应该有的，他们经常欺骗自己，要搞清楚那些是他们真正需要的功能。
    - 信道：人的输入输出包括5种感官，虽然通常电脑只与人通过视觉和听觉交互。
    - 直觉：人是靠直觉和模型(model)思考的，给人的信息不管是符号还是图形，应该容易在人脑中建立起直观的模型，这样人才能高效的操作它们。
    - 上下文：人脑的“高速缓存”的容量是很小的。试试你能同时想起7个人的名字吗？所以在任一特定时刻，应该只提供与当前被关注对象相关的操作，而不是提供所有情况下的所有操作供人选择。上下文菜单和依据上下文的键盘操作提示，貌似不错的主意。


　　
====== 所谓“人为错误” ======


昨天是一个让人悲哀的日子。旧金山湾区主要的上下班交通工具Caltrain，在24小时之内发生三次事故，撞死三人。其中一次事故发生在Menlo Park，一辆汽车被困在铁轨上，因为被前后的车辆堵塞而无法逃避，终于被飞驰而来的列车撞成一堆废铁。开车人被消防队员从残骸里切割出来，送往医院后不久死亡。(新闻视频）

我为生命的殒灭而悲哀，然而让我更加悲哀的是，每当这样的事故发生，总有人指责说是“人为错误”。比如，Twitter上有人说这事故是因为死者没有遵守交通规则，才导致自己的汽车被困在铁轨之上，所以她死的活该。

真的是因为她不遵守交通规则吗？真的有人愿意把车停在铁轨上等死吗？也许是这规则没法遵守，或者设计得让人很容易“违反”呢？

首先，规则必须要让人理解，切实可行，才能叫做规则。

但是请看看铁轨交叉路口上的指令：“不要停在铁轨上（DO NOT STOP ON TRACKS）”，“保持路口畅通（KEEP CLEAR）”。我也不想停在铁轨上啊，可是我刚开到铁轨上，前面的车就停下来了，过不去怎么办？另外什么叫做clear？一定要等到路口里面完全没有车才可以进去吗？如果路口里面虽然有车，然而它们都以每小时30英里的速度行驶？这时我还该停下来吗？如果前面车的速度不到每小时5英里呢？如果前面车辆貌似很快，结果我一进路口它就慢下来了怎么办？

如果“不要停在铁轨上”的指令我想遵守都不可能，如果连clear这个单词都定义不清楚，这还叫什么“交通规则”呢？既然规则都不清楚，又怎么能责怪别人不遵守？我要有多么高的预知未来的能力，才能猜得到前面的车会不会正好在我开到铁轨上的时候停下来，把我堵在铁轨上呢？也许你已经看出来了，这其实不是开车人的错误，它最多算一个“判断失误”。每个人都有可能在那种模棱两可的情况下发生判断失误，因为你没法知道前面的车会怎样运动。记者在现场采访的几个开车人都说：“过那个路口要极度小心，因为你不知道前面的车会怎么样走。”

如果你仔细看看卫星图，就会发现铁轨前方的道路狭窄，而且不远处有一个红绿灯。如果这个红绿灯变红，那么就有可能把直到铁轨处的车辆全都叫停。如果你熟悉湾区的道路，就知道红灯处是82号公路（El Camino Real），上那条路的红灯经常等很久。也就是说，可能有很多车在那里等红灯，一直到铁轨的地方！

如果你再仔细一点，用Google Map的street view去实地看一下那个路口，就会发现，地面上的"KEEP CLEAR"字样，其实是用来给被堵在铁轨上的车预留后路的。然后你就发现，如果后面的车不遵守KEEP CLEAR的指令，那么它们就会断掉铁轨上的车的退路。所以，其实不是铁轨上的车自己等死，而是后面那些不遵守KEEP CLEAR指令的车，把它逼上了绝路。然而就像我之前提到的，想要遵守KEEP CLEAR又是很模棱两可的事情，后面的车有可能以为你过得去，所以才跟上的。所以你死了，不能怪火车，不能怪你自己，不能怪前面的车，还不能怪后面的车！怪谁呢？只能怪路口的“设计”！

这种路口交通规则还有一个致命的特征，那就是后果的严重性不明显，人不会敏锐的感觉到犯了错误的结果是车毁人亡。一般人都不闯红灯，因为很显然，如果你红灯不停就会被另一个方向的车撞上。可是违反这铁道路口的规则，后果不是立显的，有可能什么事也没有，也有可能呆在那里几分钟之后才出事，到时候想逃都逃不了。这就像把活青蛙放进冷水里，然后慢火加热一样，它不会立即被烫得跳出来，而会死在里面！等你慢慢的开到铁轨上，才发现前面的车不走了（因为更前面路口亮了红灯），后面的车又抵上来。过一会儿，当当当，栏杆放下来，火车来了…… 你这是在设陷阱诱捕野生动物吗？

如此容易出现的失误（甚至不叫做自己的失误），真的值得一个人用生命来偿还吗？按照这样的逻辑，我就可以把地雷埋在大街上，插上标志牌说：“下面有地雷，不要踩！”如果你踩了，那我就可以怪你没遵守规则，自己找死！

如果你回头看看历史就会发现，Caltrain几乎每个月都会撞上至少一辆汽车，所以这次的事故绝不是偶然，它有更深层的原因。上一个月，我乘坐的一列Caltrain，就因为前面一趟列车撞上了汽车而延误了好几个小时。当时我就在Twitter上看到有人责备开车的人，说他脑子秀逗了，不该把车停在铁轨上。当时我就在Twitter上警告@Caltrain，说你们应该仔细分析一下这个交叉路口的设计，也许是因为设计有问题。没有人回应我。这次出了三条人命，交叉路口的设计问题才终于受到了重视。

出了人命的大事故，也许能唤醒人们一点理智，认识到所谓的“人为错误”，其实在很多时候是设计错误。在这个例子中，交叉路口的设计是不合理的。一旦你因为判断失误把车开进去了，就有可能出现无路可逃，车毁人亡的局面。然而很多生活中的设计失误所引发的“人为错误”都是不致命的，有点像慢性毒药。这种貌似无关痛痒的设计错误，更加容易被忽视，它们就潜伏在我们的身边。

在我所在的软件行业里，就有很多这样的设计错误。在我看来，整个软件行业基本就是建立在一堆堆的设计失误之上。做程序员如此困难和辛苦，大部分原因就是因为软件系统里面积累了大量前人的设计失误，所以我们需要做大量的工作来弥补或者绕过。举个例子，Unix/Linux操作系统就是一个重大的设计失误。Unix系统的命令行，系统API，各种工具程序，编辑器，程序语言（C，C++等），设计其实都很糟糕。很多工具程序似乎故意设计得晦涩难用，让人摸不着头脑，需要大量时间学习，而且容易出错。出错之后难以发现，难以弥补。

然而一般程序员都没有意识到这里面的设计错误，知道了也不敢指出来，他们反而喜欢显示自己死记硬背得住这些稀奇古怪的规则。这就导致了软件行业的“皇帝的新装现象”——没有人敢说工具的设计有毛病，因为如果你说出来，别人就会认为你在抱怨，那你不是经验不足，就是能力不行。这就像你不敢说皇帝没穿衣服，否则别人就会认为你就是白痴或者不称职的人！Unix系统的同盟者和后裔们（Linux，C语言，Go语言），俨然形成了这样一种霸权，他们鄙视觉得它们难用，质疑它们的设计的人。他们嘲笑这些用户为失败者，即使其实有些“用户”水平比Unix的设计者还要高。久而久之，他们封住了人们的嘴，让人误以为难用的东西就是好的。

我体会很深的一个例子就是Git版本控制工具。有人很把这种东西当回事，引以为豪记得住如何用一些稀奇古怪的Git命令（比如git rebase, git submodule之类）。好像自己知道了这些就真的是某种专家一样，每当遇到不会用这些命令的人，都在心底默默地鄙视他们。作为一个比Git的作者还要高明的程序员，我却发现自己永远无法记住那些命令。在我看来，这些命令晦涩难懂，很有可能是因为没设计好造成的。因为如果一个东西设计好了，以我的能力是不可能不理解的。可是Linus Torvalds的名气之大，威望之高，有谁敢说：“我就是不会用你设计的破玩意儿！你把我怎么着？”


====== 设计的重要性 ======


我曾经在一篇文章里谈过关于设计的问题，然而那篇文章由于标题不够醒目，可能很多人没有注意看。我觉得现在有必要把里面的内容专门提出来讲一下，因为设计在我的心目中具有至关重要的地位，却被很多计算机科学家和程序员所轻视。

我觉得自己不但是一个计算机科学家和程序员，在很大程度上我还是一个设计师。我不但是一个程序语言的设计师，而且是其它很多东西的设计师。我设计的东西不但常常比别人的简洁好用，而且我经常直接看出其他人的设计里面的问题。我写的代码不仅自己容易看懂，而且别人也容易理解。我有时候受命修补前人的BUG，结果没法看懂他们的代码。在这种情况下，我的解决方案是推翻重写。经我重写之后的代码，不仅没有BUG，而且简洁很多。

很多人自己的设计有问题，太复杂不易用，到头来却把责任推在用户身上，使用类似“皇帝的新装”的技巧，让用户有口难言。之前一篇文章提到的严重交通事故，就是一个设计问题，却被很多人归结为“人为错误”。这种出人命的事情都这么难引起人们对设计的关注，就更不要说软件行业那些无关性命的恼人之处了。有些人写的代码过度复杂，BUG众多，却仿佛觉得自己可以评估其他人的智商，打心眼里觉得自己是专家，看不懂他代码的人都是笨蛋。

很多程序员有意把“用户”和自己区别开来，好像程序员应该高人一等，不能以用户的标准。所以他们觉得程序员就是应该会用各种难用的工具，难用的操作系统，程序语言，编辑器，…… 他们觉得只要你追求这些东西的“易用性”或者“直观性”，就说明你智商有问题。只要你说某个东西太复杂，另一个东西好用些，他们就会跟你说：“专家才用这个，你那个是菜鸟用的。” 这些人不明白，程序员其实也是用户，而且他们是自己的代码的用户，每一次调用自己写的函数，自己都是自己的用户。可是这种鄙视用户的风气之胜行，带来了整个行业不但设计过度复杂，而且以复杂为豪的局面。

经常有人自豪的声称自己的项目有多少万行代码，仿佛代码的行数是衡量一个软件质量的标准，行数越多质量越好，然而事实却恰恰相反。你可能需要经历过Indiana式的教育才能真正的理解这一点。如果你拿一些引以为豪的代码给Dan Friedman看，他可能瞟一眼就说：“太长了。当年这个东西我两行代码就写出来了……” 你摸着脑袋怀疑他是不是在吹牛，怎么可能！然后过了几个星期，你把代码重写了好多遍之后，真的发现只需要两行！这时候他才会微笑着点点头，一副龟仙人的味道。就是这样的教育，让我能够在短短几个星期之内，完成Google一个小组的人花几年也没法完成的项目。看过我写的代码，你也许会理解这句《小王子》作者的名言：“一个设计师知道他达到了完美，并不是当他不能再加进任何东西，而是当没有任何东西可以被去掉。”

如果你跟我一样关心设计，却发现身边的人喜欢显示自己能搞懂复杂的东西，跟你说容易的东西都是菜鸟用的，那么你需要一个朋友。书籍是人类最好的朋友，因为它的作者可以跨越时间和空间的限制，给你最需要的支持和鼓励。这就是当我阅读这本1988年出版的《The Design of Everyday Things》（简称DOET）时的感觉。我觉得，终于有人懂我了！有趣的是，它的作者 Don Norman 曾经是 Apple Fellow，也是《The Unix-Haters Handbook》一书序言的作者。

DOET 不但包含并且支持了我的博文《黑客文化的精髓》以及《程序语言与……》里的基本观点，而且提出了比《什么是“对用户友好”》更精辟可行的解决方案。

我觉得这应该是每个程序员必读的书籍。为什么每个程序员必读呢？因为虽然这本书是设计类专业的必读书籍，而计算机及其编程语言和工具，其实才是作者指出的缺乏设计思想的“重灾区”。看了它，你会发现很多所谓的“人为错误”，其实是工具的设计不合理造成的。一个设计良好的工具，应该只需要很少量的文档甚至不需要文档。这本书将提供给你改进一切事物的原则和灵感。你会恢复你的人性。

值得一提的是，虽然 Don Norman 曾经是 Apple Fellow，但我觉得 Apple 产品设计的人性化程度与 Norman 大叔的思维高度还是有一定的差距的。因为我看了这书之后，立马发现了iPhone的一些设计问题。

如果你跟我一样不想用眼睛看书，可以到 Audible 买本有声书来听。

====== 论对东西的崇拜 ======


作者：王垠


在之前的几篇博文里面，我多次提到了 Lisp，它相对于其它语言的优势，以及 Lisp Machine 相对于 Unix 的优点。于是有人来信请教我如何学习 Lisp，也有人问我为什么 Lisp Machine 没有“流行”起来。我感觉到了他们言语中对 Lisp 的敬畏和好奇心，但也感觉到了一些隐含的怀疑。


这是一种复杂的感觉，仿佛我在原始人的部落兜售一些原子能小玩具，却被人当成了来自天外的传教士。敬畏和奉承，并不能引起我的好感。怀疑和嘲讽，也不能引起我的不平。当我看到有人说“别听他误导群众，学那些语言是找不到工作的”的时候，我心里完全没有愤怒，也没有鄙视，我也没必要说服他。我只是微笑着摇摇头，对自己说：可怜而可笑的人。


不明白为什么，当我提到某个东西相对于另一个东西的优点的时候，我总是被人认为是在“推崇”某个东西，或者被人称为是它的“狂热分子”。现在显然已经有人认为我在推崇 Lisp 了，甚至在某个地方看到有人称我为“国内三大 Lisp 狂人之一”。他们仿佛觉得我推荐一个东西，就是想让他们完全的拥抱这个东西，而丢弃自己已经有的东西。而“支持”这另一个东西的人，也往往会产生敌视情绪。


很多人都不明白，每个东西都有它好的方面，也有它不好的方面。我推荐的只是 Lisp 好的方面，不好的方面我心里清楚，但是还没有机会讲。这些人显然已经在下意识里把“东西”当成了人。有人说“爱一个人就要爱她（他）的全部”，这是一种很无奈的说法，因为你没有能力把一个人分解成你喜欢的和不喜欢的两部分，然后重新组装成你的梦中情人。可是东西却不一样。因为东西是人造出来的，所以你可以把它们大卸八块，然后挑出你喜欢的部分。

所以我可以很清楚的告诉你，我并不推崇 Lisp，我也不是 Lisp 狂人，它只是我的小玩意儿之一。这个非常精巧的小玩意儿，包含了很多其它东西身上没有的优点。人们都说忘记历史就等于毁灭未来。如果 Java 没有从 Lisp 身上学会“垃圾回收”，C# 没有从 Lisp 身上学会 lambda，那么我们今天也许还在为 segfault 而烦恼，也许会继续使用没必要的 design patterns。如果你了解一点历史就会发现，今天非常流行的 JavaScript，其实不过是一个“没能正确实现的 Scheme”。所以 Lisp 的精髓，其实正在越来越多的渗透到常用的语言里面。


很多人没有设计程序语言的能力，所以他们把程序语言，操作系统一类的东西当成是不可改变的，凌驾于自己之上的。相比之下，我受到的训练却给了我设计和实现几乎任何语言的能力。我知道它们的优点和弱点，我有能力把它们大卸八十块，再组装还原。我有能力改变其中我不喜欢的地方，或者增加我觉得有必要的功能。当我谈论某个东西比另一个好的地方，总有人以为我在“抱怨”，说：“既然如此，那为什么你说的这个好东西被打败了？”他不明白，其实我只是在“分析”。我希望从各个东西里面提取出好的部分，然后想办法把它们都注入到一个新的东西里面。我也希望吸取前人教训，免得重犯这些东西里面的设计错误。


如果在见识短浅的人们心目中，Paul Graham 和 Peter Norvig 算是“Lisp 牛人”的话，那么 Dan Friedman 和 R. Kent Dybvig 就应该被称为 “Lisp 天外来客”了。我不敢大言不惭的说我超过了恩师们，但我除了学到他们的真功夫之外，还偷学了一些他们不屑一顾的“旁门左道”。所以我经常能看到他们看不到的东西，我知道他们的弱点。他们对于 Lisp 的热爱，防止了他们看到它的一些缺点，但这些对于我却非常的清晰明了。然而也是因为他们对其它语言的不屑，才让我逐步的理解了，我曾经认为是优点的某些语言特征（比如 Hindley-Milner 类型系统），其实是缺点。


所以，我其实并不是那么热心的希望有更多的人用 Lisp，Haskell 或者其它什么语言。我不会，也没那工夫去分享自己的秘诀。我没有责任，也没有能力去拯救世界。这是一种找到巨大宝藏的感觉，我蹲在一堆堆的财宝上休养生息。我知道世界上即使没有了我，太阳明天照样会升起。我为什么要那么热心的让别人也知道如何进入这个宝藏？我不是一个特别自私的人，但我也不需要推销什么。这就像我介绍了我的“减肥成功经验”，你觉得太辛苦，偏要去买那些吹得神乎其神的减肥药。我有什么动机来说服你呢？又不是我身上的肥肉。


推崇一个东西，为一个东西狂热，这些感情都在我身上存在过。也许它们确实给我带来了一些益处，让我很快的学会了一些东西。但是这些感情的存在，其实也显示了一个人的弱小。当一个人没有办法控制一个东西的时候，他就会对它产生“崇拜”的心理，这就像所有的宗教和迷信一样。当人们处于自然灾害的凌威之下，没有能力掌握自己命运的时候，他们就对神和超自然的力量产生了崇拜。这是一种心灵的慰藉，至少有上帝或者观音菩萨，可以聆听他们的心声，可以给予他们度过灾难的勇气，但它同时也显示出人的无助和自卑。这种无助和自卑，也引发了偏激的宗教心理，因为他们害怕自己的“保护神”被别人的“保护神”所压倒，以至于让自己受制于他人。这是一种愚昧和卑劣的感情。


可是当你拥有了强大的力量，可以不再畏惧的时候，这种崇拜，以及由于崇拜所带来的偏激心理，就渐渐的消亡了。这就像是一个身怀绝世武功的人，他完全没必要让别人都相信他是高手。因为他知道，自己在谈笑之间，就可以让樯橹灰飞烟灭。于是，他自得其乐，对别人表现出的任何感情，都变得淡漠和无动于衷。

====== 怎样尊重一个程序员 ======


得知一位久违的同学来到了旧金山湾区，然而我见到他时，这人正处于一生中最痛苦的时期。他告诉我，自己任职的公司在他加入之前和之后，判若两人。录取的时候公司对他说，我们对你在实习期间的表现和学术背景非常满意，你不用面试，甚至不用毕业拿学位，直接就可以加入我们公司成为正式员工。然而短短一年后的今天，这位同学已经完全感觉不到公司对自己技能的尊重。Manager让他做一些乱七八糟没技术含量的事情，还抱怨说他做事太慢，并且在他的evaluation上很是写了一笔。在人格尊严和工作安全感的双重打击之下，这位同学压力非常大，周末经常偷偷地加班，仍然无法让manager满意。

我很了解这位同学的能力，在任何一流公司任职，肯定是绰绰有余了。他的名字我当然保密，然而他所任职的公司因为太过嚣张，我不得不直接指出来——这就是被很多人向往得像天堂一样的地方，Google。这位同学所描述的遭遇，跟我几年前在Google的实习经历如出一辙。我仍然记得，Google的队友在旁边看着我用Emacs，用小学老师似的口气对我说：“按Ctrl-k！” 我仍然记得，在提交队友完全无法写出来的高难度代码时，被指责和嘲笑不会用Perforce。我仍然记得，吃饭时同事们对所谓“Google牛人”眉飞色舞的艳羡。我仍然记得，最后我一个人做出整个团队做梦都做不出来的项目的时候，有人发出沉闷的咆哮：“快——写——测——试！” ……

我的这位同学也算得上本领域顶尖的专家了。如此的践踏一个专家的价值，用肤浅的标准来评判和对待他们，Google并不是唯一一个这样的公司。我之前任职的好几个公司，或多或少都存在类似的问题。很多时候也不一定是公司管理层无端施加压力，而是程序员之间互斗的厉害，互相评判，伤害自尊。从最近Linus Torvalds在演讲现场公然对观众无理，你可以看出这种只关心技术，不尊重人的思潮，在程序员的社区里是非常普及的。

后来我发现，并不是程序员故意想要藐视对方或者互相攻击，而是他们真的不明白什么叫做“尊重”，他们不知道如何说话才可以不伤害另一个程序员，所以有时不小心就让人怒火中烧。所以说，尊重他人其实是一个“技术问题”，而不是有心就可以做到的。因为这个原因，我想在下文里从心理和技术角度出发，指出IT业界不尊重人现象的起源，同时提出几点建议，告诉人们如何真正的尊重一个程序员。我希望这些建议对公司的管理层有借鉴意义，也希望它们能给与正在经受同样痛苦的程序员们一些精神上的鼓励。

我觉得为了建设一个程序员之间互相尊重的公司文化，应该注意以下几个要点。
===== 认识和承认计算机系统里的历史遗留糟粕 =====


很多不尊重人现象的起源，都是因为某些人偏执的相信某种技术就是世界上最好的，每个人都必须知道，否则他就不是一个合格的程序员。这种现象在Unix（Linux）的世界尤为普遍。Unix系统的鼓吹者们（我曾经是其中之一）喜欢到处布道，告诉你其它系统的设计有多蠢，你应该遵从Unix的“哲学”。他们仿佛认为Unix就是世界终极的操作系统，然而事实却是，Unix是一个设计非常糟糕的系统。它似乎故意被设计为难学难用，容易犯错，却美其名曰“强大”，“灵活”。眼界开阔一点的程序员都知道，Unix的设计者其实基本不懂设计，他们并不是世界上最好的程序员，却有一点做得很成功，那就是他们很会制造宗教，煽动人们的盲从心理。Unix设计者把自己的设计失误推在用户身上，让用户觉得学不会或者搞错了都是自己的错。

如果你对计算机科学理解到一定程度，就会发现我们其实仍然生活在计算机的石器时代。特别是软件系统，建立在一堆历史遗留的糟糕设计之上。各种蹩脚脑残的操作系统（比如Unix，Linux），程序语言（比如C++，JavaScript，PHP，Go)，数据库，编辑器，版本控制工具，…… 时常困扰着我们，这就是为什么你需要那么多的所谓“经验”和“知识”。然而，很多IT公司不喜欢承认这一点，他们一向以来的作风是“一切都是程序员的错！”，“作为程序员，你应该知道这些！” 这就造成了一种“皇帝的新装现象”——大家都不喜欢用一些设计恶劣的工具，却都怕别人嘲笑或者怀疑自己的能力，所以总是喜欢显示自己“会用”，“能学”，而没有人敢说它难用，敢指出设计者的失误。

我这个人呢，就是这种“黑客文化”的一个反例。我所受到的多元化教育，让我从这些偏激盲从，教条主义的心理里面跳了出来。每当有人因为不会某种工具或者语言来请教我时，我总是很轻松的调侃这工具的设计者，然后告诉他，你没理由知道这些破玩意儿，但其实它就是这么回事。然后我一针见血的告诉他这东西怎么回事，怎么用，是哪些设计缺陷导致了我们现在的诡异用法…… 我觉得所有的IT从业人员对于这些工具，都应该是这样的调侃态度。只有这样，软件行业才会得到实质性的进步，而不是被一些自虐的设计所困扰，造成思维枷锁。

总之，这是一个非常重要的“态度问题”。虽然在现阶段，我们有必要知道如何绕过一些蹩脚的工具，利用它们来完成自己的任务。然而在此同时，我们必须正视和承认这些工具的恶劣本质，而不能拿它们当教条，把什么事都怪罪于程序员。只有分清工具设计者的失误和程序员自己的失误，不把工具的设计失误怪罪于程序员，我们才能有效地尊重程序员们的智商，鼓励他们做出简单，优雅，完善的产品。
===== 分清精髓知识和表面知识，不要太拿经验当回事 =====


在任何领域，都只有少数知识是精髓的，另外大部分都是表面的，肤浅的，是从精髓知识衍生出来的。精髓知识和表面知识都是有用的，然而它们的分量和重要性却是不一样的。所以必须区分精髓知识和表面知识，不能混为一谈，对待它们的态度应该是不一样的。由于表面知识基本是死的，而且很容易从精髓知识推导衍生出来。我们不应该因为自己知道很多表面知识，就自以为比掌握了精髓知识的人还要强。不应该因为别人不知道某些表面知识，就以为自己高人一等。

IT公司经常有这样的人，以为精通一些看似复杂的命令行，或者某些难用的程序语言就很了不起似的。他们如果听说你不知道某个命令的用法，那简直就像法国人不知道拿破仑，美国人不知道华盛顿一样。这些人没有发现，自己身边有些同事其实掌握着精髓的知识，他们完全有能力从自己已有的知识，衍生制造出所有这些工具，而不只是使用它们，甚至设计得更加完善和方便易用。这种能够设计制造出更好工具的人，往往身负更加重要的任务，所以他们往往会在被现有工具的用法迷惑的时候，非常谦虚的请同事帮助解决，大胆的承认自己的糊涂。

如果你是这个精通工具用法的人，切不可以把同事的谦虚请求当成可以显摆自己“资历”的时候。这同事往往真的是在“不耻下问”。他并不是搞不懂，而是根本不屑于，也没有时间去考虑这种低级问题。他的迷惑，往往来源于工具设计者的失误。他很清楚这一点，他也知道自己的技术水平其实是高于这工具的设计者的。然而为了礼貌，他经常不直接批评这工具的设计，而是谦虚的责怪自己。所以同事向你“虚心请教”，完全是为了制造一种友好融洽的气氛，这样可以节省下时间来干真正重要的事情。这种虚心并不等于他在膜拜你，承认自己的技术能力不如你。

所以正确的对待方式应该是诚恳的表示对这种迷惑的理解，并且坦率的承认工具设计上的不合理，蹩脚之处。如果你能够以这种谦和的态度，而不是自以为专家的态度，同事会高兴地从你这里“学到”他需要的，肤浅的死知识，并且记住它，避免下次再为这种无聊事来打扰你。如果你做出一副“天下只有我知道这奇技淫巧”的态度，同事往往会对你，连同这工具一起产生鄙视的情绪。他下次会照样记不住这东西的用法，然而他却再也不会来找你帮忙，而是一拖再拖。
===== 不要自以为聪明，不要评判别人的智商和能力 =====


在IT公司里，总是有很多人觉得自己聪明，想显示自己比别人聪明。这种人似乎随时都在评判（judge）别人，你说的任何话，不管认真的还是开玩笑的，都会被他们拿去作为评估你智商和能力的依据。

有时候你写了一些代码，自己知道时间不够，可是当时有更重要的事情要做，所以打算以后再改进。如果你提交代码时被这种人看到了，他们就会坚定地认为你一辈子只能写出那样的代码。这就是所谓“wishful thinking”，人只能看到他希望看到的东西。这种人随时都在希望自己比别人聪明，所以他们随时都在监听别人显得不如他聪明的时候，而对别人比他高明的时候视而不见。他们只能看到别人疏忽的时候，因为那是可以证明他们高人一等的有利证据。

当然，谁会喜欢这样的人呢，可是他们在IT公司里相当的普遍。你不敢跟他们说话，特别是不敢开玩笑，因为他们会把你稀里糊涂的玩笑话全部作为你智商低下或者经验不足的证据。你不敢问他们问题，因为他们会认为你问问题，说明你不懂！我发现具有这种心理的人，一般潜意识里都存在着自卑。他们有某些方面（包括智力在内）不如别人，所以总是找机会显得高人一等。我还没有想出可以纠正这种心理问题的有效方法，但如我上节所说，意识到整个行业，包括你仰慕的鼻祖们，其实都不懂很多东西，都是混饭吃的，是一个有效的放松这种心理的手段。

有时候我喜欢自嘲，对人说：“我们这行业的祖先做了这么多BUG来让我们修补。现在你做了一坨屎，我也做了一坨屎，我的屎貌似比你的屎香一点。”这样一来，不但显示出心理的平等和尊重，而且避免了因为谦虚而让对方产生高人一等的情绪。说真的，做这行根本不需要很高的智力，所以最好是完全放弃对人智力的判断。你不比任何人更聪明，也不比他们笨。
===== 解释高级意图，不要使用低级命令 =====


随时都要记住，同事和下属是跟你智力相当的人。他们是通情达理的人，然而却不会简单地服从你的低级命令。像我在Google的队友的做法，就是一个很好的反面教材。其实这位Googler只是想告诉我：“删掉这行文本，然后改成这样……” 就是如此一个简单的事情，然而她却故弄玄虚，不直接告诉我这个“高级意图”，而是使用非常低级的指令：“按Ctrl-k！……” 语气像是在对一个不懂事的小学生说话，好像自己懂很多，别人什么都不知道似的。

有哪个Emacs用户不知道Ctrl-k是删掉一行字呢，况且你现在面对的其实是一个资深Emacs用户。我想大家都看出来这里的问题了吧。这样的低级命令不但逻辑不清楚，而且是对另一个人的智力的严重侮辱。你当我是什么啊？猴子？如果这位Googler表明自己的高级意图，就会很容易在心理上和逻辑上让人接受，比如她可以说：“配置文件的这行应该删掉，改成……”

在项目管理的时候也需要注意。在让人做某一件事之前，应该先解释为什么要做这件事，以及它的重要性。这样才能让人理解，才能尊重程序员的智商。
===== 不要期望新人向自己学习 =====


很多IT公司喜欢把新人当初学者，期望他们“从新的起跑线出发”，向自己“学习”。比如，Google把新员工叫做“Noogler”（Newbie Googler的意思），甚至给他们发一种特殊的螺旋桨帽子，其寓意在于告诉他们，小屁孩要谦虚，要向伟大的Google学习，将来才可以飞黄腾达。

这其实是非常错误的作法，因为它完全不尊重新员工早已具备的背景知识，把自己的地位强加于他们头上。并不是你说“新的起跑线”就真的可以把人的过去都抹杀了的。新人不了解你们的代码结构和工程方式，并不等于你们的方式就会先进一些。Google里面真的有很多值得学习的东西吗？学校的教育真的一文不值吗？其实恰恰相反。我可以坦然的说，我从自己的教授身上学会了最精髓的知识，而从Google得到的，只是一些很肤浅的，死记硬背就可以掌握的技能，而且其中有挺多其实是糟粕。我在Google做出的所有创新成果，全都是从学校获得的精髓知识的衍生物。很多PhD学生鄙视Google，就是因为Google不但自己技术平庸，反倒喜欢把自己包装成最先进的，超越其它公司和学校的，并且嚣张的期望别人向他们“学习”。

一个真正尊重人才的公司会去了解，尊重和发挥新人从外界带来的特殊技能，施展他们特有的长处，而不是一味期望他们向自己“学习”。只有这样，我们才能保持这些锐利武器的棱角，在激烈的竞争中让自己立于不败之地。如果你一味的让新人“学习”，而无视他们特有的长处，最后就不免沦为平庸。
不要以老师自居，分清“学习”和“了解”

如上文所说，IT行业的很多所谓“知识”，只不过是一些奇技淫巧，用以绕过前人设计上的失误。所以遇到别人不知道一些东西的时候，请不要以为你“教会”了别人什么东西，不要以为自己可以当老师了。以老师自居，使用一些像“跟我学”一类的语言，其实是一种居高临下，不尊重人的行为。

人们很喜欢在获得了信息的时候用“学习”这个词，然而我觉得这个词被滥用了。我们应该分清两种情况：“学习”和“了解”。前者指你通过别人的指点和自己的理解，获得了精髓的，不能轻易制造出来的知识。后者只是指你“了解”了原来不知道的一些事情。举个例子，如果有人把一件物品放在了某个你不知道的地方，你找不到，问他，然后他告诉你了。这种信息的获取，显然不叫“学习”，这种信息也不叫做“知识”。

然而，IT行业很多时候所谓的“学习”，就是类似这种情况。比如，有人写了一些代码，设计了一些框架模块。有人不知道怎么用，然后有人告诉他了。很多人把这种情况称为“学习”，这其实是对人的不尊重。这跟有人告诉你他把东西放在哪里了，是同样性质的。这样的代码和设计，我也可以做，甚至做得更好，凭什么你说我在向你学习呢？我只是了解了一下而已。

所谓学习，必须是更加高级的知识和技能，必须有一种“有收获”，“有提高”的感觉。简单的信息获取不能叫做“学习”，只能叫做“了解”。分清“了解”和“学习”，不以老师自居，是尊重人的一个重要表现。
===== 明确自己的要求，不要使用指责的语气 =====


有些人很怪异，他根本没告诉过你他想要什么，有什么特别的要求，可他潜意识里假设已经告诉你了。到了后来，他发现你的作法不符合要求，于是严厉指责你没有按照他“心目中的要求”办事。这种现象不止限于程序员，而且包括日常生活中的普通人。举个例子，我妈就是这种人的典型，所以我以前在家生活经常很辛苦。她心目中有一套“正确”的做事方式，如果你没猜出来就会挨骂。你为了避免挨骂，干脆什么事都不要做，然后她又会说你懒，所以你就左右不是人 :)

IT公司里面也有挺多这样的人，他们假设有些信息他已经告诉你了，而其实根本没告诉你。到了后来，他们开始指责你没有按照要求做事。有些极其奇葩的公司，里面的程序员不但喜欢以老师自居，而且他们“传授”你“知识”的主要方式是指责。他们事先不告诉你任何规则，然后只在你违反的时候来责备你。我曾经在这样一个公司待过，名字就不提了。

现在举一个具体的场景例子：

A: 你push到master了？
B: 是啊？怎么了？
A: 不准push到master！只能用pull request！
B: 可是你们之前没告诉过我啊……
A: 现在你知道了？！

注意到了吗？这不是一个技术问题，而是一个礼节（etiquette）问题。你没有事先告诉别人一些规则，就不该用怪罪的语气来对人说话，况且你的规则还不一定总是对的。所以我现在提醒各位IT公司，在技术上的某些特殊要求必须事先提出来，确保程序员知道并且理解。如果没有事先提出，就不要怪别人没按要求做，因为这是非常伤害人自尊的作法。其实，在任何时候都不应该使用指责的语气，它不但对解决问题没有任何正面作用，而且会恶化人际关系，最终导致更加严重的后果。
===== 程序员的工作量不可用时间衡量 =====


很多IT公司管理层不懂得如何估算程序员的工作量，所以用他们坐在自己位置上工作的时间来估算。如果你能力很强，在很短的时间内把最困难的问题解决了，接下来他们不会让你闲着，而会让你做另外一些很低级的活。这是很不合理的作法。打个比方，能力强的员工就像一辆F1赛车，马力和速度是其他人的几十倍。当然，普通人需要很长时间才能解决，甚至根本没法解决的问题，到他手里很快就化解掉了。这就像一辆F1赛车，眨眼工夫就跑完了别人需要很久的路程。如果你用时间来衡量工作量，那么这辆赛车跑完全程只需要很短时间，所以你算出来的工作量就比普通车子小很多。你能因此说赛车工作不够努力，要他快马再加鞭吗？这显然是不对的。

物理定律是这样：能量 = 功率 x 时间。工作量也应该是同样的计算方法。英明的，真正理解程序员的公司，就不会指望高水平的程序员不停地工作。高水平程序员由于经常能够另辟蹊径，一个就可以抵好几个甚至几十个普通程序员。他们处理的问题比常人的困难很多，费脑力多很多，当然他们需要更好的休息，保养，娱乐，…… 如果你让高水平的程序员太忙了，一刻都不停着，有趣有挑战性的事情做完了就让他们做一些低级无聊的事情，他们悟出这个道理之后，就会故意放慢速度，有时候明明很快做完了也会说没做完。与其这样，不如只期望他们工作短一点的时间，把事情做完就可以。

当然这并不是说初级的程序员就应该过量工作。编程是一项艰苦的脑力活动，超时超量的工作再加上压力，只会带来效率的低下，质量的降低。
===== 不要让其他人修补自己的BUG =====


这个我已经在一篇专门的文章里讨论过。让一个程序员修补另外一个程序员的BUG，不但是效率低下，而且是不尊重程序员个人价值的作法，应该尽量避免。

在软件行业，经常看到有的公司管理让一个人修补另一个人代码里的BUG。有时候有人写了一段代码，扔出来不管了，然后公司管理让其他工程师来修复它。我想告诉你们，这种方法会很失败。

首先，让一个人修复另一个人的BUG，是不尊重工程师个人技术的表现。久而久之会降低工程师的工作积极性，以至于失去有价值的员工。代码是人用心写出来的作品，就像艺术家的作品一样，它的质量牵挂着一个人的人格和尊严。如果一个人A写了代码，自己都不想修复里面的BUG，那说明A自己都认为他自己的代码是垃圾，不可救药。如果让另一个人B来修复A代码里的BUG，就相当于是让B来收拾其他人丢下的垃圾。可想而知，B在公司的眼里是什么样的地位，受到什么样的尊重。

其次，让一个人修复另一个人的BUG，是效率非常低下的作法。每个人都有自己写代码的风格和技巧，代码里面包含了一个人的思维方式。人很难不经解释理解别人的思想，所以不管这两人的编程技术高下，都会比较难理解。不能理解别人的代码，不能说明这人编程技术的任何方面。所以让一个人修补另一个人的BUG，无论这人技术多么高明，都会导致效率低下。有时候技术越是高的人，修补别人的BUG效率越是低，因为这人根本就写不出来如此糟糕的代码，所以他无法理解，觉得还不如推翻重写一遍。

当我在大学里做程序设计课程助教的时候，我发现如果学生的代码出了问题，你基本是没法简单的帮他们修复的。我的水平显然比学生的高出许多，然而我却经常根本看不懂，也不想看他们的代码，更不要说修复里面的BUG。就像上面提到的，有些人自己根本不知道自己在写什么，做出一堆垃圾来。看这样的代码跟吃屎的感觉差不多。对于这样的代码，你只能跟他们说这是不正确的。至于为什么不正确，你只能让他们自己去改，或者建议他们推翻重写。也许你能指出大致的方向和思路，然而深入到具体的细节却是不可能的，而且不应该是你的职责。这就是我的教授告诉我的做法：如果代码不能运行，直接打一个叉，不用解释，不用推敲，等他们自己把程序改好，或者实在没办法，来office hours找你，向你解释他们的思想。

如果你明白我在说什么，从今天起就对自己的代码负起责任来，不要再让其它人修补自己的BUG，不要再修补其他人的BUG。如果有人离开公司，必须要有人修补他遗留下来的BUG，那么说话应该特别特别的小心。你必须指出需要他帮忙的特殊原因，强调这件事本来不是他的错，本来是不应该他来做的，但是有人走了，没有办法，并且诚恳的为此类事情的发生表示歉意。只有这样，程序员才会心甘情愿的在这种特殊关头，修补另外一个人的BUG。
===== 不要嚷着要别人写测试 =====


在很多程序员的脑子里，所谓的“流程”和“测试”，比真正解决问题的代码还重要。他们跟你说起这些，那真的叫正儿八经，义正言辞啊！所以有时候你很迷惑，这些人除了遵守这些按部就班的规矩，还知道些什么。大概没有能力的人都喜欢追究各种规矩吧，这样可以显得自己“没有功劳有苦劳”。这些人自己写的代码很平庸，不知道如何简单有效地解决困难的问题，却喜欢在别人提交代码让他review的时候叫喊：“测试很重要！覆盖很重要！你要再加一些测试才能通过我的review！”

本来code review是让他们帮忙发现可能存在的问题，有些人却仿佛把它作为了评判（judge）其他人能力，经验，甚至智商的机会。他们根本不明白别人代码的实质价值，就知道以一些表面现象来判断。我在Google实习，最后提交了质量和难度都非常高的代码，然而一些完全没能力写出这样代码的人，不但没表示出最基本的肯定，反而发出沉闷的咆哮：“快——写——测——试！” 你觉得我会高兴吗？

我并不否认测试的用处，然而很多人提起这些事情时候，语气和态度是非常不尊重，让人反感的。这些人不但没有为解决问题作出任何实质贡献，当有人提交解决方案的时候，他们没有表达对真正做出贡献的人的尊重和肯定，反而指责别人没写测试。好像比他高明的人解决了问题，他反倒才是那个有发言权的，可以评判你的代码质量似的：“我管你代码写得多好，我完全没能力写出来，但你没写测试就是不够专业。你懂不懂测试的重要性啊，还做程序员！”

人际交往的问题经常不在于你说了什么，而在于你是怎么说的。所以我的意思并不是说你不该建议写测试，然而建议就该有建议的语气和态度。因为你没有做实际的工作，所以一些礼貌用语，比如“请”，“可不可以”……是必须的。经常有人说话不注意语气和态度，让人反感，却以自己是工程师，不善于跟人说话为借口。永远要记住，你没有做事，说话就应该委婉，切不可使用光秃秃的祈使句，说得好像这事别人非做不可，不做就是不懂规矩一样。

礼貌的语言，跟人的职业完全没有关系。身为工程师，完全不能作为说话不礼貌的借口。
===== 关于Git的礼节 =====


Git是现在最流行的代码版本控制工具。用外行话说，Git就是一个代码的“仓库”或者“保管”，这样很多人修改了代码之后，可以知道是谁改了哪一块。其实不管什么工具，不管是编辑器，程序语言，还是版本控制工具，比起程序员的核心思想来，都是次要的东西，都是起辅助作用的。可是Git这工具似乎特别惹人恼火。

Git并不像很多人吹嘘的那么好用，其中有明显的蹩脚设计。跟Unix的传统一脉相承，Git没有一个良好的包装，设计者把自己的内部实现细节无情地泄露给了用户，让用户需要琢磨者设计者内部到底怎么实现的，否则很多时候不知道该怎么办。用户被迫需要记住挺多稀奇古怪的命令，而且命令行的设计也不怎么合理，有时候你需要加-f之类的参数，各个参数的位置可能不一致，而且加了还不一定能起到你期望的效果。各种奇怪的现象，比如"head detached"，都强迫用户去了解它内部是怎么设计的。随着Git版本的更新，新的功能和命令不断地增加，后来你终于看到命令行里出现了foreach，才发现它的命令行就快变成一个（劣质的）程序语言。如果你了解ydiff的设计思想，就会发现Git之类基于文本的版本控制工具，其实属于古代的东西。然而很多人把Git奉为神圣，就因为它是Linus Torvalds设计的。

Git最让人恼火的地方并不是它用起来麻烦，而是它的“资深用户”们居高临下的态度给你造成的心理阴影。好些人因为自己“精通Git”就以为高人一等，摆出一副专家的态度。随着用户的增加，Git最初的设计越来越被发现不够用，所以一些约定俗成的规则似乎越来越多，可以写成一本书！跟Unix的传统一脉相承，Git给你很多可以把自己套牢的“机制”，到时候出了问题就怪你自己不知道。所以你就经常听有人煞有介事的说：“并不是Git允许你这么做，你就可以这么做的！Unix的哲学是不阻止傻人做傻事……” 如果你提交代码时不知道Git用户一些约定俗成的规则，就会有人嚷嚷：“rebase了再提交！” “不要push到master！” “不要merge！” “squash commits！” 如果你不会用git submodule之类的东西，有人可能还会鄙视你，说：“你应该知道这些！”

打个比方，这样的嚷嚷给人的感觉是，你得了奥运会金牌之后，把练习用的器材还回到器材保管科，结果管理员对你大吼：“这个放这边！那个放那边！懂不懂规矩啊你？” 看出来问题了吗？程序员提交了有高价值的代码（奥运金牌），结果被一些自认为Git用的很熟的人（器材保管员）厉声呵斥。

一个尊重程序员的公司文化，就应该把程序员作为运动健将，把程序员的代码放在尊贵的地位。其它的工具，都应该像器材保管科一样。我们尊重这些器材保管员，然而如果运动员们不懂你制定的器材摆放规矩，也应该表示出尊重和理解，说话应该和气有礼貌，不应该骑到他们头上。所以，对于Git的一些命令和用法，我建议大家向新手介绍时，这样开场：“你本来不该知道这些的，可是现在我们没有更好的工具，所以得这样弄一下……”

====== 谦虚不是一种美德 ======


人们常说谦虚是一种美德，然而我发现其实并不是这样。

首先，谦虚是一种不诚实，虚伪的做法。这是因为谦虚的定义本身就意味着你要对自己的资质有所保留，直白点说就是，你要撒谎说自己其实没那么好！比如一个本来很有才华的人，做出了一个顶尖的研究成果，非要谦虚地说：“哎呀，比起某某大牛的成就，其实还差得远……”这种说法，把他自己的成果掩盖在别人的阴影之下，以至于让人难以看到它的价值，这对于世界的学术水平的提高其实是一种损失。谦虚本身就是一种谎言，你说它能是美德吗？

其次，谦虚的产生跟嫉妒有很大的联系。中国有句古话叫“枪打出头鸟”，就是人们嫉妒情绪的写照。如果一个女人很美，或者穿得很华丽，在场的所有女人就开始嫉妒她。如果一个男人很出类拔萃，同行的男人们都开始嫉妒他。所以呢，如果你称赞一个中国女人很美，她的回答往往不是“谢谢！我也这么觉得！”而是“哪里有~不如那谁谁谁……”如果你称赞一个中国男人很聪明，他往往对你说：“不敢当不敢当！哪有领导您聪明呢~”他们之所以说这样的违心话，就是因为害怕其他人的嫉妒，害怕其他人因为嫉妒而伤害自己。嫉妒是一种极其卑劣的情感，而谦虚经常来源于对嫉妒的恐惧，你说它能是美德吗？

所以，谦虚其实不是一种美德。它是一种虚伪，一种妥协，一种无奈。

====== 程序员的心理疾病 ======


由于程序员工作的性质，他们长期以来受到的所谓“黑客”式的“熏陶”，形成了一种行业性的心理疾病。这里我就简单的把我所观察到的一些症状总结一下。
无自知之明

由于程序员的工作最近几年比较容易找，工资还不错，所以很多程序员往往只看到自己的肚脐眼，看不到自己在整个社会里的位置其实并不是那么的关键和重要。很多程序员除了自己会的那点东西，几乎对其它领域和事情完全不感兴趣，看不起其他人。这就是为什么我的前同事 TJ 作为一个资深的天体物理学家，在一个软件公司里面那么卑微。貌似会写点 node.js，iOS 软件的人都可以对他趾高气昂的样子，而其实这些东西的价值哪里可能跟 TJ 知道的物理知识相提并论。很多科学家其实都 可以轻而易举的掌握程序员知道的东西，有人却认定了他们不是这个专业的，不懂我们的东西，或者故意把问题搞复杂，让他们弄不明白。让人感觉是在阴沟里翻了船被老鼠欺负。

如果力学工程师犯了错误，飞机会坠毁；如果结构工程师犯了错误，大桥会垮塌；可是如果软件工程师犯了错误，大不了网站挂掉一小时，重启一下貌似又好了。所以所谓“软件工程师”，由于门槛太低，他们的工作严谨程度，其实是根本没法和力学工程，结构工程等真正的工程师相提并论的。实际上“软件工程”这个名词根本就是扯淡的，软件工程师也根本不能被叫做“工程师”。跟其他的工程不一样，软件工程并不是建立在科学的基础上的，计算机科学也根本不是科学。
垃圾当宝贝

按照 Dijkstra 的说法，“软件工程”是穷途末路的领域，因为它的目标是：如果我不会写程序的话，怎么样才能写出程序？

为了达到这个愚蠢的目的，很多人开始兜售各种像减肥药一样的东西。面向对象方法，软件“重用”，设计模式，关系式数据库，NoSQL，大数据…… 没完没了。只要是有钱人发布的东西，神马垃圾都能被吹捧上天。Facebook 给 PHP 做了个编译器，可以编译成 C++，还做了个 VM，多么了不起啊！其实那种东西就是我们在 Indiana 第一堂课就写过的，只不过我们是把比 PHP 好很多的语言翻译成 C。我们根本不想给 PHP 那么垃圾的语言做什么编译器，让垃圾继续存活下去并不能证明我们的价值。

其实软件里面有少数永恒的珍宝，可惜很少有人理解和尊重它们的价值。这在其它的工程领域看来是不可思议的，然而这却是事实。由于没有科学作为理论的基础，没有实验作为检验它们的标准，软件行业的很多东西就像现代艺术一样，丑陋无比的垃圾还能摆在外表堂皇的“现代艺术博物馆”里面，被人当成传世大作一样膜拜。

为了凸显自己根本不存在的价值，又提出一些新的“理念”，就像有些现代艺术家一样，说“艺术的目的不是为了美，而是为了自由。”哦，这就是为什么你们可以自由地把那些让人反胃的东西放在博物馆里，还要买门票才能参观？
===== 宗教斗争 =====


当然了因为没有实质的技术，为了争夺市场和利益，各种软件的理念就开始互相倾轧。一会儿说软件危机啦，面向对象方法来拯救你们！一会儿又提出设计模式。过了一会儿又有人说这些设计模式里面有些模式是“反模式”，然后又有人把函数式编程包装起来，说是面向对象编程的克星，一会儿是关系式数据库，一会儿是 NoSQL，一会儿是 web，一会儿是 cloud，一会儿又是 mobile…… 每个东西都喜欢把自己说成是未来的希望。

这就是为什么有人说在软件行业里需要不停地“学习”，因为不断地有人为了制造新的理念而制造新的理念。在这样一个行业里，你会很难找到一个只把程序语言或者技术当成是工具的人。如果有人问你对某个语言或者技术的评价，是非常尴尬甚至危险的事情，所以最可靠的办法就是不做评论，什么都不要说。
===== 引难为豪 =====


在 IT 行业里批评一个技术难用，是一件非常容易伤自尊的事情，因为立马会有人噼里啪啦打出一些稀奇古怪的命令或者一大篇代码，说：就是这么简单！然后你就发现，这些人完全不明白什么叫做设计，他们以自己能用最快的速度绕过各种前人的设计失误为豪，很多程序员甚至以自己打字快为豪。

当遇到这样的人，我的经验是，千万不要恭维他们。你必须大声地嘲笑这些东西的设计，并且指出它们的失误之处，否则你不但助长了这些人的气焰，而且将来自己的自尊也难保了。很可惜的是不是每个人都有这种勇气把这些话说出来，这就造成了今天的局面，纷繁复杂的垃圾充斥着世界。爱因斯坦说，你需要很多的天才和非常大的勇气，才能追求到简单。

非常大的勇气…… 也许就是这个意思。
===== 去读文档！ =====


不知从什么时候开始，人们开始引用 Eric Raymond 的一篇叫做《提问的艺术》的文章，这篇文章后来就成为了对提问者没礼貌的借口。由于这篇文章的误导，当你希望同事能给你一个手把手的演示的时候，他们往往会丢给你一篇不知道什么时候写的文档，让你自己去读，仿佛文档就可以代替人之间的直接互动。况且不说这文档可能已经过时，里面有很多地方已经不符合最新的设计，而这意味着在潜意识里，他们觉得高你一等。他们甚至会对你说，如果每个新人来了我们都花这么多时间去指导他们入门，哪里还有时间干正事呢？然后你就意识到了，你在他们心里的地位，其实是如此的卑微和低下。

有的人稍微委婉一点，当你提问的时候，他们会二话不说打开一个浏览器窗口，在里面用 Google 搜索，然后指给你：看，就是这样。貌似比较礼貌，但那其实意味着他们在教训你：Google 一下就找到了的，自己不动脑筋！有谁不会用 Google 呢？提问的人恐怕是想得到 Google 不能给他的答案。真正有礼貌的人在不知道答案的时候是不会当面去帮你搜索的，他会对你说：“这个我也不知道…… 要不你搜索一下？”

在 IRC 的聊天室里，由于隔着网络的屏障，这种对提问者没礼貌的现象就更加嚣张。我曾经有几次去 Java 的聊天室问一些貌似基础，而其实很深入的语言设计问题，结果没有一次不是以收到像“去读 API！”这样的回答而结束。API 谁不会读，然而我需要的是一个有血有肉的人对此的理解。所以后来我根本不去 IRC 这种地方了，因为那里面对你打字的基本上已经不是人类了。他们觉得你问问题浪费了他们的时间，好像他们一天到晚泡在 IRC 里面就是在做什么正事似的。不想回答问题，不开口还不行吗。后来你发现，原来在 IRC 里面训斥新手就是这些人唯一的乐趣，所以其实他们是非开口说话不可的。然而这次他们遇到的却不是个新手，而是一个可以把 Java 整个造出来的人。

像 Haskell 之类的聊天室貌似稍微友好一点，然而后来你发现他们显得友好是有所企图的。因为当时 Haskell 还没有很多人用，他们需要吸引新手，所以竭尽所能的诱导他们。而一旦它用户稍微多了一点，有声势了，那些积极分子就成了专家一样的人物。他们就开始写书，然后就开始牛气哄哄的了。然后你就会发现当对 Haskell 的设计提出异议的时候，这些“id”们是多么的不友好，有理也说不清。所以最后你发现，其实所有语言的所谓“社区”都一个德行。如果 Haskell 有一天像 Java 一样如日中天（当然不大可能），肯定对大部分问题的答案也就是“去读API！”其实它已经在向这一步发展了。

不得不指出，《提问的艺术》等介绍“黑客文化”的文章对于这种现象的出现有着极大的责任。说穿了，写这些文章的人一般都是 Unix 的跟屁虫。这种文章试图抹去人类文明几千年来传承的文化，而重新给“礼貌”做出定义。其结果是，人类的文明因为这些文章，在程序员的世界里倒退了几十甚至几百年。很多外行人人不喜欢跟程序员说话，叫他们是 nerd，就是这个原因。
不要提问，不要谦虚，不要恭维

跟上面的症状相似，程序员世界里的一条重要的潜规则是：只有菜鸟才会问问题。所以如果你有任何机会可以自己得到答案，就不要试图向人“请教”，尤其不要显得好奇，否则你就会被认为是菜鸟。我有几次不耻下问的经历，最后导致了我被人当成菜鸟。我只是觉得那问题有趣，也许能够启发我设计自己的东西，所以吃饭时觉得是个话题可以说一下，结果呢就有人忙着鄙视你，那么小的问题都没搞清楚。正确的态度应该是诚实，直接，见惯不惊，那有什么大不了的，我什么没见过，我很怀疑。

随之而来的引论就是：不要谦虚！那些“职场经验”之类的文章告诉你的进入新的公司工作，要谦虚好问，对 IT 公司这种不讲美德的地方是不管用的。有的大 IT 公司有所谓的“文化”，比如叫你要“Googley”，要“humble”，其实只是用来贬低你价值的借口。他们要你向他们“学习”，但其实他们没有什么值得学习的地方。他们只是想让你安于“本分”，做一些微不足道，不能发挥你才能的工作。看看那些叫你要 humble 的人，他们 humble 吗？所以跟江湖一样，在 IT 公司里面一件很重要的事情是，亮出自己的宝剑和绝招，给人下马威。介绍自己的东西一定要自豪，这就是世界上最好的，无敌的，没有其他人能做到！不能有任何保留。不要像科学家一样介绍自己技术的局限性，否则随之而来的就是有些人对你价值的怀疑和对你自信心的打击。

另外要注意的是对于别人介绍的东西，不要轻易地表扬或者点头，否则有人就更有气势了。你要问这样的问题：这里面有什么新的东西吗？这个事情，另外一种技术早就能做了啊，没觉得有什么了不起。

哎，总之这样还是很累，所以最好是能不跟程序员讲话就不讲。
===== 以语言取人 =====


你的软件是什么语言写的，告诉别人的时候是千万要小心的，不到万不得已最好不要说。因为十有八九，对方会立即在心里对你的软件的价值做出判断，光凭你用的是什么语言。

很多程序员都以自己会用最近流行的一些新语言为豪，以为有了它们自己就成了更好的程序员。他们看不到，用新的语言并不能让他们成为更好的程序员。其实最厉害的程序员无论用什么语言都能写出很好的代码。在他们的头脑里其实只有一种很简单的语言，他们首先用这种语言把问题建模出来，然后根据实际需要“翻译”成最后的代码。这种在头脑里的建模过程的价值，是很难用他最后用语言的优劣来衡量的。有时候高明的程序员用一个语言并不是因为他只会用那种语言，而是其他的原因。他们的头脑里有着万变不离其宗的理念，可以让他们立即掌握几乎任何语言或者工具，所以他们对所谓的“新语言”都不以为然。可是很多人误以为他们不愿意学习“新东西”，从而从心里鄙视他们。其实计算机的世界里哪里有很多新的东西，只不过是有人给同样的东西起了很多不同的名字而已。如果连这样的程序员都不能理解你的技术，就说明你的技术设计有问题，而不是他们有问题。就像 Seymour Cray 说的，我只能理解简单的东西，如果它太复杂了，我是不能理解的。

早些年的时候，大家都认为招募某种特定语言的程序员是一种浮浅的做法，很多公司看重的都是解决问题的能力。可是近些年我发现这些浮浅的做法越来越普遍。可以说现在像 Google 这样的公司面试员工的方式和态度，其实还不如八年前我的第一份国内工作。很可笑的是，我离开 Coverity 之后那段时间面试的所有声称使用 Python 的公司，最后都认定了我是 Python 的菜鸟。然而如果你知道 PySonar 的技术含量就会明白，这样的东西需要水平高过 Python 的创造者 Guido van Rossum 很多的人才能造出来。在制造了 PySonar 之后，他对程序语言的理解，他的每一个错误都被我看得清清楚楚。当然，Ruby 就更烂了，我可以说，Matz 这人其实根本不知道他在干什么。

说到这些的时候，我很惊讶的发现有人来信告诉我，还是等你做出了什么“成就”再来说这些话吧。从这里我看到了“竞争”和“攀比”的思想在有些人心里是多么的根深蒂固，我也看出了这些“大牛”在他们心里是个什么地位。然而他们是激将不到我的，因为我根本没有跟别人“比”的意思。说实话吧，就算你打死我，我也做不出有那么多毛病的语言来。我两个小时之内设计个语言都比 Python, Ruby, JavaScript 要好很多。我不可能以“超过 Python 和 Ruby”这么肤浅的目的为动机，来达到别人所认同的“成就”。打个比方，我有什么必要证明我比 Justin Bieber 或者 Lady Gaga 强呢？我根本不明白这些人到底有什么成就，也完全没有必要向他们的粉丝证明我的价值。在这几次有伤自尊的面试之后，我再也不会给任何使用 Python 作为主要语言的公司工作。
===== 跟屁虫 =====


有些程序员对新手和同事是那么的不友好，然而对大牛们拍马屁的功夫可真是出类拔萃。我刚到旧金山的几个月有时候参加一些程序语言的“meetup”，后来我发现这种 meetup 都是宗教气氛非常浓厚的地方，跟传销大会差不多。Scala 的 meetup 里面的人几乎全都对 Scala 和 Martin Odersky 顶礼膜拜，甚至把 Rod Johnson 请来说一堆胡话。Clojure 的，当然基本上把 Rich Hickey 当成神，甚至称他为“二十一世纪最重要的思想家之一”。各种 talk 总是宣扬，哇，我们用 Scala/Clojure 做出了多么了不起的东西云云，其实只不过是在向你兜售减肥药。

很多人喜欢做这些新的语言和技术的“evangelist”，尽显各种马屁神功，然后就开始写书，写 blog，…… 目的就是成为这个“领域”的第一批专家。这就难怪了，再垃圾的语言也有一大批人来鼓吹。因为这些没真本事的人，随便把一个东西捧上天都有自己的好处。

由于受到这些“先知”的影响，有些人开始在他们自己的公司里“布道”。比如有人在 Python 的 meetup 集会时告诉我，他试图在自己的小组里推 Python，可是一些老顽固一定要用 Java，认为 Java 才是王道。很鄙夷不高兴的样子。我并不认为 Java 是很好的语言，然而 Python 也好不到哪去。它们在我眼里只不过是临时拿来用一下的工具，可是我仍然能用它们写出一流的代码。

看到这些宗教性质的聚会，我终于理解了一些地区是如何被从一个国家分裂出去，最后沦落为另外一个国家殖民地的。最早的时候，一般是派传教士过去“传经”，然后就煽动一小部分人起来造反。到后来就可以名正言顺的以“保护传教士”，“保护宗教自由”，“维持和平”等理由把军舰开到别人家门口……


　　
====== 黑客文化的精髓 ======


听说“黑客文化”这个词，就像在昨天。想起它，眼前就出现一些头发蓬乱，穿黑色道袍的人。最早的时候，他们努力地向人们澄清：“黑客”不是贬义词，不是指那些入侵电脑网络的罪犯。当人们明白过来之后，他们开始告诉人们如何成为一个黑客，并且把黑客与画家相提并论。当人们受到鼓舞，决心成为黑客之后，他们开始向这些人灌输黑客的“行为守则”，“提问的艺术”等等。总之就是说，你得显示出一些非常重要的特征以证明你是高手，并且教育那些菜鸟们。否则按照我们的标准，你就不是个黑客！

于是忽然间，我来到了这个黑客遍地的世界。体验着，忍受着自己向往已久的“黑客文化”。
===== 某大牛说…… =====


一个中等水平的黑客要说服一个菜鸟水平的黑客，方法很简单：引用一个超级黑客的话。至于为什么嘛，我也不知道，总之你照办就是了。最好记住那超级黑客的名字，以后再遇到不懂事的菜鸟就用同样的方法教育他，免得我亲自来动口舌！
===== 笨蛋才不会用这个工具 =====


黑客的世界里有很多背着历史包袱，设计拙劣，你却不得不用的工具。黑客文化的其中一个作用就是掩盖这些工具的设计失误。这定律被我叫做“都是用户的错”。

你的智商和能力被一些肤浅的标准所衡量，你每天都在提心吊胆的接受各种审查。这两个 Git 命令的区别都不知道？还当什么黑客！哪个学校毕业的？老师连这都没教过你们？哎，算我面试时看走眼了。

于是为了显示自己有能力，接受过良好的教育，你不敢再问这种问题。为了避免再受伤害，为了掩饰自己的“无知”，你变成了一只刺猬。你开始用自己会的那点东西去审查其他人，伤害其它人，以为这样就可以保护自己。这些被伤害的人又转而去伤害更多的人。

Visitor pattern 都不会写？还当什么黑客！这厮今天终于让我抓住把柄了 :)
===== 只有天才才能理解它的简单 =====


某超级大牛说过，我的系统是简单的，但只有天才才能理解它的简单。

你敢说我的系统不简单？哼哼，那你肯定不是像我一样的天才。你知道吗？其实我爷爷的爷爷是给皇帝做衣服的。他的座右铭是：看不见这衣服的人都是白痴或者不称职的人。

所以你不敢说任何东西太复杂，太难用，太不可视化，对用户不友好。否则就会有人鄙视你：菜鸟，白痴，人笨怪刀钝！
===== 择其难者而从之 =====


做一件事有两种方法，一种容易一种难，你会选择哪种？

普通人都会选择更容易的，但是很奇怪的是，受到黑客文化熏陶的人，往往会选择困难的那种。如果这选择只是个人的喜好，如果他们尊重其他人的选择，那还无所谓了。但十有八九，选择了明显更加难用的工具的人，并不会从心底尊重那些选择更加容易的工具的人。这貌似是一种必然的结果。

这其实是心理上的优越感在作怪。很多人选择困难的工具，并不是因为真的觉得它们好用，而是因为只有用其他人不会的东西，才能显示出自己的特殊性，显示出高人一等的水平。由于其根本的动机就来自于优越感，所以他们是不可能不找机会利用这得来不易的优越感的。

有些人虽然可能口头上不说，但他们随时都在观察，看其他人选择了哪一种工具。那些选择了（或者倾向于选择）更容易的方法的人，会在他们的印象中产生一种肤浅的感觉，从而不会真正的被尊重。这种不尊重累积起来，就会开始隐约的表现出来，从而导致同事间工作关系的恶化。当然也有人更加露骨一些，直接就问别人选择了什么工具，然后嘲笑那些选择了容易工具的人为菜鸟。

常见例子：

    VIM 与 Emacs，选择 VIM
    Emacs 与 IntelliJ（编辑 Java），选择 Emacs
    组合键与方向键（移动光标），选择组合键，因为“并不是每个键盘都有方向键的！”
    Linux 与 Windows，Mac，选择 Linux
    Gentoo 与 Ubuntu，选择 Gentoo
    Terminal 与 GUI，选择 Terminal，使用黑底绿字
    TeX 与 Word，选择 TeX，拒收 .docx 附件
    C++ 与 Java，选择 C++

===== RTFM! =====


RTFM = Read The Fucking Manual!


惯用法：有人在#java聊天室问了一个问题，结果大家回答说：“RTFM！”“菜鸟，去读了 API 再来这里混！”
===== 你不会 Google (百度）吗？ =====


当这种现象普及开来之后，普通的问题你都不能问别人了。比如：“哎，今天会不会下雨呢？”因为在黑客文化里，别人的回答会是：“你不会 Google 吗！”当然，在中国这句话就是：“你不会百度吗！”

就像 IRC 里面的人一样，我不明白他们为什么在那里面，仿佛他们唯一的乐趣就是告诉别人“你不该问这个问题”，“你浪费了我的时间”。当这种现象普及到更广的社会，你知道会有什么结果吗？任何人都不要再对任何人说话了，因为说话全都是浪费时间。

“你不该问这个问题”这种说法是非常大的攻击行为，它是人类良好社会关系的杀手。其实对别人“该不该问这个问题”的“考虑”本身就是一个错误。我们甚至不应该说“你可以问这个问题”，因为那应该是不言而喻的，想都不用想。

任何人都允许问任何问题并不等于会浪费你的时间，因为你并不是必须回答每一个问题。所以我的做法总结下来就是一句话：我誓死捍卫你问问题的权利和尊严，但我不一定要回答你。比如在 IRC 聊天室，如果遇到有很初级的问题我懒得回答或者太忙，我不吭声就是了。我对问问题的人没有任何反感，我只是等其他人去回答他。但是“你不会 Google 吗！”肯定是非常不礼貌的做法。
===== 你问我，所以你懂的没我多 =====


子贡问曰：“孔文子何以谓之文也？”子曰：“敏而好学，不耻下问，是以谓之文也。”

可不要被孔老二误导了！在黑客文化里，这种不耻下问的行为是相当危险的。一次可能还好，多几次之后，我看你不被当成傻b菜鸟才怪。
===== 希望你向我们学习 =====


进了新的黑客公司很兴奋哈？可是发现代码里有不大好的地方怎么办呢？如果吭声，立即讨人嫌。如果不吭声，那就等于承认了我们的代码是“模范”咯。跟着学吧，小弟。要学像哦！
===== 这就是我们的作法 =====


我们刚从某大公司挖来一个世界级高手。结果他对我们引以为豪的一段代码提出了异议，说那是 premature optimization，思路不清晰。切！

虽然他是世界级的高手，可我们才是这里的地头蛇，所以我们得告诉他：“这就是我们的作法！”
===== 结束语 =====


上面的小片段，估计在你自己的生活中已经出现过很多次了吧？它们也在我的生活中出现过很多次。不同的学校或者公司，有可能出现其中的几种或者全部。其实哪里来的什么“黑客文化”？文化就是文化，管你做什么工作。不要忘了黑客不过是一种工作，跟医生，律师，厨师，教师一样的。所谓黑客文化只不过是为一些人的各种无理怪癖找借口，搞特殊化。

按照以上标准，我不认为自己是个黑客。我是一个计算机科学家，我按照几百年来国际通用的礼节行事。计算机科学家与黑客的区别在于他不只按照工具的手册来完成规定的任务。他经常记不住别人设计的复杂工具如何使用，因为他本人是一个更好的设计师。他审视这些工具的设计合理性，发现蹩脚的地方，然后构思更好的设计方案。他总是嘲笑和自嘲，我们其实仍然生活在计算机的石器时代。

在自己的公司里，我希望创造一个更加人性化的氛围，而不是宣扬所谓的黑客文化。让所有人无论男女，无论水平如何都身心舒坦，受到尊重，可以谈天说地，不耻下问。

如果上面有我没有概括到的经典情况，欢迎来信告诉我。


====== 我和 Google 的故事（2015 修订版）======

2009 和 2010 年，两年的夏天我都在 Google 实习，然而最后毕业的时候我却没有为 Google 工作。虽然我心里很清楚这里面的原因，可总有些人觉得不解，为什么居然有人不想为 Google 工作？如果你是这些人其中之一，那你可能想知道我在 Google 时的切身感受。

直到将近 2015 年新年的今天，我发现这篇文章仍然具有普遍的意义。面对 Google 的员工，我仍然是同样的感觉。他们很多人太拿自己的公司当回事了，自高自大，放弃自己的尊严来舔这个公司的屁股。这些人总觉得好像所有人都希望为 Google 工作，即使进不了 Google，都想去 Google “蹭饭”似的。如果一个人说“我很厉害”，我也许会尊敬他，可是如果他说“我为 Google 工作”，以此来显得厉害，我就会鄙视他。我只尊敬那些尊敬他们自己的人。以自己的公司名声来抬高自己的人，是最被我瞧不起的，因为他们跟仗着人势的狗没什么区别。

===== 进 Google 很难吗？ =====


每当我告诉别人我在 Google 实习过，总有人说：“哇，你好厉害。Google 很难进的！”我说：“一点也不难啊。”他就会说：“你一定是从 MIT 之类的牛校毕业的吧？”然后我就无语了，我不屑于跟这样的人说话。首先，进 Google 的门槛真的很低。说白了，Google 只需要一些低级码农而已！世界上有很多比 Google 技术精深而且尊重个人的公司，所以 Google 并不是很多有志之士的首选。其次，我厉害并不是因为我从 MIT 或者其它什么牛校毕业，而是因为我自己的资质。这种资质不是读了 MIT 或者 Stanford 之类就可以得到的，所以其实我根本不把这些牛校当回事。相反，我看不起这些学校，觉得它们不但徒有虚名，而且相当浮躁。所以说这话的人原意是奉承，结果反倒贬低了我的个人价值，招致我的轻视。

能进 Google 确实是因为我很厉害，但其实比我弱很多的人也可以进 Google，所以能进 Google 根本不能说明我的实力。你认为我到 Google 实习，我的导师们很高兴，很支持，觉得很荣耀吗？恰恰相反，他们觉得我贱卖了自己，我本来应该去更好的地方。当我回到学校，我发现自己成了师兄，老师们的嘲笑对象。有个在 Google，微软研究院等地方都实习过的师兄说：“Google 那种地方去一次就够了，你居然去了两次！”有新同学问道，从我们这毕业，将来能去 Google 工作吗？有个老教授笑笑说：“那个还不容易？Google 招收任何可以做出他们题目的人！”其实正当我在 Google 实习的时候，有在微软研究院的同学来找我，很不解的样子，说：“你为什么不来微软研究院？Google 根本不是搞研究的地方。”后来我才发现，微软对员工个人价值的尊重，明显好于 Google。在微软工作，你至少不需要舔微软的屁股。

那么既然不是那么喜欢 Google，我为什么还要去 Google 实习呢？其实原因很简单很世俗，我当时需要一些钱，而 Google 是最容易进去挣点钱的地方。我这人从来不担心所谓的“前途”或者“事业”，因为我知道自己能力有多么强大。我不觉得为任何公司工作是一种荣耀，我只是有时候拿我很小的一部分技术，出去换点吃的回来。看上去很市井小民吧？但这个世界就是如此，我只是跟它做交易。我就像一个雇佣杀手，专门搞定别人都搞不定的事情。得到这些技术的公司（包括 Google，Coverity，Sourcegraph），其实都很是赚了一笔，因为我卖给他们的东西，比他们给我的工资，价值要高很多。如果没有我，他们可能永远也不会做出具有同样高品质的东西。我敢打赌！

好了，还是来看看我在 Google 的时候都发生了些什么吧。
===== 受命于危难 =====


先说说我的项目是怎么开始的吧。当我加入的时候，我的老板 Steve Yegge 的小组试图制造一个跨语言的“服务器”式的编程工具，叫做 Grok。你可以把它想象成 Eclipse, 但是 Grok 的设计目标不只是像 Eclipse 那样检索和分析本机的某一种语言的代码，而是大规模的检索和分析 Google 的所有项目，所有语言，所有代码。这包括 Google 的“四大语言”：C++, Java, JavaScript, Python，一些工具性的语言：Sawzall，protobuf 等，还有一些“build file”和所有第三方的库。Grok 的初期设计目标是一个静态的代码索引服务，只要程序员点击任何一个变量或者函数名，就能“准确”的跳转到它定义的位置。动态的编辑功能稍后也在陆续加入。

这种检索不是像 ctags, etags 那种简单的正则表达式匹配，而是像 Eclipse 和 Visual Studio 那样的准确的“语义检索”，所以它必须真正的理解程序语言的语义。在 Grok 诞生以前，市面上和 Google 内部都没有一个工具能正确的支持所有“四大语言”，所以我不得不说，Steve 的项目比起 Google 的其它跟编程语言相关的项目，是相当先进的。

虽然 Grok 的技术含量很高，但是 Google 的管理层对东西的评价并不是看技术含量的，而是看你有多少“影响力”(impact)，说白了也就是有多少用户。Google 当时本来就只有不到一万个程序员，一个“内部编程工具”能有多少“用户”呢？所以 Grok 比起像 CodeSearch 一类利用正则表达式来查询程序的“低端”项目来说，在管理层心目中并不占任何优势。而且由于其它项目界面好看些，用户多些，Grok 随时有被取消的危险，这使得 Steve 心理压力很大。我就是在这个“危难关头”进入他们的小组的。我当然没蠢到会自己进入这样一个组，但是 Steve 在电话面试时把一切都说得很美好的样子。当时小组里只有三个人：Steve 和另外两个组员。
===== 不安全感，恐惧和疑惑 =====


在整个实习的过程中，我都感觉到我所在小组成员的不安全感，这引起了他们的恐惧和疑惑。这种不好的心理状态持续了整个实习过程，使得我在别人的怀疑当中生活了三个月！我不知道如何安慰他们或者让他们相信我的能力，就像我不知道如何安慰一个没有安全感的女朋友。这种感觉，就像是一个女生不相信自己的魅力可以招来这么好的男朋友，所以各种怀疑，纠结，蛮缠。对于 Google 来说，就是不相信自己可以招到这么厉害的实习生。

当我开始的时候，Grok 小组已经初步完成了 Java 和 JavaScript 的检索模块。但是他们的检索并不是从头设计的，而是从 Eclipse (JDT) 和 JSCompiler 里面分别“挖取”了对 Java 和 JavaScript 语义检索的部分，修改之后插入到项目里的。Eclipse 的设计非常的不模块化，以至于项目进行了一年多，大家还在忙着解决它带来的各种 bug。

最开头的时候 Steve 给了我两个选择：检索 C++ 或者是 Python。我觉得 C++ 的设计太繁琐，所以就选择了看起来好一点的 Python。Steve 就让我去找一个好一点的开源的 Python IDE，然后把里面的语义检索部分挖出来插入到项目里面。可是在看过十个左右的“Python IDE”之后，我发现它们没有一个能够正确的“跳转到定义”。分析其原因，是因为这些 IDE 基本上做的是正则表达式匹配，而完全不理解 Python 的语义。所以我对 Steve 说，我要自己从头写一个。但他反对这个提议，因为他觉得这是三个月的时间之内不可能完成的。不但是我不能，而且就算一个小组的高级程序员也不可能完成。就算完成了，他也不想“维护”这些代码。所以他宁愿让我去拿一个不怎么样的开源项目，因为这样“维护”的工作就转嫁到开源项目身上去了。这也许就是 Google 支持开源运动的原因吧？

可是我很清楚的看到，这样一个语义检索，不过是一个抽象解释器 (abstract interpreter)。写解释器是我最在行的，所以我告诉他这是我可以完成的，而且由于设计上的简洁，我的代码的维护代价会比使用一个开源项目小很多。他没有说话。我同时也在进行一些内部培训，看一些视频，折腾 MapReduce 一类的内部工具教程，就这样过了一个星期。我隐约的感觉到 Steve 的不快，因为他不怎么说话了，可是我也没有太在意，仍然傻乎乎的到处凑热闹。到了周五的时候，Steve 下午很早就回家了。另一个组员还待在哪里，不时的叹气。我对她说：“Steve 是不是不高兴了？我知道我说话有点太自信，可能打击到他了。”她好像打满的气球被开了一个洞：“他怎么会被你打击到？你知道他以前做的项目有多厉害吗？他是怕你做不出来。之前有一些 intern 设的目标太高，以至于到最后没有完成他们的项目。”于是她打开 Eclipse，把 JSCompiler 的代码给我看。“你知道我们以前一个类似的项目 JSCompiler，花了多少时间才完成吗？一个小组的人，四年的时间！”她打开其中一个文件，也就是处理符号表的那个模块，说：“看这一个文件就有 9000 多行代码。你三个月能写出这么多代码吗？”我翻了一下白眼，搞笑似地说：“啊～ 怎么可能有 9000 多行？这些人真的知道怎么写这种代码吗……”

后来具体的对话我忘记了，但是她确实给了我一些压力，再加上 Steve 那个闷声子，真是不好受。所以那个周末我没有出去玩，我下载了一个 Jython，把它的 parser 文件 (ANTLR) 拿出来。然后自己设计了一个更简单的 AST 数据结构，把这个 parser 生成的 AST 转换成我的结构。然后就开始在上面写一个抽象解释器。由于 Java 的限制，我想出了一个更简洁的用 Java 实现解释器的方法，从而避免了使用繁琐的 visitor pattern。一个周末之后，我做出了一个基本的原型。当然因为 Python 语言的复杂性，有很多细节的东西到后来才完全的实现。

等到星期一的时候，我告诉 Steve 我做了一个原型出来，而且因为我拿了 Jython 的 parser，我们以后可以用这个理由把这代码 merge 回 Jython，给他们提供功能，让他们帮我们维护代码，对两方都有好处。他居然一点也不高兴，把我叫到一个白板前面，板着脸说：“来，给我讲一下你打算怎么做。”我就画了一个 AST 的类关系图，在里面每个类插入一个叫 interp 的方法，然后指出这个东西就是一个抽象解释器。最后他豁然开朗了一样，说：“好。我相信你知道你在干什么了。就这样做吧。”

虽然貌似经过我自己的努力和坚持，从头做一个工程的计划被接纳了，但是这却不是说之后就没有压力了。这种感觉就像是“皇帝的新装”里的织布工一样。我扬言自己会做出精美绝伦的布料，皇帝的大臣们却看不见，所以他们就相当的小心。总是对我很敬畏的样子，有时会来问候一下，做得怎么样了。可是一旦扯到深入的话题，却又怕被看穿其实他们不懂很多东西。
陌路

在 Google 的整个夏天我都觉得跟其他人没有共同语言。我感兴趣的东西，他们一点都不了解。我觉得不以为然的一些东西，却被他们捧上了天。比如，有一次几个人在谈论一个 Google 的“牛人”，说他做了一个多么了不起的项目，很快就升为了 Staff Software Engineer （“Staff”是比“Senior”高一级的职位，Steve 就是个 Staff）。我去看了一下这项目，发现不过就是 JUnit 的“C++ 版本”。JUnit 这东西技术含量本来就是相当低的，做这样一个东西就能当“Staff”，那我岂不是轻而易举就可以成为“Principal”了？哈哈。我心里这样想，但是没有说出来。一个 Staff 就如此，谈到 Google 的两个创始人的时候，有些人就简直是黑白不分了。对他们的各种武断的甚至愚蠢的做法，居然都津津乐道。创始人在他们眼里俨然就跟皇帝一样，他们做什么都是对的。这种浮夸和互相吹捧之风，恐怕是在其它公司也少见的。Google 要求员工们保持一种“Googley”的态度，原来就是这样的态度，过度“正面”和“积极”。西方所崇尚的“个人主义”和“批判性思维”，我在 Google 还真的没有见到过。

另一些时候，我会遇到一些对某种语言或者技术有宗教情绪的人。有次一个工程师坐到我面前，像是在面试我一样，表情严肃正儿八经的开始自我介绍，后来我们就谈到 C++。我说 C++ 设计实在是太繁琐了，其实很多简单的语言效率并不比 C++ 低，C++ 最近其实在向其它高级语言学一些东西…… 后来这人就不说话了。那天以后我就发现跟他打招呼他都不理了。后来我才发现，在 Google 是不可以指出某种语言，特别是 C++ 的缺点的。C++ 在 Google 的势力之大，连 Java 都只能算二流货色。

最让我受不了的其实是 Google 的气氛。总体感觉就是过度“和谐”，没有人说真话，以至于你不知道什么好，什么不好。很多文档，视频，活动都挂着“Google Confidential”的标签。等你去看了，却发现相当幼稚，其实是众所皆知的东西，没有什么机密可言。可是大部分的实习生们却有一种受宠若惊的感觉，或者假装有这种感觉。每个星期五，都会有一个“TGIF”，两个创始人会像主持人一样组织一个大会。本来无可非议，但是总感觉气氛过于群情激昂了，有点像文化大革命时候念红宝书的感觉。好不容易大家聚在一起，总是在听新闻发布，不然就是谈工作。真正大家一起玩的 party，却非常稀少。所以一些别的公司的人都在疑惑，Google 的员工到底有没有下班的时间。

我就是这样度过在 Google 的每一天，以至于后来我都不怎么在饭桌上吃饭了。自己把饭端到靠墙的吧台去吃，或者坐在“冰激凌吧”跟里面的厨师聊天，省得遇到一些高谈阔论的人无语。我发现自己跟打扫卫生的大妈小妹们也谈得来，她们也喜欢跟我说话。后来我发现有这种感觉的不只是我，另外两个比较厉害的博士生也懒的在那边吃饭了。其中一个说，Google 的人太傻了，他一个星期就把组里给自己三个月的项目做完了，因为这帮人完全不知道自己在干什么。
===== 压力 =====


直到有一天，我才发现 Steve 为什么这么紧张。那天有另一个“分舵”的 director 来访。他给我们做了一个关于“创新”（innovation）的演讲。基本内容就是说，技术上的创新，如果吸引不到用户，那就不算什么创新，拉得到用户的东西才叫创新。

那天下午，这个 director 来到我们的办公室。表情严肃的“审问”Steve：“你说你每天有 5000 个用户。可是 Google 总共还不到 10000 个程序员。你是怎么算的？你把接受你的服务的那些下游项目的用户全都算进去了吧！”唉，想不到大名鼎鼎的 Steve Yegge 在这种皇帝的钦差大臣面前也只能唯唯诺诺。

我可以说，这个 Python 的东西，虽然不费我很多力气，但却是 Google 里很少有人可以做出来的。就算 Python 的创造者 Guido van Rossum 恐怕也玄，因为这需要比设计出 Python 这样的语言高深很多的专业知识，比如类型理论（type theory）和抽象解释（abstract interpretation）。所以实际上我的这个东西在很大程度上拯救了这个濒临灭亡的项目，因为一旦 Grok 支持所有的“Google 语言”，就会有很多人注意到这个东西，从而会有“影响力”。这确实是后来发生的事，我走了之后，Grok 开始通过 API 给很多项目提供服务，包括 CodeSearch。

可是这种“上级领导”的压力居然也间接的传到了我身上，而且是以一种不尊重的方式。这种感觉就是，你做得再多再出色，你相对于 Google 的“大拿”们，什么都不算。这也许就是 Google 为什么雇佣 Dennis Ritchie, Brian Kernighan, Ken Thompson, Rob Pike, Guido van Rossum 等大牛吧。因为它就可以说：“看我们 Google 有这些顶尖牛人，相比之下你算个什么，要不断努力！”Steve 不止一次的对我说：“你要为 Google 做出杰出的贡献啊！Google 的东西总是最好的，你要做出 Google 一贯的品质来。你知道 Python 的创造者 Guido 也在 Google 吗？我一定会在他面前给你美言几句。”这种语气，我好像在几十年前的中国听说过呢？“你要为祖国做出杰出的贡献！”他也许以为我会受宠若惊，可是我心里却不是个滋味，因为在我心里，自己的地位一点也不比这些大牛低。“宠为下”的道理，你懂吧？

总之他们就是用这种奉承，利诱，竞争，加威胁的方式，想方设法让我多做事情。可是我心里想的是，Google 老爹，您就给了那么点钱，您想买多少东西啊？本来这系统能做出来就不错了，一个组员却一直催着我写 test。她根本不明白，一个程序并不是写了测试就会是个好程序。这个程序经过我多次的大规模修改甚至推翻重来，即使一早写了测试，那些测试也会很快作废。这种大公司给人灌输的“test-driven”编程方式，在这种创造性的程序设计里是根本就是行不通的。要写出这样一个系统，必须全神贯注，深入到语言的本质。而去写测试，往往会打乱原来的思路，所以测试应该是最后完成之后才写的。当我最后完成这个系统，可以大规模的处理 Python 代码的时候，却听见从她的桌上传来一声沉闷的咆哮：“WRITE--THE--TESTS---”这真的非常的 Googley！
===== 结果 =====


最后我顺利完成了整个项目，还没少休息和玩耍。现在它仍然是世界上最精确的 Python 分析器，每天都会把 Google 所有的 Python 代码索引一遍。很多内部工具比如 CodeSearch 里面的 Python 文件上的链接，都是这东西做出来的。我所有的代码加起来才 4000 行。处理符号表的模块只有 600 行。我怎么也想不通为什么 JSCompiler 会有 9000 行来处理这么简单的东西，但是也许这就是为什么 JSCompiler 花费了四年时间。
===== 总结 =====


所以你看到了，这就是我对 Google 的印象。那种文化大革命似的气氛和对个人价值的忽视，就是我（以及其他很多有志之士）至今不为 Google 工作的原因。Google 是一个年轻的公司，所以比起 IBM，微软之类成熟稳重的老牌公司，确实难免显得浮躁。也许多年以后等它成熟起来，懂得如何尊重个人价值之后，我们还有合作的机会。
参考资料

如果你想从另一个角度看看 Google 的问题，可以参考一下 James Whittaker 的博文《Why I left Google》。这个 James 当时是 Google 的一个 director，是 Steve 的老板。我从来没跟他仔细说过话，所以我不能对他做出任何评价。这个文章仅供参考。

====== 怎样成为一个天才 ======


有人说我是天才。我一直“谦虚”得很， 从来不承认。可是纵观像 John Nash，Richard Feynman 这些公认的天才的各种特征和生活遭遇，我发现自己还真是一个天才。我知道这个事实已经很久了，这一方面让我开心，另一方面又让我痛苦。可是除非洗脑技术高度发展，一旦成为了天才，就很难再还原成普通人了。所以目前我只是做一天天才撞一天钟 :)

那么天才到底是什么呢？我想这是很多人都不明白的问题。大部分人都是人云亦云，别人说这人是天才，他们就以为是天才，也不仔细看看这人思想如何，就开始膜拜。所以现在我作为一个天才，本着学究的态度，对天才的本质做一个探讨，然后介绍一下成为天才的方法。
===== 天才和聪明的区别 =====


很多人都把天才和“聪明”混为一谈，以为天才就是非常聪明，头脑特别快，或者记性特别好的人。可是天才往往并不显得聪明，想问题也并不快，而且记不住很多东西。天才的价值并不在于快，而在于他们能想出其他人都想不出来的东西。

人们的这一误解往往是因为媒体和传记作家对天才的肆意吹捧。传说有人问过冯诺依曼一个问题：两列火车相距100公里面对面行驶，时速50公里。一只苍蝇以时速75公里在两个火车头之间来回飞，碰到一个火车头就掉头飞向另一个，如此反复。请问苍蝇被这两列火车挤死的时候飞过了多少距离？冯诺依曼眨了一下眼说：“75公里。”这人很惊讶，问冯诺依曼你是不是听说过这道题，用了捷径。 冯诺依曼说：“什么捷径？我只不过做了一个积分而已。”

这就是一个典型的“都市传奇”（urban legend）。我觉得冯诺依曼只不过是幽默了一下，结果就被某些人永远的记录在册。这种故事的负面作用，在于它夸大了天才头脑的“硬件性能”，让其他人觉得成为天才是可望而不可即的事情，从而对其进行膜拜。能快速的心算做积分，真的是很了不起的事情吗？恰恰相反。夸大头脑的速度，其实贬低了冯诺依曼，让人误以为头脑速度快就是他的天才之处。现在如果你把这积分式子输入到 Mathematica 或者 Maple 里面，不到一秒就算出来了。这机器都能做的事情，能说明人是天才吗？冯诺依曼的天才不在于他自己的头脑速度快，而在于他提出的一些理论，导致了比任何人的头脑都要快很多的机器的产生。这些机器产生的目的，是为了帮我们偷懒，把我们从繁琐枯燥的计算活动中解脱出来。

所以，头脑的硬件性能并不是天才的本质特征。头脑速度快的人，跟跑得快的人差不多，只是体力比较好。我欣赏跑得快，体力好的人。大自然赋予了他们其他人没有的财富，但那并不叫做天才。也许那种天赋的速度比天才还要难得，但天才往往不喜欢太快，因为过快的速度会让人变成机器，停止思考，走上歧途。天才喜欢反复审视前进的方向，所以他们经常能找到偷懒的方法。天才喜欢偷懒，并且利用巧妙的设计让大家都可以偷懒。
===== 从动手中学习（learn by doing）=====
如果你看过 John Nash 的传记《A Beautiful Mind》，就会发现他与其他人的不同。Nash 看书只看封面和开头，把这书要讲的问题了解清楚之后，就自己动手解决。最后，他完全依靠自己的“头脑暴力”创造出整本书的内容。Nash 头脑里的数学知识，绝大部分是他自己造出来的，而不是看书看会的。也就是说，他把整个的研究领域作为一道道的练习题，用这种方式独立创造出了大部分的现代数学！Learn by doing, 这就是天才最重要的特征。

另一位天才 Richard Feynman 也有类似的特点。由于他脑子里的东西基本都是自己想出来的，所以同一个名词，在他头脑里关联的概念，其实是跟其他人很不一样的。这种现象体现在他的自传《What Do You Care What Other People Think?》里面，他说：“我不知道这个东西的名字，但我却知道这个东西是什么。”这也体现在他的一些演讲视频里。看 Feynman 演讲的时候，有时候你发现他用错专业名词，或者想不起来叫什么，跟听众确认了发明这概念的人不在场，然后说：“反正那家伙不在……所以管它叫什么呢。你们知道我在说什么就行！”

天才往往依靠自己的直觉和想象力，而不是经验。这就是为什么爱因斯坦说“想象力比知识更重要”。天才记不住那些吓人的名词，却更深刻地知道那些名词所代表的意义。天才不喜欢显示自己知道很多，不以自己“不知道”为耻，因为虽然他可能暂时不知道一些东西，却总能在需要的时候琢磨透彻，所以知不知道一些东西，很多时候其实是无所谓的。也许这就是所谓“大智若愚”吧。
===== 怎样成为一个天才 =====


现在我来讲一下，如何成为一个天才。其实说实话，我现在有点后悔自己为了成为天才费了这么大力气，放弃了那么多的乐趣。所以看过这段之后，你也许就不再想成为天才了。不过如果你执意要做天才，也许会受到一定的启发。

人们常说，天才出于勤奋，所以首要的一点是你必须为此投入巨额的努力，甚至做出巨大的牺牲。从我的经历来看，这一点也不假。天才都是孤独的，因为只有孤独，他们才能有自己的时间和空间来进行思考。为了成为今天的自己，我放弃了很多其他人追逐的东西，可以说是经历了千辛万苦。

仅就孤独这一点，就足以让很多人望而却步了。但仅有艰苦卓绝的勤奋，也不一定能成为天才。你必须把勤奋用在巧妙的地方。在计算机领域，很多人喜欢抱着大部头的专业书籍看，其实那是事倍功半的努力。学而不思则殆，就是这个道理。书籍让你记住了现成的“事实”，却不能让你拥有产生出这些知识的能力。它们只是把你“训练”（train）成了循规蹈矩的流水线工人，而不能让你受到真正的“教育”（education）。真正的好书都是很薄的，“把厚书读薄”这句话其实是误导的。厚书本来就不应该拿来读，最多可以拿来当字典查。所以我的建议是：如果你想成为天才，就避免去读厚书。去寻找简短的书来入门，然后就可以自己思考了。这就是我从 Nash 的故事得到的启发。

笛卡尔（René Descartes）写过一篇文章，讲述如何成为一个天才。他说，在人生中的某个时候，他决定开始仔细检查自己头脑里的思想。他翻出自己所有的想法，寻找它们的最初的“来源”，然后审视它们。这种来源有可能是父母，有可能是传统，有可能是学术权威。当他发现某个来源有问题的时候，他就抛弃从这个来源获得所有想法。我从这篇文章得到了启发，所以我也用了很多年时间，对自己头脑里的想法做了一件差不多的事情。你可能很难想到，一个不知不觉窜到你头脑里的错误想法，会导致你永远无法发现更好的东西，甚至会毁掉你的一生。因为这个原因，我抛弃了很多未经思考就接受的权威的思想，我抛弃了很大部分的中国传统，我审视美国和世界的文化，尽一切可能的防止错误的思想进入我的头脑。所以虽然我并不富裕，我却拥有比很多富有的人更多的自由。这种自由，给了我思考的时间和机会。

要成为天才，必须要能够打破别人设下的思维圈套。去除自己头脑里的各种权威，是非常重要的事情。你必须首先在心理上把自己放在跟本领域的权威平起平坐的地位，才能有效地对他们的想法做出判断和消化。我喜欢对权威显示出藐视的态度，就是这个原因，这是一种“矫枉过正”的方法。因为他们最开头在我心里还占有很重要的地位，为了把他们轰下去，我最开头是很激烈的藐视。到后来自己的认识因此迅速加深之后，才开始慢慢的理解到他们其中一些想法的启发意义。最后那种激烈的情绪逐渐消亡，他们在我心里也就变成了很普通的人。对于计算机领域的人我想强调一点，你们特别需要注意看到 Unix 系统的缺陷。很多人盲目的崇拜 Unix 的创造者，这使得他们看不到它们的设计缺陷，看不到 Unix 的设计者思想的局限性。不错，胜者为王的心理可以让你找到一份好的工作，但我在这里讲的是如何成为天才。Unix 的创造者并不是天才。

要成为天才，你必须使用直觉（或者图形），而不是符号（或者文字）进行思考。这是很显然的事情，因为人脑根本不是用符号进行思考的。符号只是不同的人脑之间进行信息交互的媒体，就像电脑之间的网线上传输的信号，它并不存在于思维活动中。有些人可能会告诉你，直觉是不可靠的。这些人并不是天才，所以不用听他们说什么。直觉可靠与否，是由你自己的造诣决定的。这些人没有得到可靠的直觉，所以他们就连直觉的价值一起给抹杀了。这里面也许有嫉妒或者故意误导的成分。真正的天才，比如 Nash 和 Feynman，都是用直觉思考的。别人的公式在进入他们头脑里时，首先被翻译成某种“思维模型”，然后他们的头脑对这种模型进行思考。他们通过直觉对这些模型进行变换操作，得出结果。然后他们用符号把这结果表示出来，为的是给其他人看。那些完全用公式进行推导的人，往往是纸上谈兵，只能做出衍生的结果，而不能做出突破性的发现。

为了得到直觉，你必须去接近自然界，必须出去寻找灵感。这就像作家需要出去“采风”，画家需要出去“写生”一样。蹲在家里看书，思考，会让你的思维局限于文字和符号所能表示的东西，没法达到突破。如果你能看到我的头脑如何思考，你就会发现，当我的眼睛看到代码或者公式的时候，我的头脑看到的并不是代码和公式，而是自动把它们翻译成了一些电路，流体导管一类的东西，它们存在于一个具有多重现实和历史的，像 Matrix 一样的世界里。这些直觉都不是从书里来的，也不是老师教的，而是通过观察身边的事物得到的。这就是为什么你听说有位古人洗了一个澡，然后发现了重大的物理学规律。Nash 在酒吧看到一个绝色美女，然后想出了他最著名的成果。

另外，你还需要休息。很多人一天学到晚，一天想到晚，以为这样就可以有所成就。可是人脑需要足够的休息和间歇的时间，才能从你想过的，看过的东西里面提取出精华的东西。Feynman 有个方法我觉得很管用。他说，如果你想成为天才，就在你的头脑里随时准备好12个需要解决的问题。每当你的生活中发生一件事，就把这些问题拿出来检查一下，看其中是否有问题会得到进展。当然，你不一定要准备12个之多，也不需要刻意的去回忆它们，否则你就会很累。这个过程应该是由“潜意识”来完成，而不需要你做出努力。如果经过了比较深入的思考还没有得到结果，你可以出去放松一下，然后说不定忽然间你的问题就被解决掉了！这是因为一旦你启动了有意识的思维，当你停下来去做其他事情的时候，你的头脑并不会停止思考，而会把这问题转交给潜意识。潜意识有一种神奇的力量，它会在接受到外界的某种微妙的激发之后，忽然间顿悟。
