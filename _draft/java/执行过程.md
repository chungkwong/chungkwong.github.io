Java虚拟机启动时加载指定类并执行`main`方法（必须是`public`、`static`、`final`）。程序在以下两种情况下结束：
- 所有非守护进程结束
- 有线程调用`Runtime`或`System`类的`exit`方法且没有被安全管理器禁止

# 类的生命周期

1. 加载类，即用类加载器（`ClassLoader`的子类）寻找（可能动态生成）指定的类或接口类型的二进制表示并构造`Class`对象，一个类加载器应当对相同名字返回相同类对象，而且若一个类加载器把加载类`C`的工作委托给另一类加载器，则它们应当对`C`的直接超类、直接超接口、域类型、方法或构造器形参类型与返回类型要返回相同类对象。若加载失败则程序在直接或间接使用类型时会抛出异常如`ClassCircularityError`、`ClassFormatError`、`NoClassDefFoundError`和`OutOfMemoryError`（前三者是`LinkageError`的子类）。
2. 链接类
    1. 验证，即保证类或接口的二进制表示是良构的，如每个操作代码合法、分支指令转到其它指令开始、每个方法签名良构和所有指令类型正确，否则在程序导致验证处抛出`VerifyError`（`LinkageError`的子类）
    2. 预备，即分配静态域（初始化为默认值）和Java虚拟机内部使用的数据结构
    3. 解析（可推迟到使用前），加载提到的域、方法、类或接口并检查引用正确（通常也替换为直接引用），否则但在程序进行可能直接或间接使用符号引用时抛出异常：`IllegalAccessError`、`InstantiationError`、`NoSuchFieldError`、`NoSuchMethodError`、`UnsatisfiedLinkError`
3. 初始化类。在首次创建类实例、调用其静态方法、给静态域赋值、使用非常变量的静态域、或执行嵌套在这顶级类其中的`assert`语句前（还有类`Class`和包`java.lang.reflect`中相应方法）需要执行它的初始化器或静态域初始化器。对于每个类或接口`C`关联一个锁`LC`，初始化`C`过程如下：
    1. 获取`LC`
    2. 若类`C`的类对象表明`C`正被其它线程初始化，则释放`LC`并等待初始化完成，再重复这步
    3. 若类`C`的类对象表明`C`正被当前线程初始化，则释放`LC`并完成这过程
    4. 若类`C`的类对象表明`C`已经被初始化，则释放`LC`并完成这过程
    5. 若类`C`的类对象表明`C`初始化失败，则释放`LC`并抛出`NoClassDefFoundError`
    6. 否则，在`C`的类对象标记`C`正在由当前线程初始化，释放`LC`，初始化`C`中作为常变量的静态域
    7. 若`C`为类，记`SC`为其超类，`SI1 , ..., SIn`为所有声明了至少一个默认方法的超接口，递归地初始化`SC , SI1 , ..., SIn`（必要时先验证和预备），若由于抛出异常而失败，则获取`LC`且标记`C`的类对象为初始化失败，通知所有等待线程释放`LC`，以同一异常为原因中止这过程
    8. 通过询问定义类加载器确定是否对`C`启用断言
    9. 按文本顺序执行类变量初始化器和静态初始化器，或接口的域初始化器
    10. 若初始化器正常完成，则获取`LC`并标记`C`的类对象为已经被初始化，通知所有等待线程释放`LC`，完成这过程
    11. 若初始化器抛出了非错误的异常，则以之为参数创建`ExceptionInInitializerError`实例以代替它，创建失败则改用`OutOfMemoryError`
    12. 获取`LC`，标记`C`的类对象初始化失败，通知所有等待线程释放`LC`，以上一步得到的错误为原因中止这过程

Java虚拟机可以卸载类，一个类或接口可以被卸载当且仅当定义它的类加载器可以被垃圾回收，启动类加载器加载的类或接口不会被卸载。

# 对象的生命周期

在以下情况会创建新的类实例：
- 求值类实例创建表达式
- 加载包含字符串字面值的类或接口可能创建`String`对象
- 执行导致装箱转换的操作可能创建基本类型装箱类型的对象
- 执行不属于常量表达式的字符串连接运算符`+`会创建新的`String`对象，也可能创建基本类型装箱类型的对象
- 求值方法引用表达式或lambda表达式可能创建新的类实例实现函数式接口

当类实例被创建时，为所有类类型及其超类声明的实例变量分配空间并初始化为默认值，没有足够空间则抛出`OutOfMemoryError`。然后，
1. 把参数赋值到构造器调用的参数变量
2. 若构造器有对相同类的显式构造器调用，则求值参数并递归地处理该构造器调用，正常完成的话则到5
3. 若这类不是`Object`，则求值参数并递归地处理对父类构造器的显式或隐式调用
4. 执行实例初始化器和把实例变量初始化器求值后的值赋给实例变量
5. 执行构造器体其它部分

在垃圾收集器回收一个对象的空间前，Java虚拟机会调用对象的`finalize`方法（在`Object`类声明的`protected`方法，但没有被非平凡地覆盖的话不会做什么事），提供一个清除无法通过自动存储管理释放的资源的机会。`finalizer`的运行时机和线程都是与不确定的，只保证在构造器成功完成后和在空间被重用前，对顺序没有规定，甚至可能并发。终结器被调用时线程不持有显式可见的同步锁，终结器抛出的未捕获异常被忽略。终结器调用前对对象域的写在终结器可见，但终结器调用前对对象域的读看不到在终结器的写。通常终结器中应当调用超类的终结器。

包`java.lang.ref`介绍的弱引用与垃圾回收有关，请参考相应API。

每个对象的可达性分为：
- 可达的对象从任何活动进程的潜在后继计算可访问的对象可达
- 终结器可达的对象从可终结对象可达，但不从任何活动进程的潜在后继计算可访问的对象可达
- 不可达对象是其余对象

每个对象按终结情况分为：
- 未终结对象的终结器没有被自动调用过
- 已终结对象的终结器被自动调用过
- 可终结对象的终结器没有被自动调用过但Java虚拟机可能最终调用终结器

编译器和代码生成器可能把不再使用（包括由于需要的域已经在寄存器的栈上引用）的变量或参数设置为`null`以使一些对象可以更早被回收。