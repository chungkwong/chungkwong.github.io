关于C的速度的迷信(基于Mark C. Chu-Carroll 2/11/2006)

一种广为流传的说法认为C和C++是要求运行速度的程序的最佳语言，但它们不是。它们擅长要求相当接近硬件的东西，但这不意味着效率，只意味着可以直接管理栈、寄存器之类。它们对于真实的科学计算代码而言是糟糕的。

事实上，C/C++的基本设计使它几乎不可能做好数值计算。这正是为什么 Fortran 仍是要求用尽机器计算能力的高强度科学计算的现实选择。

让程序运行得快是编译器的工作。现代体系架构已经使人再也无法写出高效的汇编代码 – 交换两条相互独立指令对性能有戏剧性的影响，优化的约束已经超出人能处理的范围。

于是，对于现代系统，编写高效程序是一种合作。人精心选择算法 – 机器做不到。机器精心计算指令顺序、流水线约束、取内存延迟等。这两部分不是独立的：人需要以一种编译器能理解并优化的方式表达算法。

这就是C/C++倒下的地方。C/C++强烈基于指针。几乎所有东西的语义都最终涉及没什么限制的指针。C/C++没有真正的数组，它们只是指针,(`x[n]` 相当于 `*(x+n)`.)

基于指针的本质意味着C/C++程序中编译器极难找出相互独立的东西。这涉及别名检测问题，即检查两个变量是否可能指向同一位置，在存在没什么限制的指针时别名检测是一个灾难。例如：

for (int i=0; i < 20000) { for (int j=0; j < 20000) { x[i][j] = y[i-2][j+1] * y[i+1][j-2]; } } 

这循环可以并行化或向量化当且仅当 `x` 和 `y` 指向的数组不交。但 C/C++ 代码保证不了这点。别名问题不仅与并行化有关，对实际代码影响巨大。六年前，我实现一个求最长公共子序列 (LCS)的算法，标准的动态规划算法需要O(n^3)时间和O(n^2)空间，生物人设计了一个平均只用O(n)空间的算法。

我用多种语言写了 LCS 算法。对于有2000个元素的数组:* C: 0.8 秒 * C++: 2.3 秒 OCaml: 0.6 秒（解释）, 0.3 秒（编译）* Java: 0.7秒（另JVM启动需要1秒）* Python: 超过5分钟

OCaml字节码解释器比手工精心优化的 C 程序还要快! 为什么? 因为 OCaml 编译器看出数组间独立 – 它不用担心一次迭代的值被另一个使用。C 编译器做不了很多有用的优化，因为它保证不了语义不变。

不仅不基于赋值的函数式语言的性能可击败C，较不高效的高级语言也行。 加类型声明的CMU CommonLisp 在同一算法的数值计算代码击败 C/C++。

后记

如前所述，C/C++本质上是一种难以优化的语言，只因C/C++流行，gcc和llvm之类优化编译器的开发者才为C/C++的优化投入了艰苦桌绝的努力，才让C/C++的速度保持在较快水平。

可笑的是，至今C的教材还在误导学生，慌称用指针比数组快，让他们把数组写法改成指针写法。而优化编译器却在另一方面拼命要把指针写法改成数组写法。

C是为了重写UNIX而设计的，当年流水线、乱序执行、多级缓存还未普及，C与汇编相比是一个进步，但后来的发展已经使接近硬件成为性能的阻碍。

投入到OCaml编译器的努力比投入到C/C++的努力小多了，但OCaml速度至少达到了C的水平，说明与OCaml相比C/C++是要求运行速度的程序的更佳语言。

在现在用并行来加速的发展中，C/C++更显得过时。OpenMP式的pragma会改变语义，而且常常是用户觉得莫名奇妙地，要求用户理解并发的实现方式是强人所难（Fortran的OpenMP也有同一问题，影响面小一点）。理想情况下程序应该可以不用程序员干预地利用并行的好处，自动并行化不是梦，函数式编程语言已经能，Java 8 的流API也在这方向前进。

更大的问题在于C的过程化编程思想与并行格格不入。并发编程的关键在于切割，把计算想像成算法的隐喻已经不再恰当。锁机制的问题已经臭名昭著，更异步的思考方式才是出路。

正是这样，过去被认为低效的消息传递方式在并发场境反倒胜于共享内存，进程击败了线程。map-reduce框架（支撑搜索引擎等超大规模数据处理）、actor模型（如广泛用于电信等分布式系统的Erlang语言，还有新兴的Scala）、STM模型（见于Clojure和Haskell）就是例证。