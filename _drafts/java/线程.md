# 监视器

每个Java对象都与一个监视器和等待线程集关联，线程可以锁定或解锁它。同一时间只有一个线程可能持有对一个监视器的锁。企图获得锁的线程会阻塞至获取该监视器的锁。一个线程可重复锁定一个监视器，每次解锁逆转一次锁定操作的作用。初始时等待集为空。

Java语言不防止或检测死锁，程序员应遵从避免死锁的编程习惯，尽可能使用不会死锁的高层原语。

线程`t`对对象`m`调用`wait()`或`wait(long millisecs)`或`wait(long millisecs, int nanosecs)`在没有抛出`InterruptedException`时正常返回。记线程`t`对对象`m`未解锁的锁定次数为`n`：
- 若`n`为0，则抛出`IllegalMonitorStateException`
- 若`nanosecs`实参不是0到999999的范围或`millisecs`为负，则抛出`IllegalArgumentException`
- 若`t`被中断，则抛出`InterruptedException`并清除中断状态
- 否则：
    1. 把`t`加到`m`的等待集并对`m`解锁`n`次
    2. 在`t`从`m`的等待集移除前不会执行后续指令，这会在以下情况发生，而且这些事件看似以某种顺序发生：
        - 对`m`调用`notify`且`t`被选中
        - 对`m`调用`notifyAll`
        - 中断`t`
        - 开始`wait`后至少经过了`millisecs`毫秒和`nanosecs`纳秒
        - 实现在没有事干时可能会这样做（`wait`应当在循环中的又一原因）
    3. `t`对`m`加锁`n`次
    4. 若2因中断完成，则清除中断状态并抛出`InterruptedException`

线程`t`对对象`m`调用`notify`或`notifyAll`，记记线程`t`对对象`m`未解锁的锁定次数为`n`：
- 若`n`为0，则抛出`IllegalMonitorStateException`
- 若`n`为正且为`notify`，则在`m`等待集非空时选取其中一个线程`u`并移除之，导致`t`完全解锁`m`的监视器后`u`从`wait`继续
- 若`n`为正且为`notifyAll`，从`m`的等待集移除所有线程让它们继续，但只有一个获取到监视器。

线程`t`对线程`u`调用`Thread.interrupt`会设置`u`的中断状态。若有对象`m`的等待集包含`u`，则`u`从`m`的等待集移除，在重新锁定`m`的监视器后抛出`InterruptedException`

调用`Thread.isInterrupted`可得知中断状态，静态方法`Thread.interrupted`可检查并清除当前线程的中断状态。

`Thread.sleep`方法使当前执行的线程在一段时间（与调度器和处理器供应有关）内不执行，但不会失去监视器的拥有权。

`Thread.sleep`和`Thread.yield`没有同步语义，调用前不用清洗写缓存，调用后也不用重新加载已缓存的值。

# 内存模型

可以由多个线程共享的内存称为共享内存。所有实例变量、静态变量和数组元素都保存在共享内存，以下用变量指代它们。局部变量、方法参数、异常参数则不会在线程间共享。称两个访问冲突当且仅当其中一个是写。

线程间动作可以被其它线程检测或影响：
- 读（非`volatile`)变量
- 写（非`volatile`)变量
- 同步：
    - 读`volatile`变量
    - 写`volatile`变量
    - 锁定监视器
    - 解锁监视器
    - 线程的首个和最后一个动作
    - 启动线程和检测线程终止
- 外部动作，在执行外可观察（若终止）且有基于执行外环境的结果
- 线程发散动作，即不进行内存、同步、外部动作的无穷循环。若有线程发散动作，则接着是无穷个线程发散动作。

动作`a`由元组`< t, k, v, u >`表示，其中
- `t`为进行动作的线程
- `k`为动作的类型
- `v`为涉及的变量或监视器
- `u`为动作的惟一标识
- 外部动作还有结果

一个执行`E=< P, A, po, so, W, V, sw, hb >`由以下组成：
- `P`为程序
- `A`为动作集
- `po`为程序顺序，是各线程中`A`所有动作的全序，每个线程内与线程内语义一致
- `so`为同步顺序，是`A`所有同步动作的全序，每个线程中的同步顺序与线程的程序顺序一致
- `W`为把读映射所见写的函数
- `V`为把写映射到它写的值的函数
- `sw`为同步关系，是同步动作的偏序关系，每条同步边的源和目标分别叫释放和获取
    - 对监视器`m`的解锁动作与所有同步顺序中后面对`m`的加锁动作同步
    - 对`volatile`变量`v`的写与所有同步顺序中后面所有线程对`v`的读动作同步
    - 启动线程的动作与被启动线程的首个动作同步
    - 对每个变量写默认值与每个线程的首个动作同步
    - 线程`T1`的最后一个动作与另一线程`T2`检测`T1`是否已终止的动作同步
    - 若`T1`中断`T2`，则`T1`的中断与所有其它线程（包括`T2`）中检测`T2`中断状态的点同步
- `hb`为先于发生关系，是动作的偏序关系。若一个动作先于另一个发生，则前者对后者可见且排在前面。若两个动作有先于发生关系，它们在没有先于发生关系的代码看来不必按这顺序执行。一个同步边集`S`称为充分的，若它是最小集合使`S`的传递闭包与程序顺序决定所有先于发生边。
    - 若`x`、`y`为相同线程的动作，`x`按程序顺序先于`y`，则`hb(x, y)`
    - 一个对象构造器结束先于其终结器开始
    - 若动作`x`与动作`y`同步，则`hb(x, y)`
    - 若`hb(x, y)`且`hb(y, z)`，则`hb(x, z)`

若一个程序中，若有两个冲突的访问没有先于发生关系，则称程序有数据竞争。所有序列一致执行都没有数据竞争的程序称为正确同步的，这时所有执行是序列一致的。序列一致是指所有出现在执行顺序的动作与程序顺序一致，并且每个对变量`v`的读看到较早时（执行顺序）对变量`v`的写`w`，其中按执行顺序没有对`v`的写`w'`介于`w`与`r`间。

上述执行良构的条件是：
1. 每个读看到执行中一个相同变量的写，即对`A`中读`r`，`A`中的`W(r)`使`W(r).v = r.v`。对`volatile`变量的读写为`volatile`动作，`r.v`为`volatile`当且仅当`r`为`volatile`读，`w.v`为`volatile`当且仅当`w`为`volatile`写。
2. 先于发生是偏序，由同步边与程序顺序的传递闭包给出
3. 线程间一致，即对每个线程`t`，`t`在`A`进行的动作与该线程单独按程序顺序同。若`w`写`V(w)`，则`r`看到`V(W(r))`。
4. 先于发生一致，即对`A`中每个读`r`，不要`hb(r, W(r))`，也不要存在写`A`中写`w`使`w.v = r.v, hb(W(r), w), hb(w, r)`
5. 同步顺序一致，对`A`中`volatile`读`r`，不能`so(r, W(r))`，也不能存在写`A`中写`w`使`w.v = r.v`且`so(W(r), w)`和`so(w, r)`

程序的可观察行为是程序可能进行外部动作的有限集。

还有一个特殊的挂起动作。若行为由包含挂起动作的外部动作集描述，则在观察到外部动作后，程序可能执行无界时间而不进行其它外部动作或终止。程序可以在所有线程阻塞或进行无界个动作但不进行外部动作。

线程可能由于获取锁或进行外部动作而阻塞。执行可能导致一个线程无限阻塞而不终止，这时阻塞线程生成的动作包括直到阻塞时生成的动作（包括导致阻塞的动作），但不包括后面的动作。

若`O`为执行`E`的可观察动作集合，则`O`必须为`E`动作集`A`的有限子集，且若动作`y`在`O`中，且`hb(x, y)`或`so(x, y)`，则`x`在`O`中。

`B`是程序`P`的容许行为当且仅当`B`为外部行为的有限集且以下之一：
- 存在`P`的执行`E`使`B`，`O`为`E`的可观察动作集，则`B`为`O`中外部动作集（若`E`中有线程在阻塞状态结束且`O`包含`E`的所有动作，则`B`可包含挂起动作）
- 存在动作集`O`使`B`包含挂起动作和`O`中所有外部动作，对于所有`k ≥ | O |`存在`P`的执行`E`使动作集为`A`，存在动作集`O'`使：
    - `O`和`O'`均为`A`的可观察动作子集
    - `O ⊆ O' ⊆ A`
    - `| O' | ≥ k`
    - `O' - O` 没有外部动作

# final域

令`o`为对象，`c`为写`final`域`f`的构造器（而不一定是类创建表达式调用的），则在`c`结束（正常或中止）时冻结`f`。在执行中，读的行为与以下两个偏序（可能不惟一）有关：
- 解引用链`dereferences()`，它满足：
    - 若动作`a`为不初始化对象`o`的线程`t`中对`o`的域或元素的读或写，则存在`t`中读`r`看到`o`的地址使`dereferences(r, a)`
- 内存链`mc()`，它满足：
    - 若读`r`看到写`w`则`mc(w, r)`
    - 若`r`、`a`为动作使`dereferences(r, a)`，则`mc(r, a)`
    - 若`w`为不初始化`o`的线程`t`中写对象`o`的地址，则存在`t`中读`r`看到`o`的地址且`mc(r, w)`

给定写`w`、冻结`f`、动作`a`（不是对`final`域的读）、对`f`冻结的`final`域的读`r1`、读`r2`使`hb(w, f), hb(f, a), mc(a, r1 ), dereferences( r1 , r2 )`，则在决定`r2`的值时考虑`hb(w, r2 )`。

在创建对象的线程中读对象的`final`域关于域初始化的顺序按通常的先于发生规则。若在域于构造器设置后读，则看到域被赋的值，否则看到默认值。

在反序列化等情况，系统会在构造对象后改变`final`域；也可能通过反射或其它实现特定的方式被改变。在构造器刚结束或刚修改后冻结`final`域。然而，若`final`域在声明中以常量表达式初始化，则改变域可能不可见（因为域的使用已经在编译期替换为常量表达式的值）。线程内构造器外对`final`域的读还可能被重排。程序员应避免在修改好对象的所有`final`域前把对象泄露给其它线程或读`final`域。

正常情况下`final static`域不能修改，但由于兼容性`System.in`、`System.out`和`System.err`可通过`System.setIn`、`System.setOut`、`System.setErr`修改，这种域叫写保护域。

Java虚拟机保证更新一个域或元素时不影响其它域或元素的读写，在一些处理器保证字节数组相邻元素互不影响不是平凡的。

对非`volatile`的`long`或`double`值的单个写视为两个分开的32位写，这可能导致线程看到一个64位值的前32位来自一个写而后32位来自另一次写。`volatile`的`long`或`double`值的读写则总是原子的。