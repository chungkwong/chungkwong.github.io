类型系统是一门编程语言的精粹。问一个值的类型就是问该值是什么的问题。

Java是一种强类型的静态语言，并且是类型安全的：
- 强类型是说每个值有惟一的类型（相反类shell语言会由上下文确定如何解读它）
- 静态类型是说每个值在编译期都有一个类型
- 类型安全是指运行期值的类型必须与编译期类型一致：你不能告诉编译器它是羊但实际上它是狗并在运行时用狗的咬人功能

众所周知，越早发现错误越好。Java类型系统意味着可以在编译时检测许多错误，而运行期再检查编译时难以检测的错误。两层防御在消除了许多常见疏忽的同时，保持了适当的灵活性，不会为正确的代码带来太多负担，这是Java稳健性的一个表现。

# 类型

## 类型的分类

```
Type:
	PrimitiveType
	ReferenceType
PrimitiveType:
	{Annotation} NumericType
	{Annotation} boolean
NumericType:
	IntegralType
	FloatingPointType
IntegralType:
	(one of)
	byte short int long char
FloatingPointType:
	(one of)
	float double
ReferenceType:
	ClassOrInterfaceType
	TypeVariable
	ArrayType
ClassOrInterfaceType:
	ClassType
	InterfaceType
ClassType:
	{Annotation} Identifier [TypeArguments]
	ClassOrInterfaceType . {Annotation} Identifier [TypeArguments]
InterfaceType:
	ClassType
TypeVariable:
	{Annotation} Identifier
ArrayType:
	PrimitiveType Dims
	ClassOrInterfaceType Dims
	TypeVariable Dims
Dims:
	{Annotation} [ ] {{Annotation} [ ] }
TypeParameter:
	{TypeParameterModifier} Identifier [TypeBound]
TypeParameterModifier:
	Annotation
TypeBound:
	extends TypeVariable
	extends ClassOrInterfaceType {AdditionalBound}
AdditionalBound:
	& InterfaceType
TypeArguments:
	< TypeArgumentList >
TypeArgumentList:
	TypeArgument { , TypeArgument}
TypeArgument:
	ReferenceType
	Wildcard
Wildcard:
	{Annotation} ? [WildcardBounds]
WildcardBounds:
	extends ReferenceType
	super ReferenceType
```

Java的类型分为：
- 基本类型
    - 数值类型
        - 整数类型
    	    - `byte`的值是用8位二的补码表示的有符号整数（从-128到127）
	    - `char`的值是用16位表示的无符号整数（从0到65535），通常对应UTF-16代码单元
	    - `short`的值是用16位二的补码表示的有符号整数（从-32768到32767）
	    - `int`的值是用32位二的补码表示的有符号整数（从-2147483648到2147483647）
	    - `long`的值是用64位二的补码表示的有符号整数（从-9223372036854775808到9223372036854775807）
	- 浮点数类型
            - `float`的值为32位IEEE 754浮点数，但一些`float`类型的表达式的值可能来自扩展`float`值集（精度相同，但有更大的指数范围）
	    - `double`的值为64位IEEE 754浮点数，但一些`float`类型的表达式的值可能来自扩展`float`值集（精度相同，但有更大的指数范围）
    - 布尔类型
        - `boolean`恰有两个值分别表示真和假
- 引用类型，两个引用类型在编译期相同当且仅当它们的二进制名相同且类型参数相同。
    - 类类型。若两个类由相同类加载器加载且有相同的二进制名字，则它们相同。
    - 接口类型。若两个接口由相同类加载器加载且有相同的二进制名字，则它们相同。
    - 数组类型。若两个数组类型的分量类型在运行期相同，则它们相同。
    - 空类型，没有名字，只有一个空值

每个基本类型都对应一个属于类类型的装箱类型`Byte`、`Short`、`Integer`、`Integer`、`Long`、`Float`、`Double`、`Boolean`，这些类型提供也一些有用的静态方法。

类实例和数组统称对象，每个对象关联一个用于同步的监视器。

### 类类型

#### Object类

`Object`类是所有类的超类，它是成员包括：
- `clone`方法用于复制对象
- `equals`方法定义基于值而非引用的相等性
- `finalize`方法在对象被销毁前被调用
- `getClass`返回表示类的`Class`对象
- `hashCode`方法与`equals`一起对哈希表有用
- `wait`、`notify`、`notifyAll`用于并发编程
- `toString`方法返回对象的字符串表示

## Class类型

每个引用类型都有一个`Class`对象，可用于发现类的完全限定名、成员、直接超类、实现的接口。其中：
- `getClass`返回类型为`Class<? extends | T | >`，其中`T`为搜索的类或接口

### 数组类型

数组是包含非负个变量（称为分量）的对象，这些变量通过从0开始的整数索引引用。一个数组的所有分量有相同的类型`T`，称为分量类型，把数组类型记为`T[]`（方括号前可以加注解）。分量类型为`float`或`double`的分量的值来自`float`或`double`值集（而不是扩展值集）。数组的分量类型可以仍是数组类型。

数组可通过求值数组初始化表达式

若变量类型为`A[]`而`B`可赋值给`A`，则变量可保存`B[]`的实例。但后续对分量的赋值可能由于类型不是`B`的子类型而抛出`ArrayStoreException`。

虽然数组类型不是类类型，但也关联一个`Class`对象，好像以`Object`为直接父类，实现了`Cloneable`和`java.io.Serializable`。数组类型的成员包括：
- `public`的实例变量`length`表示其分量个数，即长度，注意长度不是类型的一部分。
- `public`方法`clone`（覆盖`Object`的）不抛出检查弄异常返回类型为`T[]`，它返回数组的浅复制（特别地对于数组的数组，分量数组将共享）

数组初始化器形如：

```
ArrayInitializer:
	{ [VariableInitializerList] [ , ] }
VariableInitializerList:
	VariableInitializer { , VariableInitializer}
```

其中每个变量初始化器都要赋值兼容于数组的分量类型，分量类型必须是完整的，构造数组的长度与直接包含的变量初始化器个数相同，构造方法为：
1. 分配空间，不够则抛出`OutOfMemoryError`
2. 把所有分量初始化为默认值
3. 从左到右求值直接包含的变量初始化器并把值赋给对应分量，特别地若分量类型为数组类型，则指定分量的初始化器也可以是数组初始化器，即数组初始化器可嵌套

## 参数化类型

设`F1 ,..., Fn`为分别为`C`的有界`B1 ,..., Bn`的类型参数，参数化类型`C<T1 ,..., Tn >`必须是良构的：
- `C`为泛型类型的名字
- 类型参数个数与`C`泛型声明中类型参数个数相同
- 当捕获转换的结果为`C<X1 ,..., Xn >`，则每个`Bi`中每个界类型`S`，`Xi`为`S[F1 :=X1 ,...,Fn :=Xn ]`的子类型

设`C`为有类型参数`A1 ,..., An`的泛型类或接口声明，`C<T1 ,..., Tn >`为`C`的参数化：
- 若所有`Ti`而非通配符，则：
    - 若`m`为`C`中声明的成员或构造器，声明的类型为`T`，则`C<T 1 ,..., T n >`中`m`的类型为`T[A1 :=T1 ,...,An :=Tn ]`
    - 若`m`为`D`中声明的成员和构造器，`D`为`C`继承的类或实现的接口，`D<U 1 ,..., U k >`为`C<T 1 ,..., T n >`的超类，则`C<T1 ,..., Tn >`中`m`类型为`D<U 1 ,..., U k >`中`m`的类型
- 若有类型参数为通配符，则：
    - `C<T 1 ,..., T n >`中域、方法、构造器的类型为`C<T1 ,..., Tn >`捕获转换中域、方法、构造器的类型
    - 令`D`为`C`中声明的类或接口（可能泛型），则`D`在`C<T1 ,..., Tn >`中类型为`D`，且在`D`为泛型时所有类型参数为无界通配符

`T1`包含类型参数`T2`（记为`T 2 <= T 1`）的自反传递关系由以下规则决定：
- `? extends T <= ? extends S if T <: S`
- `? extends T <= ?`
- `? super T <= ? super S if S <: T`
- `? super T <= ?`
- `? super T <= ? extends Object`
- `T <= T`
- `T <= ? extends T`
- `T <= ? super T`

两个参数化类型可证明不同当且仅当以下之一：
- 它是不同泛型声明的参数化
- 它有可证明不同的类型参数，即以下之一：
    - 类型参数都不是类型变量或通配符，且两个参数类型是不同类型
    - 一个类型参数是类型变量或通配符，上界（必要时用捕获转换）为`T`而另一类型参数为`S`但`| S | <: | T |`与`| T | <: | S |`都不成立
    - 一个类型参数是类型变量或通配符，上界（必要时用捕获转换）分别为`T`、`S`但`| S | <: | T |`与`| T | <: | S |`都不成立


记类型`T`的类型擦除为`| T |`，则：
- `|G<T1 ,..., Tn >|`为`| G |`
- `|T.C|`为`| T |. C`
- `|T[]|`为`| T | []`
- `|T & I1 & ... & Ik|`为`| T |`
- 其它类型的擦除为自身

构造器或方法的签名的擦除是一个同名但所有形参类型和返回类型被擦除的签名，类型参数也擦除成没有类型参数。

因为部分类型信息在编译时擦除，只有满足以下之一的完整类型在运行时可用：
- 对应非泛型类或接口类型声明
- 所有类型参数为无界通配符的参数化类型
- 原始类型，即擦除后的类型，只应用于遗留代码，条件为以下之一：
    - 由泛型类型声明的名字构成的引用类型但没有类型参数
    - 分量类型为原始类型的数组类型
    - 原始类型`R`的不派生自`R`的超类或超接口的成员类型
- 基本类型
- 分量类型为完整类型的数组类型
- 所有组成部分为完整类型的嵌套类型

## 类型变量

- 类型变量的界的所有组成类型的擦除必须两两不同
- 类型变量不能同时为同一泛型接口的不同参数化的子类型

类型变量的擦除与界的首个类型有关，此外各界的出现顺序不重要。

对界为`T & I1 & ... & In`的类型变量`X`的成员为相同位置处交类型`T & I1 & ... & In`的成员。

## 交类型

每个交类型`T1 & ... & Tn`对应一个标记类或接口以便确定其成员：
- 对每个`Ti`，记`Ci`为使`T i <: C i`的最具体类或接口类型，取`Ck`使用`Ck <: Ci`总成立，不存在是编译期错误
- 对每个`Tj`，若它为类型变量，则令`Tj'`为成员与`Tj`的`public`成员同；若`Tj`为接口，则令`Tj'`同`Tj` .
- 若`Ck`为`Object`，引入标记接口；否则引入直接超类为`Ck`的标记类。它们的直接超接口为`T1', ..., Tn'`且声明于交类型出现的包。

## 类型的关系

### 子类型

我们把直接超类关系记为`> 1`，这关系由以下规则定义：
- `double > 1 float`
- `float > 1 long`
- `long > 1 int`
- `int > 1 char`
- `int > 1 short`
- `short > 1 byte`
- 给定非泛型类型声明`C`，`C`的直接超类型包括：
    - `C`的直接超类
    - `C`的直接超接口
    - `Object`，若`C`为没有直接超接口的接口
- 给定非泛型类型声明`C`，`C`的直接超类型包括：
    - `C`的直接超类
    - `C`的直接超接口
    - `Object`，若`C`为没有直接超接口的接口
- 给定泛型类型声明`C<F1 ,..., Fn >`，原始类型`C`的直接超类型包括：
    - `C`的直接超类
    - `C`的直接超接口
    - `Object`，若`C`为没有直接超接口的接口
- 给定泛型类型声明`C<F1 ,..., Fn >`，`C<F1 ,..., Fn >`的直接超类型包括：
    - `C<F1 ,..., Fn >`的直接超类
    - `C<F1 ,..., Fn >`的直接超接口
    - `Object`，若`C<F1 ,..., Fn >`为没有直接超接口的接口
    - `C`
- 给定泛型类型声明`C<F1 ,..., Fn >`，参数化类型`C<T1 ,..., Tn >`（各`Ti`均为类型）的直接超类型包括：
    - `D<U1 θ,..., Uk θ >`其中`D<U1 ,..., Uk >`为`C<T1 ,..., Tn >`的直接超类型，而`θ`为代换`[F1 :=T1 ,...,Fn :=Tn ]`
    - `C<S1 ,..., Sn >`，其中`Si`包含`Ti`
    - `Object`，若`C<F1 ,..., Fn >`为没有直接超接口的接口
    - `C`
- 给定泛型类型声明`C<F1 ,..., Fn >`，参数化类型`C<R1 ,..., Rn >`（至少一个`Ti`为通配符类型参数）的直接超类型为应用捕获转换的结果`C<X1 ,..., Xn >`
- `T1 & ... & Tn`的直接超类型为各`Ti`
- 类型变量的直接超类型为列在它的界的类型
- 类型变量是其下界的直接超类型
- 空类型的直接超类型为所有非空类型的引用类型
- 若`S`和`T`为引用类型但且`S > 1 T`，则`S[] > 1 T[]`
- `Object > 1 Object[]`
- `Cloneable > 1 Object[]`
- `java.io.Serializable > 1 Object[]`
- 若`P`为基本类型，则
    - `Object > 1 P[]`
    - `Cloneable > 1 P[]`
    - `java.io.Serializable > 1 P[]`

超类型关系为直接超类型关系的自反传递闭包，记为`:>`。若`S :> T , S ≠ T`，则称`S`为`T`的真超类，记`S > T`。

若`S > 1 T`，则称`T`为`S`的直接子类型，记为`T < 1 S`。若`S :> T`则称`T`为`S`的子类型，记为`T <: S`。若`S <: T , S ≠ T`，则称`S`为`T`的真子类，记`S < T`。

## 最小上界

一组引用类型的近似最小上界`lub( U 1 , ..., U k )`（可能是无穷类型但Java编译器能处理）如下决定：
- 若`k = 1`，则`lub( U ) = U`
- 否则，对每个`Ui`，记`ST( Ui )`为`Ui`的超类型集，`EST( Ui )`为`Ui`的超类型的擦除集
    - 记`EC`为各`EST( Ui )`之交
    - 记`MEC`为`{ V ∈ EC | 对所有EC中的 W ≠ V不成立 W <: V }`
    - 对于`MEC`中每个元素`G`，令`Relevant( G )`为`{ V | 1 ≤ i ≤ k: V in ST( Ui ) and V = G< ... > }`
    - 最小包含类型参数`lcta`定义如下：
        - 若`U = V`则`lcta( U , V ) = U`，否则`? extends lub( U , V )`
        - `lcta( U , ? extends V ) = ? extends lub( U , V )`
        - `lcta( U , ? super V ) = ? super glb( U , V )`
        - `lcta( ? extends U , ? extends V ) = ? extends lub( U , V )`
        - 若`U = V`则`lcta( ? extends U , ? super V ) = U`，否则`?`
        - `lcta( ? super U , ? super V ) = ? super glb( U , V )`
        - 若`U`上界为`Object`则`lcta( U ) = ?`，否则`? extends lub( U , Object )`
    - 最小包含参数化`lcp`定义如下：
        - `lcp( S ) = lcp( e 1 , ..., e n )`，其中`ei`为`S`的元素
        - `lcp( e 1 , ..., e n ) = lcp(lcp( e 1 , e 2 ), e 3 , ..., e n )`
        - `lcp( G<X 1 , ..., X n > , G<Y 1 , ..., Y n > ) = G< lcta( X 1 , Y 1 ), ..., lcta( X n , Y n ) >`
        - `lcp( G<X 1 , ..., X n > ) = G< lcta( X 1 ), ..., lcta( X n ) >`
    - 令`Candidate( G )`为`lcp(Relevant( G ))`
    - 令`Best(X)`为
        - 若`X`为泛型则`Candidate( X )`
	- 否则`X`
    - 令`lub( U1 ... Uk )`为`Best( W1 ) & ... & Best( Wr )`，其中`Wi`为MEC中元素

# 变量类型

变量是存储位置，每个变量都有一个编译期类型。变量的值可以通过赋值或自增减运算符改变。在没有编译期未检查警告的情况下，变量值的类型与变量的类型兼容：
- 对于基本类型的变量，变量保存刚好是该基本类型的基本值
- 对于类类型的变量，变量保存空引用或到该类的子类的实例的引用，特别地`Object`变量保存空引用或到任何对象（含数组）的引用
- 对于接口类型的变量，变量保存空引用或到实现了该接口的类的实例的引用
- 对于分量类型为基本类型的数组类型`T[]`变量，变量保存空引用或到`T[]`数组的引用
- 对于分量类型为引用类型的数组类型`T[]`变量，变量保存空引用或到`S[]`数组的引用，其中`S`为`T`的子类或子接口。特别地`Object[]`变量保存空引用或到任何分量类型为引用类型的数组的引用

多个变量可引用同一对象，从而通过一个变量改变对象状态后对其它变量可见。

在涉及原始类型的操作是可能发生堆污染，使参数化类型的变量指向不是该类型的对象：

```java
List l = new ArrayList<Number>();
List<String> ls = l; // Unchecked warning
```

在为非完整数组类型变量给予原始或非泛型数组变量别名时，也可能发生堆污染：

```java
static void m(List<String>... stringLists) {
       Object[] array = stringLists;
       List<Integer> tmpList = Arrays.asList(42);
       array[0] = tmpList; // (1)
       String s = stringLists[0].get(0); // (2)
}
```

变量可分为：
- 类变量是类声明中用了`static`关键字的域或接口中的域，它们在类或接口预备时初始化为默认值，存在到类或接口被卸载
- 实例变量是类声明中不用`static`关键字的域，它们在创建类或其子类对象时初始化为默认值，存在到类终结
- 数组分量在数组创建时创建并有默认值，存在至数组不再被引用
- 方法参数在每次方法被调用时创建并初始化为方法调用提供的对应实参，存在到方法体执行完成
- 构造器参数在每次方法被调用时创建并初始化为类实例创建表达式或显式构造器调用提供的对应实参，存在到构造器体执行完成
- lambda参数在每次lambda实现的方法被调用时创建并初始化为方法调用提供的对应实参，存在到lambda体执行完成
- 异常参数在每次有异常被`catch`子句捕获时创建并初始化为异常对象，存在到`catch`块执行完成
- 局部变量在控制进入局部变量声明直接所在块或`for`语句时创建，其初始化器在执行局部变量声明时才执行，存在到块或`for`词句完成

`final`变量只能赋值一次，只有在变量肯定未被赋值过（通过静态分析）时才能被赋值，从而赋值后总有相同值（由于，当然指向对象的状态仍可能变化，指向数组的分量可能变化）。
空白`final`是指没有初始化器的`final`变量
常变量是指类型为基本类型或`String`的`final`且由常量表达式初始化的变量。

以下变量隐式地声明为`final`：
- 数组的域
- 带资源`try`语句的资源变量
- 多捕获的异常参数

以下变量是事实上`final`的：
- 满足下述所有条件的带初始化器局部变量：
    - 没有声明为`final`
    - 不出现在赋值表达式的左方
    - 不作为自增减操作符操作数
- 满足下述所有条件的不带初始化器局部变量：
    - 没有声明为`final`
    - 出现在赋值表达式的左方时在肯定未赋值且在右方表达式后不是肯定已赋值
    - 不作为自增减操作符操作数
- 方法、构造器、lambda和异常参数参照有初始化器的局部变量

可见事实上`final`变量可以疑为`final`而不引致编译期错误，而`final`变量删去`final`后成为事实上`final`。

每个变量在使用前必须有值：
- 对于类变量、实例变量、数组分量，它们被创建时有默认值：
    - 类型`byte`默认值为`(byte)0`的值
    - 类型`short`默认值为`(short)0`的值
    - 类型`int`默认值为`0`
    - 类型`long`默认值为`0L`
    - 类型`float`默认值为`0.0f`
    - 类型`double`默认值为`0.0d`
    - 类型`char`默认值为`'\u0000'`
    - 类型`boolean`默认值为`false`
    - 引用类型默认值都是`null`
- 方法参数初始化为调用者提供的实参
- 构造器参数初始化为类实例创建表达式或显式构造器调用提供的实参
- 异常参数初始化为抛出的对象
- 局部变量必须显式地通过初始化或赋值给予一个值，且可通过静态分析保证这点

- 在运行时，不同类加载器加载的相同的类或接口定义可能得到不同的运行时类型。
- 由于类型变量和类型参数在运行期失传，编译期不同的参数化类型可能对应相同的运行期类型

# 类型转换

类型转换改变编译期类型，但在运行期会检查安全性。

## 转换

### 恒同转换

把一个类型转换为同一类型。

### 扩宽的基本转换

- 从`byte`到`short`、`int`、`long`、`float`或`double`
- 从`short`到`int`、`long`、`float`或`double`
- 从`char`到`int`、`long`、`float`或`double`
- 从`int`到`long`、`float`、`double`
- 从`long`到`float`或`double`
- 从`float`到`double`

扩宽的基本转换在以下情况下数值不丢失信息完全保留：
- 从一个整型到另一个整型
- 从`byte`、`short`或`char`到浮点类型
- 从`int`到`double`
- `strictfp`表达式中从`float`到`double`

相反，扩宽的基本转换从`int`到`float`或从`long`到`float`或从`long`到`double`可能会导致精度损失，即结果可能会损失值的一些最低有效位。在这种情况下，所得到的浮点值将是正确舍入的整数值，使用 IEEE 754 四舍五入到最近模式。

一个有符号的整数的值转换为整型T扩宽转换只是符号扩展二的补码。一个`char`到整型`T`的扩宽转换零扩展二的补码表示。

### 收窄的基本转换

- `short`到`byte`或`char`
- `char`到`byte`或`short`
- `int`到`byte`、`short`或`char`
- `long`到`byte`、`short`、 `char`或`int`
- `float`到`byte`、`short`、 `char`、`int`或`long`
- `double`到`byte`、`short`、 `char`、`int`、`long`或`float`

收窄基本转换可能会丢失有关数字的值的总体规模，也可失去精度和范围信息。

从double收窄基本转换为float受 IEEE 754 按舍入规则。这种转换可以失去精度，但也失去范围，导致从一个非零double到float零和从一个有限double到float无限。double的NaN换为float的NaN，double的无限转换到同号float无限。

一个有符号整数转换为整型`T`收缩转换只是放弃除n个最低位外所有位，其中n是类型`T`的位数。除了大小信息可能丢失，这可能会导致生成值的符号不同于输入值的符号。

一个`char`转换为整型`T`收缩转换同样简单地丢弃n个最低位外所有位，其中n是类型`T`的位数。除了大小信息可能丢失，这可能会导致所得到的值是负数，即使字符表示 16 位无符号的整数值。

一个浮点数转换为整型`T`的收缩转换需要两个步骤︰
1. 浮点数被转化为一个`long`（如果`T`是`long`），或为`int`（如果`T`是`byte`、`short`、`char`或`int`）如下︰
    - 如果浮点数是NaN，转换的第一步的结果是`int`或`long` 0
    - 否则，如果浮点数不是无穷大，浮点值使用 IEEE 754 向零舍入四舍五入为整数值`V`︰
        - 如果`T`是`long`，而此整数值可以表示为一个`long`，则第一步的结果是`V`的`long`值
        - 否则，如果此整数值可以表示为一个`int`，然后第一步的结果是`int`值`V`
    - 否则，以下两种情况之一︰
        - 值必须是太小 （负值大或负无穷大） ，第一步的结果是最小的类型`int`或`long`可表示值
        - 值必须是太大 （正值大或正无穷大），第一步的结果是最大的类型`int`或`long`可表示值
2.
    - 如果`T`是`int`或`long`，转换的结果是第一步的结果
    - 如果`T`是结果的`byte`、`char`或`short`，转换的结果是第一步结果收缩转换到类型`T`的结果。

尽管事实上上溢、下溢或其他信息损失可能会发生，收窄基本转换不会导致运行期异常。

### 扩宽和收缩的基本转换

从`byte`到`char`的转换过程：
1. 通过扩宽基本转换转换为`int`
2. 通过收窄基本转换转换为`char`

### 扩宽引用转换

存在从任何引用类型`S`到任何引用类型`T`，其中`S`是`T`的子类型 。拓宽引用转换不需要在运行期的特别工作，因此从不引发运行期异常。

### 收窄引用转换

- 从任何引用类型`S`到任何引用类型`T`，前提是`S`是`T`的真超类型。特别地，从类`Object`可收缩到任何其他引用类型
- 从任何类类型`C`到任何非参数化的接口类型`K`，假设`C`不是`final`的也未实现`K`
- 从任何接口类型`J`到任何的不是`final`的非参数化类类型`C`
- 从任何接口类型`J`到任何非参数化的接口类型`K`，前提是`J`不是`K`子接口
- 从接口类型`Cloneable`和`java.io.Serializable`到任何数组类型`T[]`
- 从任何数组类型`SC[]`到任何数组类型`TC[]`，只要`SC`和`TC`是引用类型，并存在从`SC`到`TC`的收窄引用转换

这种转换需要在运行期检查实际的引用对象是否是新类型的一个合法值。如否，则会抛出`ClassCastException`

### 装箱转换

- 从类型`boolean`到类型`Boolean`，如果`p`是类型`boolean`的一个值，则装箱转换把`p`转换为类`Boolean`的引用`r`使`r.booleanValue() == p`
- 从类型`byte`到类型`Byte`，如果`p`是类型`byte`的一个值，则装箱转换把`p`转换为类`Byte`的引用`r`使`r.byteValue() == p`
- 从类型`short`到类型`Short`，如果`p`是类型`char`的一个值，则装箱转换把`p`转换为类`Character`的引用`r`使`r.charValue() == p`
- 从类型`char`到类型`Character`，如果`p`是类型`short`的一个值，则装箱转换把`p`转换为类`Short`的引用`r`使`r.shortValue() == p`
- 从`int`类型到类型`Integer`，如果`p`是类型`int`的一个值，则装箱转换把`p`转换为类`Integer`的引用`r`使`r.intValue() == p`
- 从类型`long`到类型`Long`，如果`p`是类型`long`的一个值，则装箱转换把`p`转换为类`Long`的引用`r`使`r.longValue() == p`
- 从类型`float`到类型`Float`，如果`p`是类型`float`的值︰
    - 如果`p`不是NaN，则装箱转换把`p`转换为类`Float`的引用`r`使`p==r.floatValue()`
    - 否则，装箱转换把p转换为类`Float`的引用`r`使`r.isNaN()`计算结果为`true`
- 从类型`double`到类型`Double`，如果p是类型double的值︰
    - 如果`p`不是NaN，则装箱转换把`p`转换为类`Double`的引用`r`使`p==r.doubleValue()`
    - 否则，装箱转换把`p`转换为类`Double`的引用`r`使`r.isNaN()`计算结果为`true`
- 从null类型到null类型，相当于恒同转换

如果被装箱的值`p`是一个`int`类型从 -128到127之间的整数字面值，或布尔字面值`true`或`false`(§3.10.3)，或从`'\u0000'`到`'\u007f'`的字符字面值，则让`p`的任何两个装箱转换的结果`a`和`b`成立 `a == b`。理想情况下，一个基本值装箱将始终生成相同的引用。在实践中，这使用现有的实现技术可能不可行。上述的规则是一种务实妥协，要求一些公共值的包装不可区分。实现可能会预先或惰性地缓存这些。对于其他值，规则不允许对程序员对包装值作任何假设。这允许 （但不要求） 共享部分或者所有的这些引用。`long`类型的整数字面值允许的但不要求共享。这将确保，在最常见的情况下，其行为将是所需的，没有施加不必要的性能损失，特别是在小型设备上。内存不太受限的实现可能，例如，缓存所有`char`和`short`值，以及-32K 到 +32 K 范围中的`int`和`long`的值。

如果创建包装类（`Boolean`、`Byte`、`Character`、`Short`、`Integer`、`Long`、`Float`或`Double`） 之一的新实例i没有足够空间，装箱转换可能会导致`OutOfMemoryError`

### 拆箱转换

- 从类型`Boolean`到类型`boolean`，如果`r`是`Boolean`类型的引用，则拆箱转换转换`r`为 `r.booleanValue()`
- 从类型`Byte`到类型`byte`，如果`r`是`Byte`类型的引用，则拆箱转换转换`r`为 `r.byteValue()`
- 从类型`Short`到类型`short`，如果`r`是`Character`类型的引用，则拆箱转换转换`r`为 `r.charValue()`
- 从类型`Character`到类型`char`，如果`r`是`Short`类型的引用，则拆箱转换转换`r`为 `r.shortValue()`
- 从类型`Integer`到类型`int`，如果`r`是`Integer`类型的引用，则拆箱转换转换`r`为 `r.intValue()`
- 从类型的`Long`到类型`long`，如果`r`是的`Long`类型的引用，则拆箱转换转换`r`为 `r.longValue()`
- 从类型`Float`到`float`类型，如果`r`是`Float`的类型的引用，则拆箱转换转换`r`为`r.floatValue()`
- 从类型`Double`到`double`类型，如果`r`是`Double`类型的引用，然后拆箱转换转换`r`为 `r.doubleValue()`

如果`r`是`null`，拆箱转换将引发`NullPointerException`

一个类型称为可转换为数值类型，如果它是数值类型 ，或者它是一个引用类型并有可转换为数值类型的拆箱转换。

一个类型称为可转换为整数类型，如果它是整数类型，或者它是一个引用类型并有可以转换为整型类型的拆箱转换。

### 未检查转换

令`G`为声明了n个类型参数的一个泛型类型，则
- 有从原始类或接口类型`G` 到任何参数化类型`G<T1,...,Tn>`的未检查转换
- 有从基本数组类型`G[]k`到任何数组类型`G<T1,...,Tn>[]k` 的未检查的转换。（符号`[]k`表示k维数组类型的）。

未检查转换的使用会导致编译期未检查警告，除非`Ti`(1 ≤ i ≤ n) 的所有类型参数都是无界通配符，或非检查警告被`SuppressWarnings`注解抑制

未检查转换用于容许引入泛型类型前写的遗留代码与转换为使用泛型的库平滑地互操作（我们称之为泛型化的过程）。在这种情况下 （最明显的是，`java.util`集合框架的客户），遗留代码使用原始类型 （如`Collection`而不是`Collection<String>`）。原始类型的表达式作为参数传递给相应形参类型为类型化参数的库方法版本。

这种调用不能静态地证明在使用泛型的类型系统下安全。拒绝这种调用会使很大部分现有代码失效，并阻止他们使用较新版本的库。反过来，会阻止库供应商利用泛型。为了防止这种不受欢迎的事件，一个原始类型可能转换为泛型类型对应声明。虽然转换是不健全的，它作为对实用性的让步。在这种情况下，发出了未检查警告。

### 捕获转换

令`G`为声明了n个类型参数`A1,...,An`的一个泛型类型，相应界为`U1,...,Un`，则存在着捕获转换从一个参数化类型`G<T1,...,Tn>` 为参数化类型`G<S1,...,Sn>`，其中对1 ≤ i ≤ n :
- 如果`Ti`是一个形如`?`，那么`Si`是一个新的类型变量，其上界是`Ui[A1:=S1,...,An:=Sn]`和其下界是 `null` 类型
- 如果`Ti`是一个形如`? extends Bi`不，则`Si`是一个新的类型变量，其上界是`glb (Bi,Ui[A1:=S1,...,An:=Sn])`和其下界是null类型。其中，`glb(V1,...,Vm)`被定义为`V1 & ...&Vm`，如果任何两个类 （而不是接口） `Vi`和`Vj`， `Vi`不是`Vj`的子类或相反，则是一个编译期错误。
- 如果`Ti`是形如`? super Bi`，则`Si`是一个新的类型变量，其上限是`Ui[A1:=S1,...,An:=Sn]`和其下限是`Bi`
- 否则为`Si=Ti`.

对于其他非参数化的类型作为恒同转换。 

捕获转换不递归地应用。捕获转换永远不会需要在运行期的特别工作，并因此从不引发运行期异常。

捕获转换旨在使通配符更有用。

### 字符串转换

任何类型可以转换为String类型：
1. 基本类型为`T`的值`x`先转换为一个引用，仿佛是被作为一个参数给适当的类的实例创建表达式：
    -如果`T`是`boolean`，则使用`new Boolean(x)`.
    -如果`T`是`char`，则使用`new Character(x)`.
    -如果`T`是`byte`、`short`或`int`，则使用`new Integer(x)`.
    -如果`T`是`long`，则使用`new Long(x)`.
    -如果`T`是`float`，则使用`new Float(x)`.
    -如果`T`是`double`，则使用`new Double(x)`.
2.
    - 如果引用值是`null`，它被转换为字符串`"null"`
    - 否则，好象是通过对引用的对象调用不带任何参数的`toString`方法执行转换，但是如果调用`toString`方法的结果为`null`，则使用字符串`"null"`。

### 禁止转换

未明确允许的任何转换是禁止的

### 值集转换

值集转换是从一个值浮点值映射为另一个而不改变其类型的过程。

- 对于不是 `strictfp`的表达式，值集转换提供实现进行选择︰
    - 如果值是float-extended-exponent值集的元素，则实现可能选择映射到最近的float值集的元素。这种转换可能会导致上溢 （在这种情况下值取符号相同的无限） 或下溢 （在这种情况下值可能会失去精度，因为它取而代之的非规范数或符号相同的零）。
    - 如果值是double-extended-exponent值集的元素，则实现可能选择映射到最近的double值集的元素。这种转换可能会导致上溢 （在这种情况下值取符号相同的无限） 或下溢 （在这种情况下值可能会失去精度，因为它取而代之的非规范数或符号相同的零）。
- 对于`strictfp`表达式，值集转换并不提供任何的选择，每个实现必须有相同行为方式︰
    - 如果值是类型float，但不是float值集的元素，则实现必须将值映射到最近的float值集的元素。这个转换可能导致上溢或下溢。
    - 如果值是double类型，但不是double值集的元素，则实现必须将值映射到最近的double值集的元素。这个转换可能导致上溢或下溢。

`strictfp`表达式内设置映射值从浮点扩展指数值或双精度扩展指数值集是必要的只有当一种方法调用其声明不是`strictfp`和执行选择的代表扩展指数值集的元素作为方法调用的结果。

值集转换不变动其类型不是`float`和`double`的值.

## 转换上下文

不同转换上下文容许不同的隐式转换，多态表达式类型规则也不一样。

### 赋值上下文

赋值上下文允许表达式的值将被分配给一个变量，表达式的类型必须转换为变量的类型。

赋值上下文允许使用下列转换之一︰
- 恒同转换
- 扩宽基本转换
- 扩宽引用转换
- 依次作装箱转换和可选的扩宽引用转换
- 依次作拆箱转换和可选的扩宽基本转换

如果在应用上面列出的转换之后，结果类型是原始类型，接着可以应用未检查的转换。

此外，如果表达式是一个类型`byte`、`short`、 `char`或`int`的常量表达式 :
- 如果变量的类型是`byte`、`short`的或`char`，常量表达式的值是变量类型可以表示的，可使用收窄基本转换。
- 可使用收窄基本转换，然后装箱转换，如果变量的类型为︰
    - `Byte`和常量表达式的值是`byte`可以表示的.
    - `Short`和常量表达式的值是`short`可表示的.
    - `Character`和常量表达式的值是在`char`类型可表示的.

可见`byte theAnswer = 42;`合法、`null`可赋值给任何引用类型。

转换链包含两个没有子类型关系的参数化类型是一个编译期错误.

如果表达式的类型不能在分配上下文中转换为变量的类型的，则发生编译期错误。

如果一个表达式的类型可以通过赋值转换转换为变量的类型，我们说表达式 （或它的值） 被赋给该变量，或等价地，那该表达式的类型是与赋值变量的类型是兼容的。

如果变量的类型是`float`或`double`，则值集转换被应用于转换的结果值`v`的是︰
- 如果`v`是`float`类型和`float-extended-exponent值集的元素，则实现必须映射到`float`值集最接近`v`的元素。这个转换可能导致上溢或下溢。
- 如果`v`是`double`类型和double-extended-exponent值集的元素，则实现必须映射到`double`值集最接近v的元素。这个转换可能导致上溢或下溢。

赋值上下文可抛出的仅有的异常是︰
- `ClassCastException`如果已应用上面的转换后，所得到的值是一个不是变量的类型的擦除的子类或子接口的实例的对象。
- 这种情况下才可能引起堆污染。在实践中，实现只在访问的域或方法的擦除的类型或返回类型与原来不同时需要执行强制转换。
- 由于装箱转换的`OutOfMemoryError`。
- 对 `null` 引用作拆箱转换的`NullPointerException`。
- 涉及数组元素或字段访问权限的特殊情况下`ArrayStoreException`.

### 调用上下文

调用上下文允许方法或构造器调用中的参数值将被赋值到相应的形参。

严格调用上下文允许使用下列操作之一︰
- 恒同转换
- 扩宽基本转换
- 扩宽引用转换

宽松调用上下文允许更加宽容的转换集，因为它们只用于使用严格调用上下文没有找到可用声明的特定调用。宽松调用上下文允许使用下列操作之一︰
- 恒同转换
- 扩宽基本转换
- 扩宽引用转换
- 依次用装箱转换和可选的扩宽引用转换
- 依次用拆箱转换和可选的扩宽引用转换

如果已列出调用上下文的转换后，结果类型是原始类型，接着可以应用未检查转换。

null类型的值 （null 引用是这样的值） 可能赋值到任何引用类型。

转换链包含两个不存在子类型关系的参数化类型是一个编译期错误。如果表达式的类型用类型宽松调用上下文允许的转换不能转换为参数的类型，也发生编译期错误。

如果变量的类型是`float`或`double`，则值集转换被应用于转换的结果值`v`的是︰
- 如果`v`是`float`类型和float-extended-exponent值集的元素，则实现必须映射到`float`值集最接近`v`的元素。这个转换可能导致上溢或下溢。
- 如果`v`是`double`类型和double-extended-exponent值集的元素，则实现必须映射到`float`值集最接近`v`的元素。这个转换可能导致上溢或下溢。

调用上下文中仅有可能抛出的异常是︰
- `ClassCastException`如果已应用上面的转换后，所得到的值是一个不是变量的类型的擦除的子类或子接口的实例的对象
- 由于装箱转换的`OutOfMemoryError`
- 对null引用拆箱转换的`NullPointerException`

严格或宽松的调用上下文中都不允许在赋值上下文中的整数常量表达式隐式收窄。因为若包括这些隐式收缩转换，我们就会将额外的复杂性添加到重载解析的规则。

### 字符串上下文

字符串上下文仅适用于运算符`+`操作数一个不是`String`而另一个是`String`。在上下文中的目标类型始终是`String`，并且字符串转换对非`String`操作数总是发生。

### 强制转型上下文

强制转型上下文允许类型转换运算符的操作数转换为转换运算符显式命名的类型。

强制转型上下文允许使用以下之一︰
- 恒同转换
- 扩宽基本转换
- 收窄基本转换
- 扩宽和收缩基本转换
- 扩宽引用转换后可选拆箱转换 或未检查转换
- 收窄引用转换后可选拆箱转换或未检查转换
- 装箱转换后可选扩宽引用转换
- 拆箱转换后可选扩宽基本转换

值集转换在类型转换之后进行。

编译期强制转换转换的合法性如下所示︰
- 基本类型的表达式可强制转换为另一个基本类型的，通过恒同转换 （如果类型是相同的）、扩宽基本转换、收窄基本转换、或扩宽和收缩基本转换。
- 基本类型的表达式可强制转换为引用类型不失信息，通过装箱转换。
- 引用类型的表达式可强制转换为基本类型不失信息，通过拆箱转换。
- 引用类型的表达式可能强制转换到另一个引用类型，如果没有编译期出现不可转换错误

给定编译期引用类型`S`（源） 和编译期引用类型`T` （目标），存在从`S`到`T`的强制转换，如果没有发生以下规则导致的编译期错误：
- 如果`S`是一个类类型︰
    - 如果`T`是类类型，然后要么`|S|<: |T|`或 `|T|<: |S|`。否则，将发生编译期错误。
    - 此外，如果存在`T`的超类型`X`和`S`的超类型`Y`，这样的`X`和`Y`是可证明不同的参数化类型，且`X`和`Y`的擦除一样，将发生编译期错误。
    - 如果`T`是一个接口类型︰
        - 如果`S`不是`final`类，存在`T`的超类型`X`和`S`的超类型`Y`，这样的`X`和`Y`是可证明不同的参数化类型，且`X`和`Y`的擦除一样，将发生编译期错误。否则，强制转换在编译期合法 （因为即使`S`未实现`T`， `S`子类可能）。
        - 如果`S`是`final`类，则`S`必须实现`T`，否则发生编译期错误。
    - 如果`T`是一个类型变量，那么这种算法递归地应用，使用`T`的上界的代替`T`
    - 如果`T`是数组类型，则`S`必须是类`Object`，否则发生编译期错误。
    - 如果`T`是一个交类型`T1 & ...&Tn`，存在`Ti`(1 ≤ i ≤ n) 使得`S`不能强制转换为`Ti`是一个编译期错误。
- 如果`S`是一个接口类型︰
    - 如果`T`是数组类型，然后`S`必须有类型`java.io.Serializable`或`Cloneable`（数组实现的唯一接口） 否则会发生编译期错误。
    - 如果`T`是一个类或接口类型，不是`final`，存在`T`的超类型`X`和`S`的超类型`Y`，这样的`X`和`Y`是可证明不同的参数化类型，且`X`和`Y`的擦除一样，将发生编译期错误。否则，强制转换在编译期合法 （因为即使`T`未实现`S`， `T`子类可能）。
    - 如果`T`是`final`的类类型，则︰
        - 如果`S`不是一个参数化的类型或原始类型，则`T`必须实现`S`，或者会发生编译期错误。
        - 否则，`S`是泛型类型声明`G`的参数化类型或`G`所对应的原始类型，则必须存在`T`的超类型`X`，`X`是`G`的特例，否则发生编译期错误。
        - 此外，如果`S`和`X`是可证明不同的参数化类型将发生编译期错误。
    - 如果`T`是一个类型变量，那么这算法递归地应用，使用`T`的上界代替`T`
    - 如果`T`是一个交类型 `T`1 & ...&Tn，那么如果存在`Ti`(1 ≤ i ≤ n) 使得`S`不能强制转换为`Ti`是一个编译期错误。
- 如果`S`是一个类型变量，那么这算法是递归地应用，使用`S`的上限代替`S`
- 如果`S`是一个交类型`A1 & ...&An`，则存在`Ti`(1 ≤ i ≤ n) 使得`Ai`无法转换为`T`是一个编译期错误。
- 如果`S`是数组类型`SC[]`:
    - 如果`T`是类类型，则如果`T`不是`Object`，则编译期错误 （因为`Object`是数组可以赋值到的唯一的类类型）。
    - 如果`T`是一个接口类型，除非`T`是`java.io.Serializable`类型或`Cloneable`类型（数组实现的唯一接口），编译期错误发生。
    - 如果`T`是一个类型的变量，那么这种算法是递归地应用，使用`T`的上界代替`T.`
    - 如果`T`是数组类型`TC[]`，则编译期错误发生，除非下列条件之一︰
        - `TC`和`SC`是相同的基本类型。
        - `TC`和`SC`是引用类型和类型`SC`可以强制转换到`TC`
    - 如果`T`是一个交类型，`T1 & ...&Tn`，那么存在`Ti`(1 ≤ i ≤ n) 使得`S`不能强制转换为`Ti`是一个编译期错误。


从`S`类型强制转换为类型`T`是静态已知正确的当且仅当`S <: T`

- 从`S`类型强制转换为一个参数化类型`T`未检查，除非至少下列条件之一︰
    - `S <: T`
    - `T`的类型参数都是无界通配符
    - `T <: S`且`S`没有除了`T`的子类型`X`使`X`的类型参数不包含于的`T`的类型参数.
- 从类型`S`到类型变量`T`的转换未检查，除非`S <: T`
- 从类型`S`到交类型`T1 & ...& Tn`，若存在i(1 ≤ i ≤ n)使从`S`到`Ti`的转换未检查，则未检查。

- 从`S`到非交类型T检查的转换完全未检查，如果从`|S|`到 `|T|`的转换是静态已知正确的。否则，它就是部分未检查.
- 从`S`到交类型`T1 & ...&Tn`完全未检查，如果对所有i(1 ≤ i ≤ n)，从`S`到`Ti`要么静态已知是正确或要么完全不检查。否则，它就是部分未检查.

检查的转换导致编译期未检查警告，除非用`SuppressWarnings`注解抑制。

强制转换是已检查的，如果它不是静态已知正确的它不是未检查。

如果强制转换为引用类型又不是一个编译期错误，有几种情况︰
- 强制转换是静态已知正确的。这时强制转换没有运行期工作。
- 强制转换是完全未检查的强制转换。这时强制转换没有运行期工作。
- 强制转换部为到一个交类型的部分分未检查转换或已检查转换。对交类型`T1 & ... &Tn`，则对所有i(1 ≤ i ≤ n)，从`S`到`Ti`所需的的任何运行期检查也是转换到交类型需要的。
- 强制转换是到非交类型的部分未检查强制转换。这种转换需要运行期间的有效性检查。检查好像是 `|S|`和 `|T|`间有已检查强制转换一样，如下所述。
- 强制转换为是到非交类型的已检查转换。这种转换需要运行期间有效性检查。如果在运行期的值为`null`，则允许强制转换。否则，令`R`为运行期间引用指向对象的类，令`T`为强制转换运算符中指定类型的擦除。类型转换在运行期必须检查类`R`赋值兼容类型。

对于任何给定的强制转换，首次用这些规则时`R`不能是接口，但规则递归地应用时`R`可以是接口，因为运行期引用值可以指向元素类型是接口类型的数组。

强制转换在运行期检查检查对象的运行期类型`R`是否与强制转换运算符中指定类型的擦除`T`赋值兼容类型。可能抛出运行期异常`ClassCastException`。
- 如果`R`是一个普通的类（不是数组类）︰
    - 如果`T`是类类型，则`R`必须是`T`或`T`一个子类的实例，否则引发运行期异常。
    - 如果`T`是一个接口类型，则`R`必须实现接口`T`，否则引发运行期异常。
    - 如果`T`是数组类型，则引发运行期异常。
- 如果`R`是一个接口︰
    - 如果`T`是类类型，则`T`必须是`Object`，否则引发运行期异常。
    - 如果`T`是一个接口类型，则`R`必须为`T`或其子接口，否则引发运行期异常。
    - 如果`T`是数组类型，则引发运行期异常。
- 如果`R`是表示数组类型RC[]:
    - 如果`T`是类类型，`T`必须是`Object`，否则引发运行期异常。
    - 如果`T`是一个接口类型，则除非`T`是`java.io.Serializable`类型或`Cloneable`类型（数组实现的唯一接口），否则引发运行期异常。这种情况下可能通过编译期检查，如果例如，对数组的引用存储在`Object`类型的变量.
    - 如果`T`是一个数组类型`TC[]`，则除非下列条件之一否则引发运行期异常︰
        - `TC`和`RC`是相同的基本类型。
        - `TC`和`RC`是引用类型且`RC`可以按这些规则强制转换为`TC`

### 数值上下文

数字上下文适用于算术运算符的操作数。

数值上下文下允许使用︰
- 恒同转换
- 扩宽基本转换
- 拆箱转换后可选扩宽基本转换

数值提升是一种过程，给定了一种算术运算符和其参数表达式，参数转换成推断的目标类型`T`。`T`在提升过程中选择，这样可以将每个参数表达式转换为`T`和算术运算的值定义为类型`T`.

#### 一元数值提升

一些一元运算符把数值提升应用于操作数，产生数值类型的值︰

- 如果操作数的编译期类型为`Byte`、`Short`、`Character`或`Integer`，它被拆箱转换。然后结果由扩宽基本转换或恒同转换提升为`int`类型的值
- 否则，如果操作数的编译期类型`Long`、`Float`或`Double`，它被拆箱转换.
- 否则，如果操作数的编译期类型`byte`、`short`的或`char`，被通过扩宽基本转换提升为类型`int`的值.
- 否则，一元数字操作数不会转换。

然后对结果进行值集转换。

一元数值提升在下列情况下进行︰

- 数组创建表达式中的每个维度表达式
- 数组访问表达式中的索引表达式
- 一元正运算符`+`的操作数
- 一元负运算符`-`的操作数
- 按位取反运算符`~`的操作数
- 移位运算符`<<`、`>>`或`>>>`的每个操作数
- `long`的移位距离（右操作数）不会使被移位的值 （左操作数）提升为`long`.

#### 二元数值提升

当运算符对它的一对操作数用二元数值提升，其中每个必须表示一个可转换为数值类型的值，下面的规则按顺序应用︰

1. 如果任何操作数为引用类型，它被拆箱转换.
2. 扩宽基本转换被用于转换一个或两个操作数︰
    - 如果任何一个操作数的类型为`double`，另一个被转换到`double`
    - 否则，如果任一操作数为`float`类型，另一个是要转换为`float`
    - 否则，如果任何一个操作数的类型为`long`，其他被转换为`long`
    - 否则，两个操作数都转换为`int`类型
3. 把值集转换应用到每个操作数

二元数值提升对以下运算符的操作数执行︰
- 乘法运算符`*`、 `/`和`%`
- 用于数值类型的加法和减法运算符`+`和`-`
- 数值比较运算符`<`、`<=`、`>`和`>=`
- 数值相等运算符`==`和`!=`
- 整数位运算符`&`、`^`和`|`
- 在某些情况下，条件运算符`? :` 

