# 上路 #

## 实践 ##

一般认为，掌握一门语言（或其它工艺）的一个必要条件是用它至少一万小时，这是免不了的，不实践光看书不仅难以形成应用能力，也不能产生真正的理解。然而，这只是必要条件而非充分条件，不断重复输入Hello World程序再多次都不能让你成为合格的程序员，我们需要逐渐进步的一万小时而不是同一水平地重复一万个一小时。
正如创作其它优秀艺术作品前往往要先广泛鉴赏现存的优秀作品一样，阅读优秀代码也是通往创作优秀代码代码之门。通过这样与优秀程序员的沟通，不仅可以学习到如何进行设计和实现，还有助于形成审美的品味。当前的自由软件运动为代码阅读提供了广阔的空间，在软件开发社区如[Github](https://github.com/)和[SourceForge](https://sourceforge.net/)，还有各大软件项目的网站，你可以找到各种各样的软件及其代码，包括许多相当成功的软件。要学习当然就要向好的（而不是差的）学习，但网上找到的代码质量参差不齐，因此需要会鉴别。一般而言，广为人知、用户众多、持续维护的软件代码质量通常不会太差，它们的成功已经说明了这点。由于不同类型项目的目标不同，不妨多看几个项目，以开阔视野。

阅读代码并不是漫无目的地读，读代码必须带着问题去读。你要想换着你会怎样做，再比较一下各方案，慢慢地，你就能体会到人家精妙之处，有时你也能看出改进空间。另外，看到不熟悉的库或语法时还可扩充知识面。读了不理解就是白读，检验理解与否的基本手段为给软件修正缺陷和增删特性。如果你有幸发现并修正缺陷，或是给软件增加了一个很有用的特性，希望你能向该项目提交建议。我们从他们得到了很多，理应在能力所及范围内作出点回报。

事实上，当你进入一家企业当程序员时，一开始让你干的活很可能就是修正缺陷和添加次要的功能，这实际上在煅练代码阅读。胸怀大志的读者的梦想往往是从头编写某个成功软件的核心代码，经常在这个阶段感到与期望有反差。但应当明白，大多数成功的项目大部分努力花在维护上，而且这种煅练对程序员的成长是有益的，正如这样累积起来的经验使你的梦想更具实现之可能。志存高远只有与立于当下相结合才可能富有成果，在慨叹怀才不遇之前请先确保你有才而不是眼高手低。

进一步，为了向打造你的梦幻软件的宏伟目标进军，还得独立开发一些相当规模的软件试试身手。一开始目标不必太远大，但应有挑战性又能看到阶段性的希望，还要预先给自己一个明确的验收标准（否则你的目标会退化为Hello World）和时限（否则用并发的术语是会“饿死”）。如果暂时没有特别想法，不妨先仿制你常用的某个软件，“如果把它改成xxx，也许更好”的想法涌现。

## 开阔眼界 ##

### 更多Java ###

#### Java SE ####

如果需要深入了解Java SE，[Java SE 8文档](http://docs.oracle.com/javase/8/docs/)是一个合适的出发点，你可以找到官方教程、JDK工具用法、规范（如Java语言的权威描述《The Java Language Specification》和虚拟机的权威描述《The Java Virtual Machine Specification》，不过最好不要太在意它们，你根本不应自找麻烦写出必须查规范才能弄懂的代码，除非你被迫要处理变态代码或开发底层语言工具），下图显示了Java SE的架构。



假如你还想要纸质版的图书，可以考虑以下的：

  * Cay S. Horstmann, Gary Cornell的《Java核心技术》（Core java）选材比较全面和实用。在第十版中文版出之前，可以结合《写给大忙人看的Java SE 8》看。
  * Ken Arnold, James Gosling, David Holmes的《Java程序设计语言》（The Java programming language）对java语言及其设计考虑作了精僻的说明，但似乎java5后没再更新。
  * Joshua Bloch的《Effective Java》（Effective Java）列出一些常见错误和有用建议。
  * Benjamin J. Evans，David Flanagan的《Java技术手册》（Java in a Nutsbell）可作java语言的语法快速参考，不过用了一小段时间后你不应该还要查语法，你说话要査语法书吗？
  * Steven John Metsker的《设计模式Java手册》（Design patterns Java workbook）总结了一些常用的设计模式，有点经验的话应已自己发现其中内容。

#### Java EE ####

Java EE的目标为开发可伸缩、可靠和安全的多层网络应用，会Java EE至少对找工作大有好处。在这里你会碰到各种各样的框架，但不要被名词吓怕，它们的用途是清楚的。Java EE系统大致分为：

  * 客户端
  * Java EE服务器
      * 表现
      * 业务逻辑
  * 信息系统

#### Android ####

目前Android已经成为手机和平板等移动设备上主流的操作系统，Android内置了一个定制的Java运行环境，大部分Android应用也基于Java。如有兴趣开发Android应用，请到[Android开发者站](https://developer.android.com/index.html)下载Android Studio开发环境（基于IntelliJ IDEA），该网站也提供了API文档和教程等学习资源。虽然Android的GUI和国际化和Java SE做法有点不同，但通过参考样例项目读者应能很快上手。相形之下现在Java ME似乎被Android压制。

### 其它语言 ###

由于不同的语言有不同特长，在工作中有时需要混合使用多种语言。通过扩充你的语言储备，知道什么时候该用什么，选对语言可收事半功倍、出奇制胜之效。有的语言虽然不常用，但却很有启发性，利于破除思维定势，学习它们有助于让你成为更佳的Java程序员。以下列出一些有代表性的语言（由于新语言层出不穷，大部分不成气候，我们仅列出一些久经考验的）：

Scheme语言是一种追求一致性的语言，拥有极简的语法，精晰的语义。Scheme语言和其它Lisp家族语言一样最初被用于人工智能领域，现在除用作教学和研究外，还被用作扩展语言（类似Microsoft Office中的宏），GNU项目正打算用Scheme作为各子项目的扩展语言并为此开发了一个解释器guile。Harold Abelson, Gerald Jay, Julie Sussman的《计算机程序的构造和解释》（Structure and Interpretation of Computer Programs）长期在多家大学被作为本科生第一门课的教材，低起点但深刻而全面，是一切编程教材的典范，极力推荐所有读者读读这本书。我仍然坚持，如果没有要立即投入工作的迫切性，Scheme是第一门语言的首选，因为它简单易学，可以集中于程序设计本身而不被次要的细节干扰。

C语言自从作为重写UNIX的副产物出现于1971年便经久不衰，现在各主流操作系统核心部分大都仍然用C写。C语言很快超出系统编程，成为使用范围最广泛的语言，从嵌入式系统到应用程序。C语言对后来流行的大多数语言影响明显，其中很多最初就用C来实现。Brian W.Kernighan , Dennis M.Ritchie的《C程序设计语言》（The C Programming Language）是接触C的最佳教材和参考书。借助于JNI，可以做到Java代码和C代码相互调用，通过调用C代码，可能可以取得更低层的控制或者提高一点点性能，有时则仅为了使用现成的大量成熟C库，但往往也会削弱可移植性。

C++最初只是让C语言加上类，后来又加入了模板、异常、名字空间、运算符重载等大量特性。一些人发现C++增加的特性有用且性能仍不错，又与C语言有不错的兼容性，而其它人觉得C++胡乱堆砌特性导致太多混乱。想了解C++语言的话请参考Bjarne Stroustrup的《C++程序设计语言》（The C++ programming language）。同样借助于JNI，可以做到Java代码和C++代码相互调用。

Perl以强大的文本处理能力著称，CPAN这个可依靠的庞大仓库也助力于它的流行。由于大部分类UNIX系统都预装了perl，你可能想用perl代替shell写部署或运维脚本。对Perl的批评主要是易写难读，不好维护。有兴趣可参考Larry Wall等的《Perl语言编程》（Programming Perl）或[官方网站](https://www.perl.org/)。

Python和Ruby都是强调面向对象的动态语言，可读性可能比Perl好一点，运行起来则较慢。它们的语法和语义看起来干净，但实际上很缺乏一致性。

JavaScript作为客户端网页脚本的事实标准，对开发网页是重要的。必须指出，不应被名称误导，JavaScript与Java完全是两种不同的语言，前者是相当动态的语言，采取基于原型的面向对象。不过，Java 8开始自带了名为Nashorn的解释器，于是可以方便地用JavaScript作为Java程序的扩展语言。另外，命令行工具jjs可用于试验Java的API，有点像动态语言常有的REPL。

PHP作为服务器网页脚本的事实标准，如要开发网站很可能也会碰到。有兴趣可参考[官方网站](http://php.net/)。

Fortran在仍然流行的高级语言大概是最老的（始于1955），由于多年来累积了很多代码，编译器优化做到登峰造极，现在仍然是数值计算的老大，在工程和科学中有广泛应用。虽然Fortran也一直在发展，但早年的约束条件使它不时被拿作反面教材。

COBOL是另一种历史悠久的语言（始于1959），其COBOL之母也是编译器和bug之母（美国海军首位女将军默里·霍柏），主要用于生成商业报表，目前在银行和保险等行业还有大量COBOL代码。一种批评认为COBOL语言过度模仿英语引致很繁琐。

Prolog作为罕见的逻辑式编程语言，程序员先声明一些事实和推理规则，然后程序员给出查询，最后系统作出应答。虽然Prolog在人工智能领域曾被寄予厚望，但由于效率太低而甚少用于最终产品，与经典逻辑也不全一致，有时可用来做小规模试验。

Haskell作为罕见的纯函数式语言，除了从ML继承了静态类型推断算法，还采取了惰性求值，这使它与其它语言很不同，目前主要只在学术界用来被研究。

汇编语言作为接近硬件的低级语言，可以取得一些高级语言无法取得的控制，因此操作系统和驱动程序有小部分必须用汇编语言书写，但由于汇编程序难于维护，一般尽可能使这部分小。过往有时由于效率原因把一些性能关键代码用汇编代码改写，但现在已经不建议这样，因为现代的优化编译器生成的往往比人工写的更快。

如果想找出更多语言并比较各语言的流行度，可看[tiobe排行榜](http://www.tiobe.com/tiobe-index/)。以下列出部分语言的族谱。



关于各种语言更详尽的异同对比可参考John C. Mitchell的《程序设计语言概念》（Concepts in programming languages）或Robert W. Sebesta的《程序设计语言原理》（Concepts of programming languages）。由于不同的语言不外是一些标准特征的组合，了解几种差异较大的语言后，以后要用其它语言就容易上手。

### 理论内功 ###

由于工作范围的限制，我们的软件开发经验不会很全面，而且其它人做我们做过的事可能做得更好，因此除了直接经验外，还需要学习别人的间接经验。当然学习必须是批判性的学习，不能让过往自身经验成为妨碍进步的包袱，也不能盲目应用导致水土不服（你可以想像用十几种设计模式的Hello World）。吸收间接经验难免要看书，但不能抱看一两本书就能登堂入室的过度期望，不修炼的话即便秘籍也是虚的。虽然我推荐的书籍原文大多非中文，但我强烈建议读者看中译本而不是原文，即使翻译质量不太好理解起来也往往远比看原文好，因为读外文书时我们倾向有意无意地压低对理解层次的要求（很多人看外文书弄懂每个词就已经满足，不奢望书的含义）。顺带一提，由于现在出版容易，每种语言的书质量都参差不齐，而翻译是要付出很大精力的，起了筛选的作用，故能够翻译引进的书质量相对较好，选书宜选翻译版。

#### 硬实力 ####

坦白地说，仅仅做程序设计没有必要知道太多计算机的原理，正如画画没有必要知道颜料的化学成分和制备方法。不过，确实有时候一些理论能帮我们解决一些脆异的问题，特别是与性能和正确性有关的场合，当然前提是能把理论学透且观察入微，干唸书不会把书本上知识和实际情况对上是没有意义的。

如果你现在还觉得编译器是一个神怪般的存在，你可以去看一看Java编译器的代码，你将发现Java编译器也就是一个Java程序而已（你会问那最初的Java编译器怎么编译，其实最初有个Java编译器是用C写的，用它来编译Java版Java编译器，从此就可以用老的Java版Java编译器编译新的Java版Java编译器，同理可说说明汇编器和C汇编器何以可能）。如果你意犹未尽，想了解编译器的工作原理，可以看一下编译原理的书，如Andrew W. Appel, Maia Ginsburg的虎书《现代编译原理 : Java语言描述》（ Modern compiler implementation in Java）。即使不打算做编译器（解释器倒很可能要做），了解编译器的优化机制也可破除一些迷信，例如你会知道把x*2改成x<<1无助改善性能，事实上要是有人告诉你什么改善性能的万应偏方，你都不会轻信，它要是有效难道编译器作者会不让编译器自动做该优化吗？

操作系统提供了进程、地址空间和文件系统三大抽象，它们很多时候工作得很好以致我们不用了解它们的实现。但稍为读一下Andrew S. Tanenbaum的《现代操作系统》（Modern operating systems）和Umakishore Ramachandran, William D. Leahy Jr.的《计算机系统 : 系统架构与操作系统的高度集成》（Computer systems : an integrated approach to architecture and operating systems）还是可能派上用场。例如知道并发进程调度就不应写出错误的计时代码，知道缓存的存在可以写出空间局部性较好的程序以改善性能，知道硬盘特性可以避免一些低效的读取方式。此外，传统上，操作系统的书会讲一下基本并发问题，虽然也许不会介绍软事务内存或actor等高层构造。

Java集合框架提供了很多实用的数据结构和算法，javadocs的说明也很清晰。但如果想了解内部细节，除了看代码外还可以参考一些书籍。最经典的当然要数Donald E. Knuth的《计算机程序设计艺术》（The art of computer programming），但百科全书很难读下去。Thomas H. Cormen等的《算法导论》（Introduction to algorithms）也较严格地介绍了很多数据结构和算法，但比较对程序员口味的应该是Jon Bentley的《编程珠玑》（Programming pearls）。当然，每个程序面对不同的问题，不能期望从这些书中总能找到恰好需要的，重要的是学会必要时自己建立自己的数据结构和算法。通常，数据结构是关键，有了合适的数据结构，算法就是自然而然的。

我们已经看到计算机可以解决很多问题，但并不能解决所有问题，例如停机问题就不能（假定有个方法static boolean checkStop(Method m)可检查无参静态方法m会否终止，考虑传入的方法m方法体为
```Java
    if(checkStop(m)){
        while(true);
    }
```
会怎样）。John E. Hopcroft, Rajeev Motwani, Jeffrey D. Ullman的《自动机理论、语言和计算导论》（Introduction to automata theory, languages, and computation）探讨了计算能力的限制，还考虑了理论上的性能问题。顺带推荐一下侯世达的文学巨著《哥德尔、艾舍尔、巴赫 : 集异璧之大成》，可以满足智力的好奇心。 

我们认为，程序设计是计算机领域的中心问题，学习计算机理论时刻要想着它对程序设计意味着什么，否则就会失去方向，陷入越来越无足轻重的支流。

#### 软实力 ####

除了技术层面外，人的因素也是不可忽视的。以下是一些偏人文的经典计算机书籍，它们之间观点不全一致，但这恰有助你形成你自已的观点。

  * Andrew Hunt, David Thomas的《程序员修炼之道 : 从小工到专家》（The pragmatic programmer : from journeyman to master）
  * Fred Brooks的《人月神话》（Mythical man-month）
  * Pete McBreen的《软件工艺》（Software craftsmanship）
  * Paul Graham的《黑客与画家》（Hackers and painters : big ideas from the computer age）
  * Brian W. Kernighan, Rob Pike的《程序设计实践》（The Practice of Programming）
  * Steve McConnell的《代码大全》（Code complete）
  * Eric S. Raymond的《UNIX编程艺术》（The art of UNIX programming）

当然，自身的经历是最深刻的，在成长过程中自我调整才能成就理想。

最后，在任何情况下都要勿忘初心，不要迷失方向。就是程序设计也不是终极目标，写出优秀的软件是为人民服务，将来还要实现共产主义呢。
