---
title:  "用Solr打造定制的搜索引擎"
layout: post
mathjax: true
tags: java web
---

在数据分析、站内搜索等应用中，我们往往需要有自己的搜索服务。[Apache Solr](http://lucene.apache.org/solr/)（用户包括Instagram、Netflix和Digg）和[ElasticSearch](https://www.elastic.co/cn/products/elasticsearch)（用户包括GitHub、Quora和eBay）就是目前最流行的开源搜索服务器软件，无独有偶，它们都基于用Java语言编写的搜索引擎[Apache Lucene](http://lucene.apache.org)。

## 开始使用Solr

1. 确保Java运行时环境已经安装好
2. [下载Solr](https://lucene.apache.org/solr/mirrors-solr-latest-redir.html)
3. 进入解压后目录
4. 运行`bin/solr start -c`启动Solr云
5. 运行`bin/solr create -c 集合名 -s 2 -rf 2`创建一个集合，其中`-s 2`表示集合索引数据分散到两个节点、而`-rf 2`表示所有索引数据有两个复本
6. 回到命令行运行`bin/post -c 集合名 需要索引的文件列表`以索引一些你想以后能搜索到的文件
7. 在浏览器打开[http://localhost:8983/solr/](http://localhost:8983/solr/)进入控制台
8. 从左下方选择刚创建的集合
9. 在`Query`选项卡中进行查询

## 搜索引擎的工作方式

设想有一本书（如《电工手册》），我们想知道里面有没有一个词（如“无刷电机”），有的话在哪些段落中。如果这本书没有索引，则我们可能需要把整本书看完才知道，除非十分走运，这个词刚好出现在我们一开始翻的哪几页。对于一本书，还可以勉为其难地这样干，但如果要在整个大型图书馆中这样去找一个词出现在哪些书中则可以认为是不可能的任务。如果这本书有索引，我们只用在索引中找有没有“无刷电机”这个词，由于索引中各个词是排好序的，能够很快地定位它，然后有的话索引就告诉我们这个词在哪页出现。如果希望的话，我们甚至可以通过把图书馆中所有书的索引合并起来。由于图书的物理结构是把位置自然地对应的词，这种把词对应到位置的索引也叫倒排索引。我们要强调的是，建立索引是一次性的，却可以为大大缩短了查询所需的时间。

对于数字数据也是同样道理，我们对需要搜索到的数据做一次索引，然后查询就能基于索引而不是原始数据进行，这样查询可能做到非常快。和图书一样，索引本质上是个映射，把关键词对应到它所在文档的列表。倒排索引有不同的实现方式，例如映射表可以是B+树、分布式散列表或者其它数据结构，文档列表可以用链表、位图或者其它数据结构实现，但这些细节还是留给Lucene的开发者去考虑好了。

建立索引时，需要进行以下工作：
1. 导入数据。要索引文档首先要取得文档，我们把文档看作由一些字段组成。导入文档有以下途径：
    - 来自文件
        - 对于XML、JSON、CSV等格式的文件，它们清晰地给出了结构化数据
        - 对于PDF、Microsoft Office、OpenDocument、RTF、HTML、TXT、LOG等格式的文档，还需要一些程序来进行解析并提取出各字段
    - 来自数据库
2. 分析各个字段的值，
    1. 分词。把字段值分解成单词有许多不同方法，如单词满足的正则表达式、分隔符满足的正则表达式、N-Gram。对于欧洲语言，分词相对简单，不论以最长字母序列作为单词还是在空白和标点符号处切分都有不错的效果。但对于中日韩语言，要准确切分并不容易，基于词典的最长前缀切分要求词典不断更新（这也是许多搜索引擎也做输入法收集数据的原因，但每次更新词典后更新索引成本太高，不然又会影响搜索质量），有时干脆把每个字符或N-Gram（如“万里长城永不倒”分成2-Gram“万里”、“里长”、“长城”、“城永”、“永不”、“不倒”）当作单词。
    2. 过滤。对单词序列往往会进行一些变换，比如：
        - 统一大小写。搜索者通常不在乎结果的大小写。
        - Unicode规范化。同一字符序列如重音、连写、全半角、繁简等等有不同的表示，需要规范化。
        - 词干提取。有的语言中动词有多种时态、名词有多种复数形式，有时会带“'s”之类，而搜索者通常不在乎这些，需要把它们归一化。
        - 加入同义词。搜索者通常也希望搜索同义词时结果类同。
        - 加入同音词或拼音。搜索者往往会犯拼写错误或者根本不知道一个字怎么写却知道怎么读。
        - 去除停用词。去除太常见的词可节省空间。如英文中常去除“a”、“an”、“and”、“are”、“as”、“at”、“be”、“but”、“by”、“for”、“if”、“in”、“into”、“is”、“it”、“no”、“not”、“of”、“on”、“or”、“such”、“that”、“the”、“their”、“then”、“there”、“these”、“they”、“this”、“to”、“was”、“will”、“with”。不过这样下来搜索“To be or not to be”就没有有意义的结果了，所以往往有另一个保护词名单。
        - 去掉两侧空白。
3. 更新索引。让上一步最后得到词指向文档。不过有的的搜索系统会拒绝与已经索引过的文档高度雷同的文档，这通常是通过增加一个散列值字段来实现的。

在查询时，需要进行以下工作：
1. 解析用户的查询。根据搜索语法和语义理解用户的查询，即结果应满足的条件（如`足球 篮球 -网球 site:cctv.cn`可能被理解为寻找含有“足球”或“篮球“的文档，它的site字段为“cctv.cn”，其中不能含有”网球”），这还可能需要应用类似于与索引时字段分析的方法。
2. 通过倒排索引找出结果集的一个超集（如上例中可能为含“足球”文档集和含“篮球“文档集的并）。
3. 过滤，即从上一步结果集中去除不满足整个查询的结果集（如上例中可能要去除含“网球“文档集和site字段不匹配“cctv.cn”的文档集）。
4. 对结果排序。当搜索结果很多时，用户一般只会注意到排在最前面的结果，所以排序对搜索质量非常重要。
    - 相关度。我们希望与查询最吻合的结果排在最前面。至于相关度的计算有不同方法，为了简单见，我们仅介绍一种基本的方法，基本想法是计算查询中各单词频率与文档中各单词频率的相似性（使用频率而不是频数是因为避免对不同查询都返回几乎什么词都有的长文档），但注意到不同词的重要性是不同的，越罕见的词应该越有区分力。假设索引中有词$k\_1,\dots,k\_n$，在一个并查询中它们的频率分别为$f\_1,\dots,f\_n$，在文档中它们的频率分别为$F\_1,\dots,F\_n$，而在所有文档中它们出现的频率分别为$N\_1,\dots,N\_n$，则记$q=(\log (1+f\_1)\log \frac{1}{N\_1},\dots,\log (1+f\_n)\log \frac{1}{N\_n})$，$d=(\log (1+F\_1)\log \frac{1}{N\_1},\dots,\log (1+F\_n)\log \frac{1}{N\_n})$，于是查询与文档的相关系数为$\frac{q\cdot d}{\vert q\vert\vert d\vert}$。其中$q$、$d$中各分量的计算有不同方法，但都是一个跟局部词频有关的因子（TD）和一个与全局词频有关的因子（IDF）之积。由于查询中词一般很少，公式中非零项很少，所以计算可以很快。
    - 流行度。基于越多人需要的页面也应该是你会需要页面的信念，流行的结果应该排在前面。
        - 入链。基于随机行走模型，用户在进入每个页面后，有一定的概率后退、一定的概率输入一个网址、余下情况则是随机点击页面上的链接，据此可估算用户进入每个页面的概率，这可作为流行度的一个指标，Google当年成名的PageRank算法就在做这事情。
        - 浏览数据。点击率、浏览量、收藏量等等都可反映流行度，许多搜索引擎厂商也做浏览器和公开DNS服务器的部分原因就是要收集这些数据。
    - 字段。对于结构化数据的搜索，根据发布日期、价格等字段排序可能是有意义的。
    - 综合评分。通过把多种指标通过某种公式（如加权平均）结合起来得出一个评分可能可比较完整地反映用户偏好，至于公式及其中参数的选取通常要慢慢试错。
5. 附加工作。对于一个现代的搜索系统，还往往包含以下功能：
    - 搜索建议。建议用户进行另一个查询，这可能基于拼写检查器、关联词（搜索结果中共同出现的其它词）或者协同推荐（其它和你作出过类似查询的人也作了什么查询）
    - 分片。建议用户加上过滤条件，如主题、日期范围等等。
    - 类似结果。需要时用与某个文档的相关度排序结果，在电子商务网站中常见的“类似产品”就是例子。
    - 结果高亮。搜索结果摘要中突出显示出现的搜索关键词，以便让用户理解为什么系统会提供这结果。
    - 结果聚类。可以根据字段或聚类算法把类似结果放在一起以便用户筛选，例如把来自同一问答类网站（如百度知道或Stackoverflow）结果放在一起，又或把对应一个词不同含义的结果分开（如在“IDE”的结果页把关于“Integrated development environment“和关于”Integrated Drive Electronics”的结果分开）。
    - 定制结果。对于特定类型的查询，可能可设计专门的结果，如显示来自维基百科的摘要、加上竞价广告、搜索算式时返回计算结果。

## 配置Solr集合



## 用Solr索引数据

## 用Solr搜索



参数|用途|默认值
---|---|---
defType|查询解析器，下一小节会进一步介绍|lucene
sort||
start|返回的首个结果的序号|0
row|返回的结果个数|10
fq|附加查询，返回的结果必须满足这查询（但不影响评分），往往比直接写到主查询时更快|
fl|返回结果中包含的字段列表（用`,`分隔）|
debug|返回的调试信息类型（可指定多次）：`query`、`timing`、`results`、`all`（或`true`）|
explainOther|比较查询，会返回它与主查询分别前列结果评分差异的说明|
timeAllowed|限时（毫秒），超时的话结果计数和分片计数等统计数据可能不准确|

### 搜索语法



### 高亮

### 分片

### 类似结果

### 结果聚类

