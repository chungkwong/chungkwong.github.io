《编程珠玑》
重复代码写进数组、封装复杂结构、让数据构造程序、用高层工具
最大总和子向量线性算法、搜索引擎倒排、马尔可夫链文本生成、拼写检查、后缀数组
插入排序、归并排序（外）、快速排序、堆排序（固定额外空间）、位图排序、基数排序
顺序查找、二分查找、散列查找、搜索树
优先队列、选择、移位、幂、多项式
加速应瞄准层次（容易而有效）
空间换时间：扩展数据结构、存储预先计算结果、高速缓存、懒惰计算
时间换空间：压缩、解释程序
循环：移出、合并测试条件（如哨兵）、展开、消除无条件分支、合并
逻辑：单调性、重排分支、预先计算
过程：常用情况、协程、尾递归、并发
表示：代数恒等式（求余）、归纳变量、消除公共表达式、打包字并发
处理正确的问题、展示解决方案的设计空间、查看数据、使用封底估算、利用对称性、使用组件进行设计、建立原型、必要时权衡、尽可能简单、尽量优美

《编程珠玑续》
性能监视：单词个数
关联数组：有限状态机、拓扑排序
忏悔：脚手架、最小出错用例（修正错误第一步为重现）、程序验证
自描述数据：名字-值对、文档在源中、来源
调试：定位特殊性（键帽错位致站立登不上、Quito停机、图书馆触摸板不灵敏）、运筹学家电梯旁装镜、用合适工具
小语言 Pic，lex，yacc，make
文档设计 迭代、一致、简约
图形化输出：表现力、统计完整性、美观、必要
取样：Floyd算法
语录
pi秒=纳世纪
回归测试把测试区间减半
剽窃即最诚恳的恭维
拿不准用穷举
代码与注释不一致通常两者皆错
特殊情况多就是错方法
数据结构清楚则其余自明
最少惊异（可预测）
手工表单20%坏数据
80%表单有多余问题
先做最难部分
计算机能做的决不人手
修不好就说没坏
测试无法证明正确

《Design by contract原则与实践》
1. Design by Contract的六大原则:
原则1 区分命令和查询。查询返回一个结果，但不改变对象的可见性质。命令改变对象的状态，但不返回结果。
原则2 将基本查询同派生查询区分开。派生查询可以用基本查询来定义。
原则3 针对每个派生查询，设定一个后验条件，使用一个或多个基本查询的结果来定义它。这样一来，只要我们知道基本查询的值，也就能知道派生查询的值。
原则4 对于每个命令都撰写一个后验条件，以规定每个基本查询的值。结合“用基本查询定义派生查询”的原则(原则3)，我们现在已经能够知道每个命令的全部可视效果。
原则5 对于没个查询和命令，采用一个合适的先验条件。先验条件限定了客户调用查询和命令的时机。
原则6 撰写不变式来定义对象的恒定特性。类是某种抽象的体现，应当将注意力集中在最重要的属性上，以建立关于类抽象的正确概念模型。
 
2. Design by Contract的六大准则:
准则1 在适当的地方添加物理限制。尤其是那些需要限制变量不应该为void的地方。
准则2 先验条件中尽可能使用高效的查询。如果有必要，可以增加高效的派生查询，并在其后验条件中确保其与较低效的基本查询之间的等价关系。
准则3 用不变式限定属性。如果一个派生查询被实现为一个属性，则应通过类中不变式的断言保证它与其他查询保持一致。在一个类的开发过程中，通常应该先把断言检测的级别设为最高级，使先验条件、后验条件和不变式都得到检测；一旦通过了检测和测试，一般就可以降低断言检测的级别，只检测先验条件，以提过代码的运行效率。
准则4 为了支持特性的重定义，用相应的先验条件确保每个后验条件。这样就允许在子类开发过程中进行各种不可预见的重定义。
准则5 将预期发生的变化和框定规则这两种不同的限制分别放置在不同的类中。这使开发者在扩展已有类时享有更多的自由。
准则6 若有保密性要求，则违背保密性的查询只能被设为私有熟悉在契约中使用。这里的“设为私有”，是对“在契约中使用了该查询的类”之下的层次而言，至于类之上的层次，这个查询当然是可以使用的。

《可用性工程》
原则：节省成本、从现在做起、用户（不）总是对的、用户不同于设计人员、少就是多、细节是重要的、帮助不能帮助、可用性是过程
方法：用户和任务观察、剧情、简化自言自语、经验性评估
可用性：易学、高效、易记、难错
可用性工程生命周期：了解用户、竞争性分析、确立目标、并行设计、参与型设计、整体界面的协调、指南应用和经验性评估、原型、界面评估、反复设计、对已安装系统的跟踪研究、元方法、可用性活动的优先顺序、有所准备
可用性经验准则：
简洁而自然的对话（直接概念映射、信息位置对、一起用的近、颜色仅用于强调防色盲）
使用用户的语言（避免不常用含义、用户投票选名字、容许别名）
将用户的记忆负担减到最小（用有意义默认值指示格式）
一致性（符合预期）
反馈（响应快、否则给进度指示已完成和预期）
清楚地标识退出（状态回滾、前台优先、可见）
快捷方式（快捷键、缩写、宏、最近用过）
好的出错信息（清晰自明、精练准确、建设性（总行/ATM故障）、友好）
避免出错（提供选择如文件名、适度确认、避免模式、至少状态标识）
帮助和文档（可搜索、上下文相关、可并排、参考卡片、入门手册）
可用性测试：测试目标和测试计划、招募测试用户、选择实验人员、用人来进行测试的伦理问题、测试任务、测试的各个阶段、绩效度量方法、边做边说法、可用性实验室
其他可用性评估方法：观察法、问卷调查与访谈、焦点小组、记录实际使用情况、用户反馈
标准：易学、降低开发成本、妨碍进步
国际化用户界面：图标、容许国际字符、数字、货币、日期、时间、资源分离、多地化界面

《UNIX编程思想》
GUI问题在于衔接，过滤器最好。CLI劣势为记忆。
如果你把你的全部聪明才智用于编码，调试就无能为力了。
宽入严出但小心html，不增删无用信息
Keep it simple, stupid
接口/实现复杂度：本质/选择/偶然
界面：最少立异、沉默是金、自动检测优于询问
Brian Kernighan：
编程的本质在于控制复杂度
Rob Pike：
花哨的算法在n很小时通常很慢，而n通常很小。花哨的算法更容易出bug。
数据压倒一切。如果已经选择了正确的数据结构并把一切组织得井井有条，正确的算法也就不言自明。编程的核心是数据结构而不是算法。
Ken Thompson：
拿不准用穷举
Hoare：
软件设计有两种方式：使之简单到明显没有缺陷，使之复杂到没有明显缺陷。第一种方式要难得多。
diff -c/-u 
项目-版本.src/bin.扩展名
尊重本地约定
发布（解包到新目录、README、容许多版本并存、deb/rpm、Checksum、通告）
IETF：我们反对国王、总统和投票。我们信任想任大致的共识和可运行的代码。
老子：不言之教，无为之益，天下希及之
《程序员修炼之道》
1 我的源码让猫给吃了
在所有弱点中，最大的弱点就是害怕暴露弱点。
提供各种选择，不要找蹩脚的借口
 
2 软件的熵
　　一扇破窗户，只要有那么一段时间不修理，就会渐渐给建筑的居民带来一种废弃感——一种职权部门不关心这座建筑的感觉。于是又一扇窗户破了。人们开始乱扔垃圾。出现了乱涂乱画。严重的结构损坏开始了。在相对较短的一段时间里，建筑就被损毁得超出了业主愿意修理的程度，而废弃感变成了现实。
　　不要留着“破窗户”（低劣的设计、错误决策、或是糟糕的代码）不修。发现一个就修一个。如果没有足够的时间进行适当的修理，就用木板把它钉起来。或许你可以把出问题的代码放入注释（comment out），或是显示“未实现”消息，或是用虚设的数据（dummy data）加以替代。采取某种行动防止进一步的损坏，并说明情势处在你的控制之下。
3 石头汤与煮青蛙
做变化的催化剂
 
记住大图景
 
4 足够好的软件
使质量成为需求问题
 
　　在某些方面，编程就像是绘画。你从空白的画布和某些基本原材料开始，通过知识、艺术和技艺的结合去确定用前者做些什么。你勾画出全景，绘制背景，然后填入各种细节。你不时后退一步，用批判的眼光观察你的作品。常常，你会扔掉画布，重新再来。
　　但艺术家们会告诉你，如果你不懂得应何时止步，所有的辛苦劳作就会遭到毁坏。如果你一层又一层、细节复细节地叠加，绘画就会迷失在绘制之中。
　　不要因为过度修饰和过于求精而毁损完好的程序。继续前进，让你的代码凭着自己的质量站立一会儿。它也许不完美，但不用担心：它不可能完美（在第6章，171页，我们将讨论在不完美的世界上开发代码的哲学）。
5 你的知识资产
- 定期投资。就像金融投资一样，你必须定期为你的知识资产投资。即使投资量很小，习惯自身也和总量一样重要。在下一节中将列出一些示范目标。
- 多元化。你知道的不同的事情越多，你就越有价值。作为底线，你需要知道你目前所用的特定技术的各种特性。但不要就此止步。计算技术的面貌变化很快——今天的热门技术明天就可能变得近乎无用（或至少是不再抢手）。你掌握的技术越多，你就越能更好地进行调整，赶上变化。
- 管理风险。从高风险、可能有高回报，到低风险、低回报，技术存在于这样一条谱带上。把你所有的金钱都投入可能突然崩盘的高风险股票并不是一个好主意；你也不应太保守，错过可能的机会。不要把你所有的技术鸡蛋放在一个篮子里。
- 低买高卖。在新兴的技术流行之前学习它可能就和找到被低估的股票一样困难，但所得到的就和那样的股票带来的收益一样。在Java刚出现时学习它可能有风险，但对于现在已步入该领域的顶尖行列的早期采用者，这样做得到了非常大的回报。
- 重新评估和平衡。这是一个非常动荡的行业。你上个月开始研究的热门技术现在也许已像石头一样冰冷。也许你需要重温你有一阵子没有使用的数据库技术。又或许，如果你之前试用过另一种语言，你就会更有可能获得那个新职位……
批判地分析你读到的和听到的
 
与古鲁打交道的礼节与教养
　　随着Internet在全球普及，古鲁们突然变得像你的Enter键一样贴近。那么，你怎样才能找到一个古鲁，怎样才能找一个古鲁和你交谈呢？
　　我们找到了一些简单的诀窍。
- 确切地知道你想要问什么，并尽量明确具体。
- 小心而得体地组织你的问题。记住你是在请求帮助；不要显得好像是在要求对方回答。
- 组织好问题之后，停下来，再找找答案。选出一些关键字，搜索Web。查找适当的FAQ（常见问题的解答列表）。
- 决定你是想公开提问还是私下提问。Usenet新闻组是与专家会面的美妙场所，在那里可以讨论几乎任何问题，但有些人对这些新闻组的公共性质有顾虑。你总是可以用另外的方法：直接发电子邮件给古鲁。不管怎样，要使用有意义的主题（“需要帮助！！！”无益于事）。
- 坐回椅子上，耐心等候。人们很忙，也许需要几天才能得到明确的答案。
　　最后，请一定要感谢任何回应你的人。如果你看到有人提出你能够解答的问题，尽你的一份力，参与解答。
6 交流！
我相信，被打量比被忽略要好。
- 知道你想要说什么。
- 了解你的听众。
- 选择时机。
- 选择风格。
- 让文档美观。
- 让听众参与。
- 做倾听者。
- 回复他人。
    7 重复的危害
　　系统中的每一项知识都必须具有单一、无歧义、权威的表示。
不要重复你自己
 
- 强加的重复（imposed duplication）。开发者觉得他们无可选择——环境似乎要求重复。使用简单的代码生成器
- 无意的重复（inadvertent duplication）。开发者没有意识到他们在重复信息。规范化。
- 无耐性的重复（impatient duplication）。开发者偷懒，他们重复，因为那样似乎更容易。
- 开发者之间的重复（interdeveloper duplication）。同一团队（或不同团队）的几个人重复了同样的信息。

让复用变得容易
8 正交性
　　在计算技术中，该术语用于表示某种不相依赖性或是解耦性。如果两个或更多事物中的一个发生变化，不会影响其他事物，这些事物就是正交的。在设计良好的系统中，数据库代码与用户界面是正交的：你可以改动界面，而不影响数据库；更换数据库，而不用改动界面。
　　如直升机的例子所阐明的，非正交系统的改变与控制更复杂是其固有的性质。当任何系统的各组件互相高度依赖时，就不再有局部修正（local fix）这样的事情。
消除无关事物之间的影响
　　我们想要设计自足（self-contained）的组件：独立，具有单一、良好定义的目的（Yourdon和Constantine称之为内聚（cohesion）[YC86]）。如果组件是相互隔离的，你就知道你能够改变其中之一，而不用担心其余组件。只要你不改变组件的外部接口，你就可以放心：你不会造成波及整个系统的问题。
　　如果你编写正交的系统，你得到两个主要好处：提高生产率与降低风险。
提高生产率
- 改动得以局部化，所以开发时间和测试时间得以降低。与编写单个的大块代码相比，编写多个相对较小的、自足的组件更为容易。你可以设计、编写简单的组件，对其进行单元测试，然后把它们忘掉——当你增加新代码时，无须不断改动已有的代码。
- 正交的途径还能够促进复用。如果组件具有明确而具体的、良好定义的责任，就可以用其最初的实现者未曾想象过的方式，把它们与新组件组合在一起。
- 如果你对正交的组件进行组合，生产率会有相当微妙的提高。假定某个组件做M件事情，而另一个组件做N件事情。如果它们是正交的，而你把它们组合在一起，结果就能做M x N件事情。但是，如果这两个组件是非正交的，它们就会重叠，结果能做的事情就更少。通过组合正交的组件，你的每一份努力都能得到更多的功能。
降低风险
　　正交的途径能降低任何开发中固有的风险。
 
- 有问题的代码区域被隔离开来。如果某个模块有毛病，它不大可能把病症扩散到系统的其余部分。要把它切掉，换成健康的新模块也更容易。
- 所得系统更健壮。对特定区域做出小的改动与修正，你所导致的任何问题都将局限在该区域中。
- 正交系统很可能能得到更好的测试，因为设计测试、并针对其组件运行测试更容易。
- 你不会与特定的供应商、产品、或是平台紧绑在一起，因为与这些第三方组件的接口将被隔离在全部开发的较小部分中。
让我们看一看在工作中应用正交原则的几种方式。
 
　　怎样把团队划分为责任得到了良好定义的小组，并使重叠降至最低呢？没有简单的答案。这部分地取决于项目本身，以及你对可能变动的区域的分析。这还取决于你可以得到的人员。我们的偏好是从使基础设施与应用分离开始。每个主要的基础设施组件（数据库、通信接口、中间件层，等等）有自己的子团队。如果应用功能的划分显而易见，那就照此划分。然后我们考察我们现有的（或计划有的）人员，并对分组进行相应的调整。
 
设计
　　大多数开发者都熟知需要设计正交的系统，尽管他们可能会使用像模块化、基于组件、或是分层这样的术语描述该过程。系统应该由一组相互协作的模块组成，每个模块都实现不依赖于其他模块的功能。有时，这些组件被组织为多个层次，每层提供一级抽象。这种分层的途径是设计正交系统的强大方式。因为每层都只使用在其下面的层次提供的抽象，在改动底层实现、而又不影响其他代码方面，你拥有极大的灵活性。分层也降低了模块间依赖关系失控的风险。你将常常看到像下一页的图2.1这样的图表示的层次关系。
　　对于正交设计，有一种简单的测试方法。一旦设计好组件，问问你自己：如果我显著地改变某个特定功能背后的需求，有多少模块会受影响？在正交系统中，答案应
　　在你引入第三方工具箱和库时，要注意保持系统的正交性。要明智地选择技术。

编码：让你的代码保持解耦。避免使用全局数据。避免编写相似的函数。养成不断地批判对待自己的代码的习惯。测试。
9 可撤消性

　　我们让本书的许多话题相互配合，以制作灵活、有适应能力的软件。通过遵循它们的建议——特别是DRY原则（26页）、解耦（138页）以及元数据的使用（144页）——我们不必做出许多关键的、不可逆转的决策。这是一件好事情，因为我们并非总能在一开始就做出最好的决策。我们采用了某种技术，却发现我们雇不到足够的具有必需技能的人。我们刚刚选定某个第三方供应商，他们就被竞争者收购了。与我们开发软件的速度相比，需求、用户以及硬件变得更快。
　　假定在项目初期，你决定使用供应商A提供的关系数据库。过了很久，在性能测试过程中，你发现数据库简直太慢了，而供应商B提供的对象数据库更快。对于大多数传统项目，你不会有什么运气。大多数时候，对第三方产品的调用都缠绕在代码各处。但如果你真的已经把数据库的概念抽象出来——抽象到数据库只是把持久（persistence）作为服务提供出来的程度——你就会拥有“中流换马（change horses in midstream）”的灵活性。
　　与此类似，假定项目最初采用的是客户－服务器模型，但随即，在开发的后期，市场部门认为服务器对于某些客户过于昂贵，他们想要单机版。对你来说，那会有多困难？因为这只是一个部署问题，所以不应该要很多天。如果所需时间更长，那么你就没有考虑过可撤消性。另外一个方向甚至更有趣。如果需要以客户－服务器或n层方式部署你正在开发的单机产品，事情又会怎样？那也不应该很困难。
　　错误在于假定决策是浇铸在石头上的——同时还在于没有为可能出现的意外事件做准备。

不存在最终决策
　　通常，你可以把第三方产品隐藏在定义良好的抽象接口后面。事实上，在我们做过的任何项目中，我们都总能够这么做。但假定你无法那么彻底地隔离它，如果你必须大量地把某些语句分散在整个代码中，该怎么办？把该需求放入元数据，并且使用某种自动机制——比如Aspect（参见39页）或Perl——把必需的语句插入代码自身中。无论你使用的是何种机制，让它可撤消。如果某样东西是自动添加的，它也可以被自动去掉。
　　没有人知道未来会怎样，尤其是我们！所以要让你的代码学会“摇滚”：可以“摇”就“摇”，必须“滚”就“滚”。

10 曳光弹

　　曳光弹行之有效，是因为它们与真正的子弹在相同的环境、相同的约束下工作。它们快速飞向目标，所以枪手可以得到即时的反馈。同时，从实践的角度看，这样的解决方案也更便宜。
　　为了在代码中获得同样的效果，我们要找到某种东西，让我们能快速、直观和可重复地从需求出发，满足最终系统的某个方面要求。
用曳光弹找到目标
 
　　曳光开发与项目永不会结束的理念是一致的：总有改动需要完成，总有功能需要增加。这是一个渐进的过程。
- 用户能够及早看到能工作的东西。如果你成功地就你在做的事情与用户进行了交流（参见“极大的期望”，255页），用户就会知道他们看到的是还未完成的东西。他们不会因为缺少功能而失望；他们将因为看到了系统的某种可见的进展而欣喜陶醉。他们还会随着项目的进展做出贡献，增加他们的“买入”。同样是这些用户，他们很可能也会告诉你，每一轮“射击”距离目标有多接近。
- 开发者构建了一个他们能在其中工作的结构。最令人畏缩的纸是什么也没有写的白纸。如果你已经找出应用的所有端到端的交互，并把它们体现在代码里，你的团队就无须再无中生有。这让每个人都变得更有生产力，同时又促进了一致性。
- 你有了一个集成平台。随着系统端到端地连接起来，你拥有了一个环境，一旦新的代码段通过了单元测试，你就可以将其加入该环境中。你将每天进行集成（常常是一天进行多次），而不是尝试进行大爆炸式的集成。每一个新改动的影响都更为显而易见，而交互也更为有限，于是调试和测试将变得更快、更准确。
 
- 你有了可用于演示的东西。项目出资人与高级官员往往会在最不方便的时候来看演示。有了曳光代码，你总有东西可以拿给他们看。
- 你将更能够感觉到工作进展。在曳光代码开发中，开发者一个一个地处理用例（use case）。做完一个，再做下一个。评测性能、并向用户演示你的进展，变得容易了许多。因为每一项个别的开发都更小，你也避免了创建这样的整体式代码块：一周又一周，其完成度一直是95%。
　　其间的区别很重要，足以让我们再重复一次。原型制作生成用过就扔的代码。曳光代码虽然简约，但却是完整的，并且构成了最终系统的骨架的一部分。你可以把原型制作视为在第一发曳光弹发射之前进行的侦察和情报搜集工作。
11 原型与便笺
　　原型的设计目的就是回答一些问题，所以与投入使用的产品应用相比，它们的开发要便宜得多、快捷得多。其代码可以忽略不重要的细节——在此刻对你不重要，但对后来的用户可能非常重要。例如，如果你在制作GUI原型，你不会因不正确的结果或数据而遭到指责。而另一方面，如果你只是在研究计算或性能方面的问题，你也不会因为相当糟糕的GUI而遭到指责；甚至也可以完全不要GUI。
　　但如果你发现自己处在不能放弃细节的环境中，就需要问自己，是否真的在构建原型。或许曳光弹开发方式更适合这种情况（参见“曳光弹”，48页）。
- 架构
- 已有系统中的新功能
- 外部数据的结构或内容
- 第三方工具或组件
- 性能问题
- 用户界面设计
为了学习而制作原型
 
怎样使用原型
　　在构建原型时，你可以忽略哪些细节？
- 正确性。你也许可以在适当的地方使用虚设的数据。
- 完整性。原型也许只能在非常有限的意义上工作，也许只有一项预先选择的输入数据和一个菜单项。
- 健壮性。错误检查很可能不完整，或是完全没有。如果你偏离预定路径，原型就可能崩溃，并在“烟火般的灿烂显示中焚毁”。这没有关系。
- 风格。在纸上承认这一点让人痛苦，但原型代码可能没有多少注释或文档。根据使用原型的经验，你也许会撰写出大量文档，但关于原型系统自身的内容相对而言却非常少。
12 领域语言
　　计算机语言会影响你思考问题的方式，以及你看待交流的方式。每种语言都含有一系列特性——比如静态类型与动态类型、早期绑定与迟后绑定、继承模型（单、多或无）这样的时髦话语——所有这些特性都在提示或遮蔽特定的解决方案。头脑里想着Lisp设计的解决方案将会产生与基于C风格的思考方式而设计的解决方案不同的结果，反之亦然。与此相反——我们认为这更重要——问题领域的语言也可能会提示出编程方案。

　　该语言无须是可执行的。一开始，它可以只是用于捕捉用户需求的一种方式——一种规范。但是，你可能想要更进一步，实际实现该语言。你的规范变成了可执行代码。
靠近问题领域编程
 
　　无论是用于配置和控制应用程序的简单语言，还是用于指定规则或过程的更为复杂的语言，我们认为，你都应该考虑让你的项目更靠近问题领域。通过在更高的抽象层面上编码，你获得了专心解决领域问题的自由，并且可以忽略琐碎的实现细节。
　　记住，应用有许多用户。有最终用户，他们了解商业规则和所需输出；也有次级用户：操作人员、配置与测试管理人员、支持与维护程序员，还有将来的开发者。他们都有各自的问题领域，而你可以为他们所有人生成小型环境和语言。
　　但使用小型语言，你却能够使用该领域的语汇发出错误消息：
　　在最简单的情况下，小型语言可以采用面向行的、易于解析的格式。在实践中，与其他任何格式相比，我们很可能会更多地使用这样的格式。只要使用switch语句、或是使用像Perl这样的脚本语言中的正则表达式，就能够对其进行解析。281页上练习5的解答给出了一种用C编写的简单实现。
　　你还可以用更为正式的语法，实现更为复杂的语言。这里的诀窍是首先使用像BNF这样的表示法定义语法。一旦规定了文法，要将其转换为解析器生成器（parser generator）的输入语法通常就非常简单了。C和C++程序员多年来一直在使用yacc（或其可自由获取的实现，bison[URL 27]）。在Lex and Yacc[LMB92]一书中详细地讲述了这些程序。Java程序员可以选用javaCC，可在[URL 26]处获取该程序。282页上练习7的解答给出了一个用bison编写的解析器。如其所示，一旦你了解了语法，编写简单的小型语言实在没有多少工作要做。
　　要实现小型语言还有另一种途径：扩展已有的语言。例如，你可以把应用级功能与Python[URL 9]集成在一起，编写像这样的代码：
　　数据语言产生某种形式的数据结构给应用使用。这些语言常用于表示配置信息。
　　命令语言更进了一步。在这种情况下，语言被实际执行，所以可以包含语句、控制结构、以及类似的东西（比如58页上的脚本）。
　　你也可以使用自己的命令语言来使程序易于维护。例如，也许用户要求你把来自某个遗留应用的信息集成进你的新GUI开发中。要完成这一任务，常用的方法是“刮屏”（screen scraping）：你的应用连接到主机应用，就好像它是正常的使用人员；发出键击，并“阅读”取回的响应。你可以使用一种小型语言来把这样的交互编写成脚本：
　　把高级命令语言直接嵌入你的应用是一种常见做法，这样，它们就会在你的代码运行时执行。这显然是一种强大的能力；通过改变应用读取的脚本，你可以改变应用的行为，却完全不用编译。这可以显著地简化动态的应用领域中的维护工作。
　　
　　考虑到大多数应用都会超过预期的使用期限，你可能最好咬紧牙关，先就采用更复杂、可读性更好的语言。最初的努力将在降低支持与维护费用方面得到许多倍的回报。
13 估算
估算，以避免发生意外
 
　　所有的估算都以问题的模型为基础。但在我们过深地卷入建模技术之前，我们必须先提及一个基本的估算诀窍，它总能给出好的答案：去问已经做过这件事情的人。在你一头钻进建模之前，仔细在周围找找也曾处在类似情况下的人。
　　看看他们的问题是怎么解决的。你不大可能找到完全相符的案例，但你会惊奇有多少次，你能够成功地借鉴他人的经验。
理解提问内容
建立系统的模型
把模型分解为组件
给每个参数指定值
计算答案
追踪你的估算能力

14 纯文本的威力 
- 保证不过时
- 杠杆作用
- 更易于测试

15 shell游戏
　　对于操纵文本文件的程序员，工作台就是命令shell。在shell提示下，你可以调用你的全套工具，并使用管道、以这些工具原来的开发者从未想过的方式把它们组合在一起。在shell下，你可以启动应用、调试器、浏览器、编辑器以及各种实用程序。你可以搜索文件、查询系统状态、过滤输出。通过对shell进行编程，你可以构建复杂的宏命令，用来完成你经常进行的各种活动。
16 强力编辑
用好一种编辑器
 
17 源码控制
总是使用源码控制
 
18 调试
要修正问题，而不是发出指责
 
不要恐慌
 
　　在开始查看bug之前，要确保你是在能够成功编译的代码上工作——没有警告。我们例行公事地把编译器警告级设得尽可能高。把时间浪费在设法找出编译器能够为你找出的问题上没有意义！我们需要专注于手上更困难的问题。
　　在设法解决任何问题时，你需要搜集所有的相关数据。糟糕的是，bug报告不是精密科学。你很容易被巧合误导，而你不能承受把时间浪费在对巧合进行调试上。你首先需要在观察中做到准确。
　　一旦你认为你知道了在发生什么，就到了找出程序认为在发生什么的时候了。
　　开始修正bug的最佳途径是让其可再现。毕竟，如果你不能再现它，你又怎么知道它已经被修正了呢？
　　但我们想要的不是能够通过长长的步骤再现的bug；我们要的是能够通过一条命令再现的bug。如果你必须通过15个步骤才能到达bug显露的地方，修正bug就会困难得多。有时候，强迫你自己隔离显示出bug的环境，你甚至会洞见到它的修正方法。
使你的数据可视化

跟踪
　　调试器通常会聚焦于程序现在的状态。有时你需要更多的东西——你需要观察程序或数据结构随时间变化的状态。查看栈踪迹（stack trace）只能告诉你，你是怎样直接到达这里的。它无法告诉你，在此调用链之前你在做什么，特别是在基于事件的系统中。
　　跟踪语句把小诊断消息打印到屏幕上或文件中，说明像“到了这里”和“x的值 = 2”这样的事情。与IDE风格的调试器相比，这是一种原始/的技术，但在诊断调试器无法诊断的一些错误种类时却特别有效。在时间本身是一项因素的任何系统中，跟踪都具有难以估量的价值：并发进程、实时系统、还有基于事件的应用。
　　你可以使用跟踪语句“钻入”代码。也就是，你可以在沿着调用树下降时增加跟踪语句。
　　跟踪消息应该采用规范、一致的格式：你可能会想自动解析它们。例如，如果你需要跟踪资源泄漏（比如未配平（unbalanced）的open/close），你可以把每一次open和每一次close 记录在日志文件中。通过用Perl处理该日志文件，你可以轻松地确定
坏变量？检查它们的邻居
　　这听起来很简单，但在向他人解释问题时，你必须明确地陈述那些你在自己检查代码时想当然的事情。因为必须详细描述这些假定中的一部分，你可能会突然获得对问题的新洞见。
　　记住，如果你看到马蹄印，要想到马，而不是斑马。OS很可能没有问题。数据库也很可能情况良好。
　　如果你“只改动了一样东西”，系统就停止了工作，那样东西很可能就需要对此负责——直接地或间接地，不管那看起来有多牵强。有时被改动的东西在你的控制之外：OS的新版本、编译器、数据库或是其他第三方软件都可能会毁坏先前的正确代码。可能会出现新的bug。你先前已绕开的bug得到了修正，却破坏了用于绕开它的代码。API变了，功能变了；简而言之，这是全新的球赛，你必须在这些新的条件下重新测试系统。所以在考虑升级时要紧盯着进度表；你可能会想等到下一次发布之后再升级。
　　但是，如果没有显而易见的地方让你着手查看，你总是可以依靠好用的老式二分查找。看症状是否出现在代码中的两个远端之一，然后看中间。如果问题出现了，则臭虫位于起点与中点之间；否则，它就在中点与终点之间。以这种方式，你可以让范围越来越小，直到最终确定问题所在。
　　当然可能。某样东西出错时，你感到吃惊的程度与你对正在运行的代码的信任及信心成正比。这就是为什么，在面对“让人吃惊”的故障时，你必须意识到你的一个或更多的假设是错的。不要因为你“知道”它能工作而轻易放过与bug有牵连的例程或代码。证明它。用这些数据、这些边界条件、在这个语境中证明它。
不要假定，要证明
 
　　当你遇到让人吃惊的bug时，除了只是修正它而外，你还需要确定先前为什么没有找出这个故障。考虑你是否需要改进单元测试或其他测试，以让它们有能力找出这个故障。
　　还有，如果bug是一些坏数据的结果，这些数据在造成爆发之前传播通过了若干层面，看一看在这些例程中进行更好的参数检查是否能更早地隔离它（分别参见120页与122页的关于早崩溃及断言的讨论）。
　　在你对其进行处理的同时，代码中是否有任何其他地方容易受这同一个bug的影响？现在就是找出并修正它们的时机。确保无论发生什么，你都知道它是否会再次发生。
　　如果修正这个bug需要很长时间，问问你自己为什么。你是否可以做点什么，让下一次修正这个bug变得更容易？也许你可以内建更好的测试挂钩，或是编写日志文件分析器。
19 文本操纵
学习一种文本操纵语言
20 代码生成器
　　当木匠面临一再地重复制作同一样东西的任务时，他们会取巧。他们给自己建造夹具或模板。一旦他们做好了夹具，他们就可以反复制作某样工件。夹具带走了复杂性，降低了出错的机会，从而让工匠能够自由地专注于质量问题。
编写能编写代码的代码
 
　　代码生成器有两种主要类型：
1.      被动代码生成器只运行一次来生成结果。然后结果就变成了独立的——它与代码生成器分离了。在198页的邪恶的向导中讨论的向导，还有某些CASE工具，都是被动代码生成器的例子。
2.      主动代码生成器在每次需要其结果时被使用。结果是用过就扔的——它总是能由代码生成器重新生成。主动代码生成器为了生成其结果，常常要读取某种形式的脚本或控制文件。
被动代码生成器
　　被动代码生成器减少敲键次数。它们本质上是参数化模板，根据一组输入生成给定的输出形式。结果一经产生，就变成了项目中有充分资格的源文件；它将像任何其他文件一样被编辑、编译、置于源码控制之下。其来源将被忘记。- 创建新的源文件。被动代码生成器可以生成模板、源码控制指示、版权说明以及项目中每个新文件的标准注释块。我们设置我们的编辑器，让它在我们每次创建新文件时做这样的工作：编辑新的Java程序，新的编辑器缓冲区将自动包含注释块、包指示以及已经填好的概要的类声明。
- 在编程语言之间进行一次性转换。我们开始撰写本书时使用的是troff系统，但我们在完成了15节以后转向了LaTeX。我们编写了一个代码生成器，读取troff源，并将其转换到LaTeX。其准确率大约是90%，余下部分我们用手工完成。这是被动代码生成器的一个有趣的特性：它们不必完全准确。你需要在你投入生成器的努力和你花在修正其输出上的精力之间进行权衡。
- 生成查找表及其他在运行时计算很昂贵的资源。许多早期的图形系统都使用预先计算的正弦和余弦值表，而不是在运行时计算三角函数。在典型情况下，这些表由被动代码生成器生成，然后拷贝到源文件中。
主动代码生成器
　　被动代码生成器只是一种便利手段，如果你想要遵循DRY原则，它们的“表亲”主动代码生成器却是必需品。通过主动代码生成器，你可以取某项知识的一种表示形式，将其转换为你的应用需要的所有形式。这不是重复，因为衍生出的形式可以用过就扔，并且是由代码生成器按需生成的（所以才会用主动这个词）。

21  按合约设计
- 前条件（precondition）。为了调用例程，必须为真的条件；例程的需求。在其前条件被违反时，例程决不应被调用。传递好数据是调用者的责任（见115页的方框）。
- 后条件（postcondition）。例程保证会做的事情，例程完成时世界的状态。例程有后条件这一事实意味着它会结束：不允许有无限循环。
- 类不变项（class invariant）。类确保从调用者的视角来看，该条件总是为真。在例程的内部处理过程中，不变项不一定会保持，但在例程退出、控制返回到调用者时，不变项必须为真（注意，类不能给出无限制的对参与不变项的任何数据成员的写访问）。
 
子类必须要能通过基类的接口使用，而使用者无须知道其区别。
　　使用DBC的最大好处也许是它迫使需求与保证的问题走到前台来。在设计时简单地列举输入域的范围是什么、边界条件是什么、例程允诺交付什么——或者，更重要的，它不允诺交付什么——是向着编写更好的软件的一次飞跃。不对这些事项作出陈述，你就回到了靠巧合编程（参见172页），那是许多项目开始、结束、失败的地方。
循环不变项
　　在复杂的循环上正确设定边界条件可能会很成问题。循环常有香蕉问题（我知道怎样拼写“banana”，但不知道何时停下来——“bananana…”）、篱笆桩错误（不知道该数桩还是该数空）、以及无处不在的“差一个”错误[URL 52]。
	不变项在循环运行之前必须为真，循环的主体必须确保它在循环执行时保持为真。这样我们就知道不变项在循环终止时也保持不变，因而我们的结果是有效的。循环不变项可被显式地编写成断言，但作为设计和文档工具，它们也很有用。
出错时要偏向消费者

22 死程序不说谎
　　所有的错误都能为你提供信息。你可以让自己相信错误不可能发生，并选择忽略它。但与此相反，注重实效的程序员告诉自己，如果有一个错误，就说明非常、非常糟糕的事情已经发生了。
 
早崩溃，不要破坏（trash）

　　显然，有时简单地退出运行中的程序并不合适。你申请的资源可能没有释放，或者你可能要写出日志消息，清理打开的事务，或与其他进程交互。我们在“何时使用异常”（125页）中讨论的技术在此能对你有帮助。但是，基本的原则是一样的——当你的代码发现，某件被认为不可能发生的事情已经发生时，你的程序就不再有存活能力。从此时开始，它所做的任何事情都会变得可疑，所以要尽快终止它。死程序带来的危害通常比有疾患的程序要小得多。

23 断言式编程
如果它不可能发生，用断言确保它不会发生
 
　　当然，传给断言的条件不应该有副作用（参见124页的方框）。还要记住断言可能会在编译时被关闭——决不要把必须执行的代码放在assert中。
让断言开着
　　这个问题是一种“海森堡虫子”（Heisenbug）——调试改变了被调试系统的行为（参见[URL 52]）。
 
    也许是你的应用的关键部分，也许需要很快才行。增加检查意味着又一次通过数据，这可能让人不能接受。让那个检查成为可选的，但让其余的留下来。

20. 为Java开发一个简单的断言检查类。　　（解答在291页）
24 何时使用异常
将异常用于异常的问题
 
错误处理器是另一种选择
25怎样配平资源
　　只要在编程，我们都要管理资源：内存、事务、线程、文件、定时器——所有数量有限的事物。大多数时候，资源使用遵循一种可预测的模式：你分配资源、使用它，然后解除其分配。
要有始有终
 

嵌套的分配
　　对于一次需要不只一个资源的例程，可以对资源分配的基本模式进行扩展。有两个另外的建议：
1.      以与资源分配的次序相反的次序解除资源的分配。这样，如果一个资源含有对另一个资源的引用，你就不会造成资源被遗弃。
2.      在代码的不同地方分配同一组资源时，总是以相同的次序分配它们。这将降低发生死锁的可能性。（如果进程A申请了resource1，并正要申请resource2，而进程B申请了resource2，并试图获得resource1，这两个进程就会永远等待下去。）

　　有时基本的资源分配模式并不合适。这通常会出现在使用动态数据结构的程序中。一个例程将分配一块内存区，并把它链接进某个更大的数据结构中，这块内存可能会在那里呆上一段时间。
　　这里的诀窍是为内存分配设立一个语义不变项。你须要决定谁为某个聚集数据结构（aggregate data structure）中的数据负责。当你解除顶层结构的分配时会发生什么？你有三个主要选择：
1.      顶层结构还负责释放它包含的任何子结构。这些结构随即递归地删除它们包含的数据，等等。
2.      只是解除顶层结构的分配。它指向的（没有在别处引用的）任何结构都会被遗弃。
3.      如果顶层结构含有任何子结构，它就拒绝解除自身的分配。

26解耦
模块间关系应少，改动影响范围小，更敢于改
得墨忒耳法则：类只调用自身和域的方法
27元程序设计
把抽象放进代码，细节放进元数据
何时进行配置
28时间耦合
分析工作流以发现并发性
用服务进行设计
为并发而设计导致更整洁的接口
29它只是视图
发布订阅模型、MVC使视图与模型分开
30黑板
用黑构协调工作流
31靠巧合编程
不应依赖不记入文档行为，至少指出假定
32速率
估算并检验
33重构
出现重复、非正交、过时、性能问题
早重构常重构
先保足够测试、短小深思步骤
34易于测试的代码
单元测试、针对合约测试、经常自动运行
35邪恶的向导
不要用不理解的向导代码，至少隔离
36需求之抗
挖掘而非搜集
与用户一同工作以像用户一样思考
抽象比细节活得久
追踪需求变化
使用项目词汇表
37解开不可能解决的谜题
难点在哪、它真的必须完成吗
38等你准备好
倾听反复出现的疑虑
39规范陷阱
有时做胜于描述
40圆圈与箭头
不要做形式方法的奴隶
昂贵的工具不一定导致更好设计
41注重实效的团队
围绕功能而非工作职务组织团队
42自动化
不要用手工流程
定时夜间构建、回归测试、网站生成、批准流程
43无情的测试
单元测试、集成测试、验证和校验、资源耗尽和异常恢复、性能测试（负载）、可用性测试
通过蓄意破坏测试测试
测试状态覆盖而非代码覆盖
一个bug只抓一次，发现漏网就加入测试
44全都是写
把文档建在里面不要拴在外面
在线发布优于打印
45极大的期望
温和地超出用户的期望
快速参考、自动安装、完整性检测、崩溃恢复
46傲慢与偏见
在作品上签名

《软件测试》

软件测试是为了尽早发现缺陷（未实现功能、错误、多余功能、用户体验）并确保得以修复（除非资源不足、修复风险大、影响小）。
测试员应有探索精神、创造性、细心、有判断力、追求完美、善于说服
完全测试不太现实、不能证明正确、错误会扎堆。
说明书要完整、准确、清晰、一致、可行、可测试
白盒与黑盒、静态与动态、对照标准和竞争产品
数据测试：测试用例（典型输入、故意破坏）、划分等价类以控制用例量、边界条件（很小、很大、默认、零、空、满、首、末、近、远，刚合法和刚非法）、垃圾数据
状态测试：用例（状态覆盖、常见和罕见、随机）、竞争条件（同时使用文件、数据库和设备，打开多个实例）、压力测试（重复、负载、老旧机器）
像新手那样试、像攻击者想、注意同类缺陷
代码审查：方式（同事审查、走查、检验）、标准和风格规范（数组出界、未使用变量、宽度、大于小于、输入输出格式、可终止、死代码、差一、遗漏情况、国际化、可移植）、编译器警告和静态分析
白盒测试：单元与集成、自底向上与自顶向下、数据覆盖（数据流）、代码覆盖（行、分支、路径）

配置测试：确定硬件类型、找出可用硬件和驱动、了解硬件选项、决定支持范围、在每种配置测试
兼容性测试：程序（操作系统、浏览器、数据库、剪贴板）、版本（前向与后向，转换工具）、用例（流行、各类、各厂商）、规范
国际化：翻译（空间变化、编码、快捷键、重音、文本排序、方向、图形中的文字）、图形和声音的文化含义、数据格式（单位、数字、货币、时间、纸张、邮编、电话）
可用性：易用（规范、直观（布局简洁）、一致（快捷方式、术语、位置）、灵活（适当选择）、舒适（错误处理、性能）、正确（拼写、不误导）、实用）、辅助（字体、颜色、声音、只能同时按一个键、认知障碍）
文档测试：对象（包装、广告、注册、标签、安装、设置、手册、帮助、指南、向导、样例、模板、错误信息、截屏、图表）、准则（受众、术语、主题、正确、逐步按指示执行）
安全性测试：攻击动机（成名、好奇、借用、破坏、盗窃）、威胁分析（确认价值、体系架构、确认威胁、等级评定（可利用性、影响））、长字符串、历史记录与隐私

自动化：监视工具（内存、网络、文件）、驱动程序、桩、负载压力、干扰注入、宏录制测试UI、随机测试（各种聪明程度）
让别人测试：beta测试、外包测试
缺陷跟踪：最小可重现、系统、状态、严重性、优先级
