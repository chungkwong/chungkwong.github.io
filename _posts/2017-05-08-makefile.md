---
title:  "Makefile构建系统概览"
redirect_from: /2017/05/08/makefile.html
layout: post
tags: unix makefile 构建
ads:
    - <a rel="nofollow" target="_blank" href="https://amazon.cn/gp/product/B008Z1IEQ8/ref=as_li_tl?ie=UTF8&tag=chungkwong-23&camp=536&creative=3200&linkCode=as2&creativeASIN=B008Z1IEQ8&linkId=270aa78907737f2b7700c97ee1f3ecc2">UNIX编程艺术</a>
---

Unix下最常用的构建脚本语言要数makefile，但手写makefile往往有过于繁琐，故常用automake来自动生成支持所有标准目标的makefile，再用autoconf处理配置软件包的工作。

## GNU makefile

make是一个构建工具，与写shell脚本相比，make的强项在于可实现自动的部分重新编译，但也可用于众多与依赖有关的任务。只用在makefile文件中写出各文件间的依赖关系，make就会根据这些规则和各文件的最后修改时间自动决定重新生成哪些文件。虽然make是通用的，不过还是多用于unix世界的C/C++/perl等项目，Java项目多用ant或maven，ruby项目多用rake。

make的通常用法为：

```
make [终极目标...]
```

其中规则放在当前目录的文件GNUmakefile、makefile或Makefile中。如果不指定终极目标，默认为makefile中首个规则的首个目标（除非规则是模式规则或以点开首）。make的选项在这不多说，只提一下-j选项会导致并发执行，-l可限制负载。


### make的执行过程

1. 依次读取变量环境变量MAKEFILES定义的 makefile 文件列表（以空格分隔，通常仅用于make的递归调用过程中的通信）
2. 读取工作目录下的 makefile 文件(依次查找GNUmakefile、makefile、Makefile”,首先找到那个就读取那个)
3. 依次读取工作目录 makefile 文件中使用指示符“include”包含的文件
4. 查找重建所有已读取的 makefile 文件的规则(如果存在一个目标是当前读取的某一个 makefile 文件，则执行此规则重建此 makefile 文件，完成以后从第一步开始重新执行)
5. 初始化变量值并展开那些需要立即展开的变量和函数并根据预设条件确定执行分支
6. 根据终极目标以及其他目标的依赖关系建立依赖关系链表
7. 执行除终极目标以外的所有的目标的规则(规则中如果目标文件不存在或依赖文件中任一个文件的时间戳比目标文件新，则使用规则所定义的命令重建目标文件)
8. 执行“终极目标”所在的规则

### makefile概览

makefile中的规则形如：

```
目标:前提
	命令
	...
```

其中规则的首行中，目标是待实现的事项（通常是生成的文件名，不是的话叫伪目标）列表，前提是生成目标所需要的文件名列表（可以空）。接下来以制表符开始的若干行每行为一条shell命令，指定实现目标所需的动作，每行在不同子shell独立运行。

makefile中也可以在换行前加反斜杠来续行，分解长的行有助提高可读性。makefile中由##开始行末注释，也同样可续行。作为例子，以下是一个makefile文件

```makefile
edit : main.o kbd.o command.o display.o \
insert.o search.o files.o utils.o
	 cc -o edit main.o kbd.o command.o display.o \
	 	 insert.o search.o files.o utils.o
main.o : main.c defs.h
	cc -c main.c
kbd.o : kbd.c defs.h command.h
	cc -c kbd.c
command.o : command.c defs.h command.h
	cc -c command.c
display.o : display.c defs.h buffer.h
	cc -c display.c
insert.o : insert.c defs.h buffer.h
	cc -c insert.c
search.o : search.c defs.h buffer.h
	cc -c search.c
files.o : files.c defs.h buffer.h command.h
	cc -c files.c
utils.o : utils.c defs.h
	cc -c utils.c
clean :
	rm edit main.o kbd.o command.o display.o \
	   insert.o search.o files.o utils.o
```

显然这样的makefile很不理想，首先它有很多重复，不但编写和修改麻烦，而且会成为错误的温床。有见及此，makefile支持变量，用变量指代字符串。于是上述makefile可写为：

```makefile
OBJECTS=main.o kbd.o command.o display.o \
	insert.o search.o files.o utils.o
edit : $(OBJECTS)
	cc -o edit $(OBJECTS)
main.o : main.c defs.h
	cc -c main.c
kbd.o : kbd.c defs.h command.h
	cc -c kbd.c
command.o : command.c defs.h command.h
	cc -c command.c
display.o : display.c defs.h buffer.h
	cc -c display.c
insert.o : insert.c defs.h buffer.h
	cc -c insert.c
search.o : search.c defs.h buffer.h
	cc -c search.c
files.o : files.c defs.h buffer.h command.h
	cc -c files.c
utils.o : utils.c defs.h
	cc -c utils.c
clean :
	rm edit $(OBJECTS)
```

然后我们看到生成.o文件的规则太像了，由于它们太常用，其实makefile的隐含规则链（通常基于目标文件名的后缀）已经能处理，于是makefile又改为：

```makefile
OBJECTS=main.o kbd.o command.o display.o \
	insert.o search.o files.o utils.o
edit : $(OBJECTS)
	cc -o edit $(OBJECTS)
main.o : defs.h
kbd.o : defs.h command.h
command.o : defs.h command.h
display.o : defs.h buffer.h
insert.o : defs.h buffer.h
search.o : defs.h buffer.h
files.o : defs.h buffer.h command.h
utils.o : defs.h
clean :
	rm edit $(OBJECTS)
```

其实还可以更简短：

```makefile
OBJECTS=main.o kbd.o command.o display.o \
	insert.o search.o files.o utils.o
edit : $(OBJECTS)
	cc -o edit $(OBJECTS)
main.o : defs.h
$(objects) : defs.h
kbd.o command.o files.o : command.h
display.o insert.o search.o files.o : buffer.h
clean :
	rm edit $(OBJECTS)
```

makefile中可以用`include 文件名...`或`-include 文件名...`导入其它makefile文件，区别在于前者在文件不存在时报错中止。常见的做法是每个目录一个makefile。

### 其它细节

#### 规则的变形

##### 模式规则

若目标中有一个`%`，则它可匹配任何非空字符串，在依赖中也可用`%`引用捕获部分。

有明确规则可用时不用模式规则。当多个模式都匹配时，首个规则被应用。有模式规则可用时不用隐含规则。

由于兼容原因，makefile支持后缀规则，如`.o.c`和`.c`分别相当于`%.o:%.c`和`%:%.c`，其中假设涉及后缀`.c`和`.o`都在特殊目标.SUFFIXES的依赖中。

另外，静态模式可用于一类前提略有不同的目标：

```
目标...:目标模式:相应前提...
	命令
	...
```

##### 双冒号规则

双冒号规则就是使用`::`代替普通规则的`:`得到的规则。一个目标可以出现在多个规则中时，这些规则必须是同一类型的规则，要么都是普通规则，要么都是双冒号规则。双冒号规则和普通规则的处理的不同点表现在以下几个方面:

1. 双冒号规则中，当依赖文件比目标更新时。规则将会被执行。对于一个没有依赖而只有命令行的双冒号规则，当引用此目标时，规则的命令将会被无条件执行。而对普通规则，当规则的目标文件存在时，此规则的命令永远不会被执行。

2. 当同一个文件作为多个双冒号规则的目标时。这些不同的规则会被独立的处理，而不是像普通规则那样合并所有的依赖到一个目标文件。这就意味着对这些规则的处理就像多个不同的普通规则一样。就是说多个双冒号规则中的每一个的依赖文件被改变之后，make 只执行此规则定义的命令,而其它的以这个文件作为目标的双冒号规则将不会被执行。

GNU make 的双冒号规则给我们提供一种根据依赖的更新情况而执行不同的命令来重建同一目标的机制。一般这种需要的情况很少，所以双冒号规则的使用比较罕见。

##### 伪目标

|伪目标|用途|
|---|---|
|.DEFAULT|匹配所有没有其它规则可用的文件。|
|.DELETE_ON_ERROR|如果规则的命令执行错误，将删除已经被修改的目标文件。|
|.EXPORT_ALL_VARIABLES|将之后所有的变量传递给子make进程。|
|.IGNORE|如果指定依赖文件，则忽略创建这个文件所执行命令的错误。否则，将忽略所有命令执行的错误。|
|.INTERMEDIATE|指定依赖为中间文件，用完删掉。|
|.LOW_RESOLUTION_TIME|指定依赖是低分辨率时间戳文件。|
|.NOTPARALLEL|所有命令按照串行方式执行。|
|.PHONY|指定依赖为伪目标。|
|.PRECIOUS|指定依赖在中断时保留。|
|.SECONDARY|指定依赖为中间文件，用完不删掉。|
|.SILENT|不打印生成依赖（不指定则所有）的命令。|
|.SUFFIXES|指定依赖为后缀。|

##### 规则变量

|变量|内容|
|---|---|
|$@|触发规则被执行的目标文件名|
|$%|当规则的目标文件是一个静态库文件时为静态库的一个成员名否则其值为空。|
|$<|规则的第一个依赖文件名|
|$?|所有比目标文件更新的依赖文件列表，空格分隔。如果目标是静态库文件名，代表的是库成员(.o文件)。|
|$^|规则的所有依赖文件列表,使用空格分隔。如果目标是静态库文件，它所代表的只能是所有库成员(.o文件)名。去掉重复。|
|$+|规则的所有依赖文件列表,使用空格分隔。如果目标是静态库文件，它所代表的只能是所有库成员(.o文件)名。不去掉重复。|
|$*|是目标模式中%所代表的部分(当文件名中存在目录时，也包含目录部分|

##### 命令前缀

|命令前缀|用途|
|---|---|
|`@`|不回显这个命令|
|`-`|出错也继续|

#### 条件执行

和C语言的文本包含一样，make的条件执行也基于文本。其语法为：

```
条件
条件为真时保留的文本
endif
```

或

```
条件
条件为真时保留的文本
else
条件为假时保留的文本
endif
```

其中条件形如以下之一：

```
ifeq (ARG1, ARG2)
ifeq 'ARG1' 'ARG2'
ifeq "ARG1" "ARG2"
ifeq "ARG1" 'ARG2'
ifeq 'ARG1' "ARG2"
ifneq (ARG1, ARG2)
ifneq 'ARG1' 'ARG2'
ifneq "ARG1" "ARG2"
ifneq "ARG1" 'ARG2'
ifneq 'ARG1' "ARG2"
ifdef VARIABLE-NAME
ifndef VARIABLE-NAME
```

#### 变量

makefile的变量类似C语言的宏，在读取期就展开，展开后内容可被继续展开至不再有变量引用。变量名是不包括`:`、`##`、`=`、前置空白和尾空白的任何字符串，大小写敏感的。变量的值可用`$(变量名)`或者`${变量名}`引用，单字符变量名可省略括号。make可以引用环境变量。引用一个没有定义的变量时，make 默认它的值为空。

用`=`定义的变量是延迟求值变量，变量的值就是等号后的值。用`:=`定义的变量是立即求值变量，变量的值是对等号后的值展开的结果。这意味着如果变量A定义用到其它变量B，则在前一情况下$A展开为与当前$B值有关的值，在后一情况下$A展开为与定义A时$B值有关的值。立即求值变量因为结果符合记法作用域，不易死循环，容易理解，但较不灵活。延迟求值变量的另外一种定义方法为：

```
define 变量名
变量值
endef
```

另外，可用`?=`给出变量的条件赋值，只有变量不存在时才会进行赋值（延迟求值）。还可用`+=`把值追加到时变量的值后面，变量性质不变（原来不存在则视为延迟求值变量）。

可以定义目标特定变量，这种变量的作用域是个别目标的上下文，包括和这些目标引发的所有执行过程。目标特定变量和同名的全局变量属于两个不同的变量，它们性质可以不同。定义语法如：

```
目标 ... : 变量赋值
```

类似地有模式特定变量。

如果在命令行指定了变量值，则在变量赋值前需要加上`override `方能修改变量的值。

变量默认只在当前make有效，如果要传给子make，要用指示`export 变量名 ...`，而`unexport 变量名 ...`则可取消其作用。

##### 内置变量

|变量|内容|
|---|---|
|MAKEFILE_LIST|已读取的makefile文件|
|VPATH|依赖文件的搜索路径（由空格或冒号分隔）|

#### 函数

函数调用形如`$(函数名 以逗号分隔的参数列表)`或者`${函数名 以逗号分隔的参数列表}`，其中参数会被依次展开。

|文本处理函数|用途|返回值|
|---|---|---|
|$(subst FROM,TO,TEXT)|把字符串TEXT中的FROM替换为TO|替换后的新字符串。|
|$(patsubst PATTERN,REPLACEMENT,TEXT)|搜索TEXT中以空格分开的单词，将否符合模式TATTERN的替换为REPLACEMENT。参数PATTERN和REPLACEMENT中可以使用模式通配符%。`$(VAR:PATTERN=REPLACEMENT)`相当于`$(patsubst PATTERN,REPLACEMENT,$(VAR))`，而`$(VAR:SUFFIX=REPLACEMENT)`相当于`$(patsubst %SUFFIX,%REPLACEMENT,$(VAR))`。|替换后的新字符串。|
|$(strip STRINT)|去多余空格|无前导和结尾空字符、使用单一空格分割的多单词字符串。|
|$(findstring FIND,IN)|搜索IN，查找FIND。|如果在IN之中存在FIND，则返回“FIND”，否则返回空。|
|$(filter PATTERN...,TEXT)|过滤掉字符串TEXT中所有不符合模式PATTERN的单词，保留所有符合其中一个模式的单词。模式中一般需要包含模式字符%。存在多个模式时，模式表达式之间使用空格分割。|空格分割的TEXT字串中所有符合模式PATTERN的字串。|
|$(filter-out PATTERN...,TEXT)|过滤掉字串TEXT中所有符合模式PATTERN的单词，保留所有不符合所有模式的单词。存在多个模式时，模式表达式之间使用空格分割。|空格分割的TEXT字串中所有不符合模式PATTERN的字串。|
|$(sort LIST)|给字符串LIST中的单词以首字母为准进行排序(升序)，并去掉重复的单词。|空格分割的没有重复单词的字串。|
|$(word N,TEXT)|取字符串TEXT中第N个单词(N的值从 1 开始)。|返回TEXT中第N个单词，没有则返回空字符串。N为0则出错|
|$(wordlist S,E,TEXT)|从字符串TEXT中取出从位置S开始到位置E（含）的单词串。|单词串。|
|$(words TEXT)|算字符串“TEXT”中单词的数目。|TEXT中的单词数。|
|$(firstword NAMES...)|取NAMES...中的第一个单词。|第一个单词。|


|文件名处理函数|用途|返回值|
|---|---|---|
|$(dir NAMES...)|从文件名序列NAMES...中取出各个文件名的目录部分。文件名的目录部分就是包含在文件名中的最后一个斜线(包括斜线)之前的|空格分割的目录部分。|
|$(notdir NAMES...)|从文件名序列NAMES...中取出非目录部分。|文件名序列NAMES...中每一个文件的非目录部分。|
|$(suffix NAMES...)|从文件名序列NAMES...中取出各个文件名的后缀。后缀是文件名中最后一个以点.开始的(包含点号)部分，如果文件名中不包含一个点号则为空。|以空格分割的后缀序列。|
|$(basename NAMES...)|从文件名序列NAMES...中取出各个文件名的前缀部分。前缀部分指的是文件名中最后一个点号之前的部分。|空格分割的前缀序列。如果文件没有前缀，则返回空字串。|
|$(addsuffix SUFFIX,NAMES...)|为NAMES...中的每一个文件名添加后缀SUFFIX。|以单空格分割的添加了后缀的文件名序列。|
|$(addprefix PREFIX,NAMES...)|为NAMES...中的每一个文件名添加前缀PREFIX。|以单空格分割的添加了前缀的文件名序列。|
|$(join LIST1,LIST2)|将字串“LIST1”和字串“LIST2”各单词进行对应连接。|单空格分割的合并后的字(文件名)序列。|
|$(wildcard PATTERN)|列出当前目录下所有符合模式PATTERN格式的文件名。|空格分割的文件名列表。|

以下的函数更像是宏：

|其它函数|用途|返回值|
|---|---|---|
|$(foreach VAR,LIST,TEXT)|不展开先不展开TEXT，把LIST中使用空格分割的单词依次取出赋值给变量VAR，然后展开TEXT表达式。|空格分隔的多次表达式TEXT的展开结果。|
|$(if CONDITION,THEN-PART[,ELSE-PART])|如果CONDITION的展开结果非空，就将第二个参数THEN_PATR作为函数的计算
表达式，否则第三个参数ELSE-PART作为函数的表达式。|相应展开结果，没有则为空。|
|$(call VARIABLE,PARAM,PARAM,...)|PARAM依次赋值给临时变量$(1)、$(2)...... ，之后对变量展开VARIABLE表达式。|VARIABLE定义的表达式的展开结果。|
|$(value VARIABLE)|不对变量VARIBLE进行任何展开操作，直接返回变量VARIBALE的值。|变量VARIBALE所定义文本值|
|$(eval TEXT)|对它的参数进行展开，展开的结果作为Makefile的一部分。|空|
|$(origin VARIABLE)|查询VARIABLE(一个变量名)的出处。|undefined、default、environment、environment override、file、command line、override、automatic之一|
|$(shell COMMAND)|调用shell命令|函数参数在 shell 环境中的执行结果。|
|$(error TEXT...)|产生致命错误,并提示TEXT...信息给用户,并退出 make 的执行。|空|
|$(warning TEXT...)|提示TEXT...，然后make 的执行过程继续。|空|

#### 文件名

makefile中文件名（但在变量定义中不会有特殊处理）接受通配符（*、?和[]，与shell类似）。

至于文件的搜索路径可以如下指定：

|行|用途|
|---|---|
|vpath PATTERN DIRECTORIES|为所有符合模式PATTERN的文件指定搜索目录DIRECTORIES（用空格或者冒号分隔）|
|vpath PATTERN|清除之前为符合模式PATTERN的文件设置的搜索路径。|
|vpath|清除所有已被设置的文件搜索路径。|

### make的使用

按惯例，makefile的一些伪目标用于特定用途：

|伪目标|用途|
|---|---|
|all|作为 Makefile 的顶层目标，一般此目标作为默认的终极目标。|
|clean|删除所有由 make 创建的文件。|
|mostlyclean|和“clean”伪目标功能相似。区别在于它所定义的删除命令不会全部删除由 make生成的文件。比如说不需要删除某些库文件。|
|distclean|类似于伪目标clean，但删除的文件更多。可以包含非 make 创建的文件。例如编译之前系统的配置文件、链接文件等。|
|realclean|类似于伪目标clean，但删除的文件更多。可以包含非 make 创建的文件。例如编译之前系统的配置文件、链接文件等。|
|clobber|类似于伪目标clean，但删除的文件更多。可以包含非 make 创建的文件。例如编译之前系统的配置文件、链接文件等。|
|install|将 make 成功创建的可执行文件拷贝到 shell 环境变量“PATH”指定的某个目录，也可安装数据、库和文档。|
|print|打印出所有被更改的源文件列表。|
|tar|创建一个 tar 文件(归档文件包)。|
|shar|创建一个源代码的 shell 文档(shar 文件)。|
|dist|为源文件创建发布的压缩包。|
|TAGS|创建当前目录下所有源文件的符号信息文件，供 vim 使用。|
|check|对 make 最后生成的文件进行检查。|
|test|对 make 最后生成的文件进行检查。|

## GNU autotools

Makefile工具还不能算是完整的构建系统，因为不同包的makefile间有很多重复性的代码，手工写是烦人的，而且写出的代码往往是考虑不详的，在不同机器上会出现各种繁琐的问题。gcc的-M或-MM选项（后者忽略标准库的头文件）可生成头文件依赖关系的makefile，但这仍然不够：
- automake的目的是自动生成支持所有标准目标的makefile，支持依赖跟踪和递归构建
- autoconf的目的是消除包用户配置软件包的工作，以便让包可以在不同机器以相同方式使用

### 例子

这里用最简单的例子开始：

`src/main.c`是源代码：

```C
#include <config.h>
#include <stdio.h>
int main (void)
{
  puts ("Hello World!");
  puts ("This is " PACKAGE_STRING ".");
  return 0;
}
```

`README`是对包的给用户看的第一个文档：

```
This is a demonstration package for GNU Automake.
Type 'info Automake' to read the Automake manual.
```

`Makefile.am`和`src/Makefile.am`包含两个目录的automake指令，语法与makefile相同，但遇到特定的变量作特别处理而不是直接复制到对就的.in文件：

```automake
bin_PROGRAMS = hello    #结束于_PROGRAMS、_SCRIPTS、_DATA、_LIBRARIES的变量指定makefile应构建的文件
hello_SOURCES = main.c  #结束于_SOURCES的变量指定相应的一个或多个源文件
```

```automake
SUBDIRS = src           #SUBDIRS指定构建当前目录前应构建的目录
dist_doc_DATA = README  #dist_前缀指出打包时相应文件应复制到归档包
```

`configure.ac`包含autoconf指令（其实`AC_`开首的是m4宏）：

```autoconf
AC_INIT([amhello], [1.0], [bug-automake@gnu.org])  #初始化autoconf，指定包名、版本和报错的联系方式
AM_INIT_AUTOMAKE([-Wall -Werror foreign])          #初始化automake，指定打开所有automake的错误检查，且包不遵守GNU标准
AC_PROG_CC                                         #寻找C编译器以决定CC变量的值
AC_CONFIG_HEADERS([config.h])                      #生成包含此文件指定宏定义（如PACKAGE_STRING）的头文件
AC_CONFIG_FILES([                                  #指定需生成.in文件模板的.am文件
 Makefile
 src/Makefile
])
AC_OUTPUT                                          #实际生成脚本
```

现在，先为这个包初始化构建系统生成`configure`脚本和用这脚本生成makefile（以后不用重复这两步，因为make时会自动检测am或ac文件的变化）：

```
$ autoreconf --install
$ ./configure
```

现在就可以用make并验证它正常工作了：

```
$ make
$ src/hello 
Hello World!
This is amhello 1.0.

```

### 目录结构

为使用automake，在包目录放置：
- 一个autoconf文件`configure.ac`或`configure.in`
- 一个automake文件`Makefile.am`
然后对automake文件运行`automake`将生成模板`Makefile.in`。

为使用autoconf，在包目录放置：
- 一个autoconf文件`configure.ac`或`configure.in`
- 一个makefile模板`Makefile.in`
- 可选择提供m4宏文件`aclocal.m4`和`acsite.m4`，其中定义包特定的宏
然后对autoconf文件运行`autoconf`将生成跨平台的脚本`configure`。

利用`autoreconf`通过反复运行`autoconf`、`autoheader`、`aclocal`、`automake`、`libtoolize`和`autopoint`，一步到位地生成或更新包的构建系统。 

`configure`脚本通常生成如下文件：
- 一个或多个makefile，通常是每个子目录一个
- 一个可选的头文件
- 一个`config.status`shell脚本，运行它会重新生成上述文件
- 一个日志文件`config.log`

### GNU autoconf

`configure.ac`文件的典型布局如下：


```autoconf
AC_PREREQ([2.69])                                                 #Autoconf requirements
AC_INIT([FULL-PACKAGE-NAME], [VERSION], [BUG-REPORT-ADDRESS])
# Information on the package
# Checks for programs.
# Checks for libraries.
# Checks for header files.
# Checks for typedefs, structures, and compiler characteristics.
# Checks for library functions.
# Checks for system services
AC_CONFIG_FILES([Makefile,src/Makefile])
AC_OUTPUT
```

为编写`configure.ac`，可以运行`autoscan`自动检查目录树找出常见移植性问题并生成一个模板`configure.scan`，把它修改成所需后再改名。

autoconf的一个重要用途是为定义C/C++宏，`ifnames`程序用于列出一个C/C++文件中`#if`、`#elif`、`#ifdef'、`#ifndef`等等用到的标识符，这对编写`configure.ac`是有用的。

#### 宏

宏|说明
---|---
`AC_ACT_IFELSE`|AC_ACT_IFELSEvsAC_TRY_ACT.
`AC_ARG_ENABLE (FEATURE, HELP-STRING, [ACTION-IF-GIVEN],[ACTION-IF-NOT-GIVEN])`|提供一个用户开关选项`--enable-FEATURE`和`--disable-FEATURE`，在用户指定时运行`ACTION-IF-GIVEN`（可用shell变量`enableval`获取参数值，没有则yes或no），否则`ACTION-IF-NOT-GIVEN`
`AC_ARG_PROGRAM`|转换包名的sed命令序列
`AC_ARG_VAR (VARIABLE, DESCRIPTION)`|声明输出变量
`AC_ARG_WITH (PACKAGE, HELP-STRING, [ACTION-IF-GIVEN], [ACTION-IF-NOT-GIVEN])`|提供一个用户开关选项`--with-PACKAGE`和`--without-PACKAGE`，在用户指定时运行`ACTION-IF-GIVEN`（可用shell变量`withval`获取参数值，没有则yes或no），否则`ACTION-IF-NOT-GIVEN`
`AC_AUTOCONF_VERSION`|autoconf版本
`AC_BEFORE (THIS-MACRO-NAME, CALLED-MACRO-NAME)`|指定两个宏都被调用时要先调用某个
`AC_CACHE_CHECK (MESSAGE, CACHE-ID, COMMANDS-TO-SET-IT)`|确保指定缓存结果存在
`AC_CACHE_LOAD`|从缓存文件加载值，必要时创建
`AC_CACHE_SAVE`|确保缓存值写到文件
`AC_CACHE_VAL (CACHE-ID, COMMANDS-TO-SET-IT)`|确保指定缓存结果存在
`AC_CANONICAL_BUILD`|计算构建用系统变量
`AC_CANONICAL_HOST`|计算运行用系统变量
`AC_CANONICAL_TARGET`|计算目标系统变量
`AC_CHECK_ALIGNOF (TYPE, [INCLUDES = 'AC_INCLUDES_DEFAULT'])`|定义`ALIGNOF_TYPE`为类型的对齐字节数
`AC_CHECK_DECL (SYMBOL, [ACTION-IF-FOUND], [ACTION-IF-NOT-FOUND], [INCLUDES = 'AC_INCLUDES_DEFAULT'])`|按函数、变量或常量是否已声明做不同工作
`AC_CHECK_DECLS (SYMBOLS, [ACTION-IF-FOUND], [ACTION-IF-NOT-FOUND], [INCLUDES = 'AC_INCLUDES_DEFAULT'])`|按各函数、变量或常量（用逗号分隔）是否已声明做不同工作，定义各`HAVE_DECL_SYMBOL`为1或0
`AC_CHECK_DECLS_ONCE (SYMBOLS)`|定义各`HAVE_DECL_SYMBOL`为1或0
`AC_CHECK_FILE (FILE, [ACTION-IF-FOUND], [ACTION-IF-NOT-FOUND])`|按文件是否存在做不同工作
`AC_CHECK_FILES (FILES, [ACTION-IF-FOUND], [ACTION-IF-NOT-FOUND])`|按各文件是否存在做不同工作，定义各`HAVE_FILE`为1或0
`AC_CHECK_FUNC (FUNCTION, [ACTION-IF-FOUND], [ACTION-IF-NOT-FOUND])`|按C函数是否已声明做不同工作
`AC_CHECK_FUNCS (FUNCTIONS, [ACTION-IF-FOUND], [ACTION-IF-NOT-FOUND])`|按各函数（用空白分隔）是否已声明做不同工作，定义各`HAVE_FUNCTION`为1或0
`AC_CHECK_FUNCS_ONCE (FUNCTIONS)`|定义各`HAVE_FUNCTION`为1或0
`AC_CHECK_HEADER(HEADER-FILE, [ACTION-IF-FOUND], [ACTION-IF-NOT-FOUND], [INCLUDES])`|按系统头文件能否编译做不同事
`AC_CHECK_HEADERS(HEADER-FILES, [ACTION-IF-FOUND], [ACTION-IF-NOT-FOUND], [INCLUDES])`|按系统头文件能否编译做不同事，定义`HAVE_HEADER-FILE`为0或1
`AC_CHECK_HEADERS_ONCE (HEADER-FILES)`|定义`HAVE_HEADER-FILE`为0或1
`AC_CHECK_HEADER_STDBOOL`|检查是否有C99的stdbool.h，有则定义`HAVE__BOOL`为1
`AC_CHECK_LIBAC_CHECK_LIB (LIBRARY, FUNCTION, [ACTION-IF-FOUND], [ACTION-IF-NOT-FOUND], [OTHER-LIBRARIES])`|按是否存在库函数做不同事情
`AC_CHECK_MEMBER (AGGREGATE.MEMBER, [ACTION-IF-FOUND], [ACTION-IF-NOT-FOUND], [INCLUDES = 'AC_INCLUDES_DEFAULT'])`|按是否有指定成员做不同事情
`AC_CHECK_MEMBERS (MEMBERS, [ACTION-IF-FOUND], [ACTION-IF-NOT-FOUND], [INCLUDES = 'AC_INCLUDES_DEFAULT'])`|按是否有指定成员做不同事情，定义`HAVE_AGGREGATE_MEMBER`为0或1
`AC_CHECK_PROG (VARIABLE, PROG-TO-CHECK-FOR, VALUE-IF-FOUND, [VALUE-IF-NOT-FOUND], [PATH = '$PATH'], [REJECT])`|按`PROG-TO-CHECK-FOR`在`PATH`是否存在把`VARIABLE`设置为`VALUE-IF-FOUND`或`VALUE-IF-NOT-FOUND`
`AC_CHECK_PROGS (VARIABLE, PROGS-TO-CHECK-FOR, [VALUE-IF-NOT-FOUND], [PATH = '$PATH'])`|按`PROG-TO-CHECK-FOR`在`PATH`中首个存在的设置`VARIABLE`设置，没有则`VALUE-IF-NOT-FOUND`或不变
`AC_CHECK_SIZEOF (TYPE-OR-EXPR, [UNUSED], [INCLUDES = 'AC_INCLUDES_DEFAULT'])`|定义`SIZEOF_TYPE-OR-EXPR`为占用的字节数
`AC_CHECK_TARGET_TOOL (VARIABLE, PROG-TO-CHECK-FOR, [VALUE-IF-NOT-FOUND], [PATH = '$PATH'])`|与`AC_CHECK_PROG`类似，但在程序前加目标类型和`-`前缀（与构建机类型同也接受不加）
`AC_CHECK_TARGET_TOOLS (VARIABLE, PROGS-TO-CHECK-FOR, [VALUE-IF-NOT-FOUND], [PATH = '$PATH'])`|与`AC_CHECK_PROGS`类似，但在程序前加目标类型和`-`前缀（与构建机类型同也接受不加）
`AC_CHECK_TOOL (VARIABLE, PROG-TO-CHECK-FOR, [VALUE-IF-NOT-FOUND], [PATH = '$PATH'])`|与`AC_CHECK_PROG`类似，但在程序前加运行机类型和`-`前缀
`AC_CHECK_TOOLS (VARIABLE, PROGS-TO-CHECK-FOR, [VALUE-IF-NOT-FOUND], [PATH = '$PATH'])`|与`AC_CHECK_PROGS`类似，但在程序前加运行机类型和`-`前缀
`AC_CHECK_TYPE (TYPE, [ACTION-IF-FOUND], [ACTION-IF-NOT-FOUND], [INCLUDES = 'AC_INCLUDES_DEFAULT'])`|按类型是否被定义做不同事
`AC_CHECK_TYPES (TYPES, [ACTION-IF-FOUND], [ACTION-IF-NOT-FOUND], [INCLUDES = 'AC_INCLUDES_DEFAULT'])`|按类型是否被定义做不同事，定义`HAVE_TYPE`
`AC_COMPILE_IFELSE (INPUT, [ACTION-IF-TRUE], [ACTION-IF-FALSE])`|按`INPUT`能否被编译做不同事
`AC_COMPUTE_INT (VAR, EXPRESSION, [INCLUDES = 'AC_INCLUDES_DEFAULT'], [ACTION-IF-FAILS])`|计算表达式的值（signed long）至shell变量
`AC_CONFIG_AUX_DIR (DIR)`|设置辅助构建工具目录
`AC_CONFIG_COMMANDS (TAG..., [CMDS], [INIT-CMDS])`|在`config.status`最后运行标记的命令
`AC_CONFIG_COMMANDS_POST (CMDS)`|在即将创建`config.status`前运行指定命令
`AC_CONFIG_COMMANDS_PRE (CMDS)`|在刚创建`config.status`后运行指定命令
`AC_CONFIG_FILES (FILE..., [CMDS], [INIT-CMDS])`|指定通过对相应`.in`文件替换输出变量而创建的文件
`AC_CONFIG_HEADERS (HEADER ..., [CMDS], [INIT-CMDS])`|指定生成的头文件
`AC_CONFIG_LIBOBJ_DIR (DIRECTORY)`|指定`AC_LIBOBJ`替代文件目录
`AC_CONFIG_LINKS (DEST:SOURCE..., [CMDS], [INIT-CMDS])`|把各源链接到目的地
`AC_CONFIG_MACRO_DIR (DIR)`|局部autoconf宏目录
`AC_CONFIG_SRCDIR (UNIQUE-FILE-IN-SOURCE-DIR)`|设置源目录
`AC_CONFIG_SUBDIRS (DIRS)`|让`AC_OUTPUT`对每个子目录运行`configure`
`AC_CONFIG_TESTDIR (DIRECTORY, [TEST-PATH = 'directory'])`|配置Autotest测试套件
`AC_COPYRIGHT (COPYRIGHT-NOTICE)`|`configure`的部分版权声明
`AC_C_BACKSLASH_A`|若C编译器支持`\a`则定义`HAVE_C_BACKSLASH_A`
`AC_C_BIGENDIAN ([ACTION-IF-TRUE], [ACTION-IF-FALSE], [ACTION-IF-UNKNOWN], [ACTION-IF-UNIVERSAL])`|按字节序展开为不同代码
`AC_C_CHAR_UNSIGNED`|若C的char类型为无符号的，定义`__CHAR_UNSIGNED__`
`AC_C_FLEXIBLE_ARRAY_MEMBER`|支持灵活数组成员时定义`FLEXIBLE_ARRAY_MEMBER`为空，否则1
`AC_C_INLINE`|若`inline`关键字用了非标准拼写，把`inline`定义为该拼写
`AC_C_RESTRICT`|若`restrict`关键字用了非标准拼写，把`restrict`定义为该拼写
`AC_C_TYPEOF`|支持GNU typeof语法时定义`HAVE_TYPEOF`为它的拼写
`AC_C_VARARRAYS`|支持可变长数组时定义`HAVE_C_VARARRAYS`
`AC_DATAROOTDIR_CHECKED`|定义这宏可禁用datarootdir警告
`AC_DEFINE (VARIABLE, VALUE, [DESCRIPTION])`|定义C宏
`AC_DEFINE (VARIABLE)`|定义C宏，值为1
`AC_DEFINE_UNQUOTED (VARIABLE, VALUE, [DESCRIPTION])`|定义C宏（键值进行shell的变量、反引号和反斜杠替换）
`AC_DEFINE_UNQUOTED (VARIABLE)`|定义C宏（键进行shell的变量、反引号和反斜杠替换），值为1
`AC_DEFUN (NAME, [BODY])`|定义autoconf知道的宏
`AC_DEFUN_ONCE (MACRO-NAME, MACRO-BODY)`|声明宏，但只在首次使用时展开体
`AC_DIAGNOSE (CATEGORY, MESSAGE)`|报告诊断信息
`AC_DISABLE_OPTION_CHECKING`|禁用对未声明选项的警告
`AC_EGREP_CPP (PATTERN, HEADER-FILE, ACTION-IF-FOUND, [ACTION-IF-NOT-FOUND])`|对预处理结果搜索
`AC_EGREP_HEADER (PATTERN, PROGRAM, [ACTION-IF-FOUND], [ACTION-IF-NOT-FOUND])`|对预处理结果搜索
`AC_ERLANG_CHECK_LIB (LIBRARY, [ACTION-IF-FOUND], [ACTION-IF-NOT-FOUND])`|检查Erlang/OTP库是否已安装
`AC_ERLANG_NEED_ERL ([PATH = '$PATH'])`|设置`ERL`
`AC_ERLANG_NEED_ERLC ([PATH = '$PATH'])`|设置`ERLC`
`AC_ERLANG_PATH_ERL ([VALUE-IF-NOT-FOUND], [PATH = '$PATH'])`|设置`ERL`
`AC_ERLANG_PATH_ERLC ([VALUE-IF-NOT-FOUND], [PATH = '$PATH'])`|设置`ERLC`
`AC_ERLANG_SUBST_ERTS_VER`|设置`ERLANG_ERTS_VER`
`AC_ERLANG_SUBST_INSTALL_LIB_DIR`|设置`ERLANG_INSTALL_LIB_DIR`
`AC_ERLANG_SUBST_INSTALL_LIB_SUBDIR (LIBRARY, VERSION)`|设置`ERLANG_INSTALL_LIB_DIR_LIBRARY`
`AC_ERLANG_SUBST_LIB_DIR`|设置`AC_ERLANG_SUBST_LIB_DIR`
`AC_ERLANG_SUBST_ROOT_DIR`|设置`AC_ERLANG_SUBST_ROOT_DIR`
`AC_F77_DUMMY_MAIN ([ACTION-IF-SUCCESS], [ACTION-IF-FAILURE = 'AC_MSG_FAILURE'])`|设置`F77_DUMMY_MAIN`为Fortrank占位入口函数名
`AC_F77_FUNC`|把一个名字的Fortran风格形式保存到一个shell变量
`AC_F77_IMPLICIT_NONE ([ACTION-IF-SUCCESS], [ACTION-IF-FAILURE = 'AC_MSG_FAILURE'])`|企图禁止隐式声明
`AC_F77_LIBRARY_LDFLAGS`|设置`FLIBS`
`AC_F77_MAIN`|设置`F77_MAIN`为Fortran入口函数名
`AC_F77_WRAPPERS`|定义C宏`F77_FUNC (name, NAME)`
`AC_FATAL (MESSAGE)`|报告致命错误信息
`AC_FC_CHECK_BOUNDS ([ACTION-IF-SUCCESS], [ACTION-IF-FAILURE = 'AC_MSG_FAILURE'])`|启用数组出界检查
`AC_FC_DUMMY_MAIN ([ACTION-IF-SUCCESS], [ACTION-IF-FAILURE = 'AC_MSG_FAILURE'])`|设置`FC_DUMMY_MAIN`为Fortrank占位入口函数名
`AC_FC_FIXEDFORM ([ACTION-IF-SUCCESS], [ACTION-IF-FAILURE = 'AC_MSG_FAILURE'])`|保证容许固定格式
`AC_FC_FREEFORM ([ACTION-IF-SUCCESS], [ACTION-IF-FAILURE = 'AC_MSG_FAILURE'])`|保证容许自由格式
`AC_FC_FUNC`|把一个名字的Fortran风格形式保存到一个shell变量
`AC_FC_IMPLICIT_NONE ([ACTION-IF-SUCCESS], [ACTION-IF-FAILURE = 'AC_MSG_FAILURE'])`|企图禁止隐式声明
`AC_FC_LIBRARY_LDFLAGS`|设置`FCLIBS`
`AC_FC_LINE_LENGTH ([LENGTH], [ACTION-IF-SUCCESS], [ACTION-IF-FAILURE = 'AC_MSG_FAILURE'])`|保证接受行长度80、132（默认）或unlimited
`AC_FC_MAIN`|设置`FC_MAIN`为Fortran入口函数名
`AC_FC_MODULE_EXTENSION`|设置`MODEXT`
`AC_FC_MODULE_FLAG ([ACTION-IF-SUCCESS], [ACTION-IF-FAILURE = 'AC_MSG_FAILURE'])`|设置`MODINC`
`AC_FC_MODULE_OUTPUT_FLAG ([ACTION-IF-SUCCESS], [ACTION-IF-FAILURE = 'AC_MSG_FAILURE'])`|设置`FC_MODOUT`
`AC_FC_PP_DEFINE ([ACTION-IF-SUCCESS], [ACTION-IF-FAILURE = 'AC_MSG_FAILURE'])`|把`FC_DEFINE`设为已预处理Fortran定义的选项
`AC_FC_PP_SRCEXT (EXT, [ACTION-IF-SUCCESS], [ACTION-IF-FAILURE = 'AC_MSG_FAILURE'])`|让预处理器支持Fortran源文件后缀
`AC_FC_SRCEXT (EXT, [ACTION-IF-SUCCESS], [ACTION-IF-FAILURE = 'AC_MSG_FAILURE'])`|让编译器支持Fortran源文件后缀
`AC_FC_WRAPPERS`|定义C宏`FC_FUNC (name, NAME)`
`AC_FUNC_ALLOCA`|检查`alloca`函数
`AC_FUNC_CHOWN`|检查`chown`函数
`AC_FUNC_CLOSEDIR_VOID`|检查`closedir`函数
`AC_FUNC_ERROR_AT_LINE|检查`error_at_line`函数
`AC_FUNC_FNMATCH`|检查`fnmatch`函数
`AC_FUNC_FNMATCH_GNU`|检查支持GNU扩展的`fnmatch`函数
`AC_FUNC_FORK`|检查`fork`和`vfork`函数
`AC_FUNC_FSEEKO`|检查`fseeko`函数
`AC_FUNC_GETGROUPS`|检查`getgroups`函数
`AC_FUNC_GETLOADAVG`|检查`getloadavg`函数
`AC_FUNC_GETMNTENT`|检查`getmntent`函数
`AC_FUNC_GETPGRP`|检查`getpgrp`函数
`AC_FUNC_LSTAT_FOLLOWS_SLASHED_SYMLINK`|检查`lstat`函数等同`link/`和`link/.`
`AC_FUNC_MALLOC`|检查`malloc`函数
`AC_FUNC_MBRTOWC`|检查`mbrtowc`函数
`AC_FUNC_MEMCMP`|检查`memcmp`函数
`AC_FUNC_MKTIME`|检查`mktime`函数
`AC_FUNC_MMAP`|检查`mmap`函数
`AC_FUNC_OBSTACK`|检查`obstack`函数
`AC_FUNC_REALLOC`|检查`realloc`函数
`AC_FUNC_SELECT_ARGTYPES`|检查`select`函数参数类型并定义`SELECT_TYPE_ARG1`、`SELECT_TYPE_ARG234`、`SELECT_TYPE_ARG5`
`AC_FUNC_SETPGRP`|检查`setpgrp`函数
`AC_FUNC_STRCOLL`|检查`strcoll`函数
`AC_FUNC_STRERROR_R`|检查`strerror_r`函数
`AC_FUNC_STRNLEN`|检查`strnlen`函数
`AC_FUNC_STRTOD`|检查`strtod`函数
`AC_FUNC_STRTOLD`|检查`strtold`函数
`AC_FUNC_VPRINTF`|检查`vprintf`函数
`AC_HEADER_ASSERT`|检查是否打开断言
`AC_HEADER_DIRENT`|对于`dirent.h`、`sys/ndir.h`、`sys/dir.h`、`ndir.h`中首个存在且定义`DIR`的对应声明`HAVE_DIRENT_H`、`HAVE_SYS_NDIR_H`、`HAVE_SYS_DIR_H`、`HAVE_NDIR_H`
`AC_HEADER_MAJOR`|若`sys/types.h`没有定义`major`、`minor`和`makedev`，则`sys/mkdev.h`有时定义`MAJOR_IN_MKDEV`、`sys/sysmacros.h`有时定义`MAJOR_IN_SYSMACROS`
`AC_HEADER_RESOLV`|检查`resolv.h`
`AC_HEADER_STDBOOL`|检查是否有C99的stdbool.h，有则定义`HAVE_STDBOOL_H`为1，若有`_Bool`类型，定义`HAVE__BOOL`为1
`AC_HEADER_STDC`|若C头文件符合C89，定义`STDC_HEADERS`
`AC_HEADER_SYS_WAIT`|若`sys/wait.h`存在且与Posix兼容，定义`HAVE_SYS_WAIT_H`
`AC_HEADER_TIME`|若可同时包含`time.h`和`sys/time.h`，定义`TIME_WITH_SYS_TIME`
`AC_HEADER_TIOCGWINSZ`|若`TIOCGWINSZ`要求`<sys/ioctl.h>`，则定义`GWINSZ_IN_SYS_IOCTL`
`AC_INCLUDES_DEFAULT ([INCLUDE-DIRECTIVES])`|展开为包含标准头文件的C代码
`AC_INIT (PACKAGE, VERSION, [BUG-REPORT], [TARNAME], [URL])`|必须在产生输出的宏前调用，生成m4宏`AC_PACKAGE_NAME`、`AC_PACKAGE_TARNAME`、`AC_PACKAGE_VERSION`、`AC_PACKAGE_STRING`、`AC_PACKAGE_BUGREPORT`、`AC_PACKAGE_URL`，同时定义预处理符号和输出变量（名字没有`AC_`前缀）
`AC_LANG (LANGUAGE)`|选择当前语言
`AC_LANG_ASSERT (LANGUAGE)`|断言当前语言
`AC_LANG_CALL (PROLOGUE, FUNCTION)`|展开main函数调用指定函数的源文件
`AC_LANG_CONFTEST (SOURCE)`|把参数保存到当前测试源文件
`AC_LANG_DEFINES_PROVIDED`|见证文件`conftest.EXTENSION`适合当前语言
`AC_LANG_FUNC_LINK_TRY (FUNCTION)`|展开为有指定main函数体的源文件
`AC_LANG_POP ([LANGUAGE])`|把当前语言（原来的可作参数）设置为从栈弹出的语言
`AC_LANG_PROGRAM (PROLOGUE, FUNCTION)`|展开为有指定main函数体的源文件
`AC_LANG_PUSH (LANGUAGE)`|把当前语言入栈后设置新的当前语言
`AC_LANG_SOURCE (SOURCE)`|把所有`AC_DEFINE`展开到参数
`AC_LANG_WERROR`|把预处理器、编译器、链接器的警告视为错误
`AC_LIBOBJ (FUNCTION)`|包含`FUNCTION.c`代替FUNCTION.
`AC_LIBSOURCE (FILE)`|指出编译可能需要的文件
`AC_LIBSOURCES (FILES)`|指出编译可能需要的文件列表（逗号分隔）
`AC_LINK_IFELSE`|RunningtheLinker.
`AC_MSG_CHECKING (FEATURE-DESCRIPTION)`|通知用户当前检查
`AC_MSG_ERROR (ERROR-DESCRIPTION, [EXIT-STATUS = '$?/1'])`|在标准输出提示错误并退出
`AC_MSG_FAILURE (ERROR-DESCRIPTION, [EXIT-STATUS])`|在日志`config.log`提示错误并退出
`AC_MSG_NOTICE (MESSAGE)`|通知用户信息
`AC_MSG_RESULT (RESULT-DESCRIPTION)`|通知用户检查结果
`AC_MSG_WARN (PROBLEM-DESCRIPTION)`|给出警告
`AC_OPENMP`|准备用Open MP
`AC_OUTPUT`|生成`config.status`并启动它，从而生成输出文件，这宏只能在`configure.ac`被调用一次
`AC_PACKAGE_BUGREPORT`|展开为PACKAGE_BUGREPORT
`AC_PACKAGE_NAME`|展开为PACKAGE_NAME
`AC_PACKAGE_STRING`|展开为PACKAGE_STRING
`AC_PACKAGE_TARNAME`|TARNAME
`AC_PACKAGE_URL`|展开为PACKAGE_URL
`AC_PACKAGE_VERSION`|展开为PACKAGE_VERSION
`AC_PATH_PROG (VARIABLE, PROG-TO-CHECK-FOR, [VALUE-IF-NOT-FOUND], [PATH = '$PATH'])`|类似`AC_CHECK_PROG`但设置为绝对路径
`AC_PATH_PROGS (VARIABLE, PROG-TO-CHECK-FOR, [VALUE-IF-NOT-FOUND], [PATH = '$PATH'])`|类似`AC_CHECK_PROGS`但设置为绝对路径
`AC_PATH_PROGS_FEATURE_CHECK (VARIABLE, PROGS-TO-CHECK-FOR, FEATURE-TEST, [ACTION-IF-NOT-FOUND], [PATH = '$PATH'])`|设置`VARIABLE`为`PATH`中首个通过`FEATURE-TEST`（可用变量ac_cv_path_VARIABLE`访问绝对路径）的`PROGS-TO-CHECK-FOR`
`AC_PATH_TARGET_TOOL (VARIABLE, PROG-TO-CHECK-FOR, [VALUE-IF-NOT-FOUND], [PATH = '$PATH'])`|类似`AC_CHECK_TARGET_TOOL`但设置为绝对路径
`AC_PATH_TOOL (VARIABLE, PROG-TO-CHECK-FOR, [VALUE-IF-NOT-FOUND], [PATH = '$PATH'])`|类似`AC_CHECK_TOOL`但设置为绝对路径
`AC_PATH_X`|定位X窗口系统
`AC_PATH_XTRA`|定位X窗口系统和确定有关编译选项
`AC_PREFIX_DEFAULT (PREFIX)`|设置默认前缀（原来是`/usr/local`）
`AC_PREFIX_PROGRAM (PROGRAM)`|依照已知程序设置默认前缀
`AC_PREPROC_IFELSE (INPUT, [ACTION-IF-TRUE], [ACTION-IF-FALSE])`|按预处理成功与否做不同事情
`AC_PREREQ (VERSION)`|保证autoconf版本至少为什么，可在`AC_INIT`前用
`AC_PRESERVE_HELP_ORDER`|要求分栏`--help`格式，要在`AC_ARG_ENABLE`或`AC_ARG_WITH`前
`AC_PROG_AWK`|准备awk命令
`AC_PROG_CC ([COMPILER-SEARCH-LIST])`|准备C编译器
`AC_PROG_CC_C89`|准备使用C89
`AC_PROG_CC_C99`|准备使用C99
`AC_PROG_CC_C_O`|若C编译器不支持同时`-c -o`选项，则定义`NO_MINUS_C_MINUS_O`
`AC_PROG_CC_STDC`|准备使用ISO C
`AC_PROG_CPP`|准备C预处理器
`AC_PROG_CPP_WERROR`|准备C预处理器，使警告成为错误
`AC_PROG_CXX ([COMPILER-SEARCH-LIST])`|准备C++编译器
`AC_PROG_CXXCPP`|准备C++预处理器
`AC_PROG_CXX_C_O`|若C++编译器不支持同时`-c -o`选项，则定义`CXX_NO_MINUS_C_MINUS_O`
`AC_PROG_EGREP`|准备egrep命令.
`AC_PROG_F77 ([COMPILER-SEARCH-LIST])`|准备Fortran77编译器
`AC_PROG_F77_C_O`|若Fortran 77编译器不支持同时`-c -o`选项，则定义`F77_NO_MINUS_C_MINUS_O`
`AC_PROG_FC ([COMPILER-SEARCH-LIST], [DIALECT])`|准备Fortran编译器
`AC_PROG_FC_C_O`|若Fortran编译器不支持同时`-c -o`选项，则定义`FC_NO_MINUS_C_MINUS_O`
`AC_PROG_FGREP`|准备fgrep命令
`AC_PROG_GREP`|准备grep命令
`AC_PROG_INSTALL`|准备install命令.
`AC_PROG_LEX`|准备lex命令
`AC_PROG_LN_S`|准备`ln -s`命令
`AC_PROG_MAKE_SET`|Output.
`AC_PROG_MKDIR_P`|准备`mkdir -p`命令
`AC_PROG_OBJC ([COMPILER-SEARCH-LIST])`|准备Objective C编译器命令
`AC_PROG_OBJCPP`|准备Objective C预处理器命令
`AC_PROG_OBJCXX ([COMPILER-SEARCH-LIST])`|准备Objective C++编译器命令
`AC_PROG_OBJCXXCPP`|准备Objective C预处理器命令
`AC_PROG_RANLIB`|准备ranlib命令
`AC_PROG_SED`|准备sed命令
`AC_PROG_YACC`|准备yacc命令
`AC_REPLACE_FNMATCH`|若`fnmatch`函数不符合posix，则要求替换
`AC_REPLACE_FUNCS (FUNCTION...)`|缺少函数时替换之
`AC_REQUIRE (MACRO-NAME)`|确保m4宏被调用过
`AC_REQUIRE_AUX_FILE`|声明辅助文件
`AC_REQUIRE_CPP`|准备预处理器
`AC_REVISION (REVISION-INFO)`|configure版本
`AC_RUN_IFELSE (INPUT, [ACTION-IF-TRUE], [ACTION-IF-FALSE], [ACTION-IF-CROSS-COMPILING = 'AC_MSG_FAILURE'])`|按`INPUT`编译并运行后是否成功退出做不同事
`AC_SEARCH_LIBS (FUNCTION, SEARCH-LIBS, [ACTION-IF-FOUND], [ACTION-IF-NOT-FOUND], [OTHER-LIBRARIES])`|寻找有指定函数的库并前置到`LIBS`
`AC_STRUCT_DIRENT_D_INO`|`struct dirent`有成员`d_ino`则定义`HAVE_STRUCT_DIRENT_D_INO`
`AC_STRUCT_DIRENT_D_TYPE`|`struct dirent`有成员`d_type`则定义`HAVE_STRUCT_DIRENT_D_TYPE`
`AC_STRUCT_ST_BLOCKS`|`struct stat`有成员`st_blocks`则定义`HAVE_STRUCT_STAT_ST_BLOCKS`
`AC_STRUCT_TIMEZONE`|若`time.h`没有定义`struct tm`则定义`TM_IN_SYS_TIME`
`AC_STRUCT_TM`|`struct tm`有成员`tm_zone`则定义`HAVE_STRUCT_TM_TM_ZONE`，否则若有外部数组`tzname`，定义`HAVE_TZNAME`
`AC_SUBST (VARIABLE, [VALUE])`|由shell变量创建相同值的输出变量，可选择赋值
`AC_SUBST_FILE (VARIABLE)`|由shell变量创建值为它指定文件内容的输出变量
`AC_SYS_INTERPRETER`|把变量`interpval`设置为系统是否支持`#!`方式决定解释器
`AC_SYS_LARGEFILE`|若支持64位偏移，定义`_FILE_OFFSET_BITS`和`_LARGE_FILES`
`AC_SYS_LONG_FILE_NAMES`|若支持长于14字符的文件名，定义`HAVE_LONG_FILE_NAMES
`AC_SYS_POSIX_TERMIOS`|把变量`ac_cv_sys_posix_termios`设置为POSIX的termios头文件和函数是否可用
`AC_TYPE_GETGROUPS`|声明组id类型`GETGROUPS_T`
`AC_TYPE_INT16_T`|确保声明16位有符号整数类型`int16_t`
`AC_TYPE_INT32_T`|确保声明32位有符号整数类型`int32_t`
`AC_TYPE_INT64_T`|确保声明64位有符号整数类型`int64_t`
`AC_TYPE_INT8_T`|确保声明8位有符号整数类型`int8_t`
`AC_TYPE_INTMAX_T`|确保声明最宽有符号整数类型`intmax_t`，已有则定义`HAVE_INTMAX_T`
`AC_TYPE_INTPTR_T`|确保声明足够放指针的有符号整数类型`intmax_t`，已有则定义`HAVE_INTPTR_T`
`AC_TYPE_LONG_DOUBLE`|有`long double`类型时设置`HAVE_LONG_DOUBLE`
`AC_TYPE_LONG_DOUBLE_WIDER`|有比`double`宽的`long double`类型时设置`HAVE__LONG_DOUBLE_WIDER`
`AC_TYPE_LONG_LONG_INT`|有`long long int`类型时设置`HAVE_LONG_LONG_INT`
`AC_TYPE_MBSTATE_T`|确保声明类型`mbstate_t`，已有则定义`HAVE_MBSTATE_T`
`AC_TYPE_MODE_T`|确保声明类型`mode_t`
`AC_TYPE_OFF_T`|确保声明类型`off_t`
`AC_TYPE_PID_T`|确保声明类型`pid_t`
`AC_TYPE_SIZE_T`|确保声明类型`size_t`
`AC_TYPE_SSIZE_T`|确保声明类型`ssize_t`
`AC_TYPE_UID_T`|确保声明类型`uid_t`和`gid_t`
`AC_TYPE_UINT16_T`|确保声明16位无符号整数类型`uint16_t`
`AC_TYPE_UINT32_T`|确保声明32位无符号整数类型`uint32_t`
`AC_TYPE_UINT64_T`|确保声明64位无符号整数类型`uint64_t`
`AC_TYPE_UINT8_T`|确保声明8位无符号整数类型`uint8_t`
`AC_TYPE_UINTMAX_T`|确保声明最宽无符号整数类型`uintmax_t`，已有则定义`HAVE_UINTMAX_T`
`AC_TYPE_UINTPTR_T`|确保声明足够放指针的无符号整数类型`uintmax_t`，已有则定义`HAVE_UINTPTR_T`
`AC_TYPE_UNSIGNED_LONG_LONG_INT`|有`unsigned long long int`类型时设置`HAVE_UNSIGNED_LONG_LONG_INT`
`AC_USE_SYSTEM_EXTENSIONS`|保证启用系统扩展，定义一些C宏以表示启用的扩展如`_GNU_SOURCE`
`AC_WARNING (MESSAGE)`|报告警告
`AH_BOTTOM (TEXT)`|在头文件模板下方插入文字
`AH_HEADER`|展开为首个声明的配置头文件名
`AH_TEMPLATE (KEY, DESCRIPTION)`|生成模板
`AH_TOP (TEXT)`|在头文件模板上方插入文字
`AH_VERBATIM (KEY, TEMPLATE)`|要求按`KEY`顺序包含模板

#### Makefile中的替换

`Makefile.in`中的`@变量名@`会被autoconf替换为变量的值。

输出变量|说明
---|---
abs_builddir|builddir的绝对名
abs_srcdir|srcdir的绝对名
abs_top_builddir|top_builddir的绝对名
abs_top_srcdir|top_srcdir的绝对名
ac_empty|空占位符
ALLOCA|alloca函数的获得途径，通常由`AC_FUNC_ALLOCA`设置
AWK|awk命令，通常由`AC_PROG_AWK`设置
bindir|可执行文件目录
build|构建用系统的规范类型，通常由`AC_CANONICAL_BUILD`设置
builddir|相当于`.`
build_alias|构建用系统的（不一定规范）类型，由`--build`选项设置
build_cpu|构建用系统的规范类型，通常由`AC_CANONICAL_BUILD`设置
build_os|构建用系统的规范类型，通常由`AC_CANONICAL_BUILD`设置
build_vendor|构建用系统的规范类型，通常由`AC_CANONICAL_BUILD`设置
CC|C编译器命令
CFLAGS|C编译器调试和优化选项，通常由`AC_PROG_CC`设置
configure_input|生成文件的来源configure文件
CPP|C预处理器命令，通常由`AC_PROG_CPP`设置
CPPFLAGS|C、C++、Objective C、Objective C++的预处理选项
cross_compiling|是否交叉编译
CXX|C++编译器命令，通常由`AC_PROG_CXX`设置
CXXCPP|C++预处理器命令，通常由`AC_PROG_CXXCPP`设置
CXXFLAGS|C++编译器调试和优化选项，通常由`AC_PROG_CXX`设置
datadir|体系无关只读数据文件目录
datarootdir|体系无关只读数据文件的根目录
DEFS|C编译器的`-D`选项
docdir|非man和info的文档文件目录
dvidir|dvi文档文件目录
ECHO_C|echo命令中用的换行
ECHO_N|echo命令中用的禁止尾随换行
ECHO_T|echo命令中用的制表符
EGREP|egrep命令，通常由`AC_PROG_EGREP`设置
ERL|Erlang解释器命令，`AC_ERLANG_PATH_ERL`设置
ERLANG_ERTS_VER|Erlang运行时版本，由`AC_ERLANG_SUBST_ERTS_VER`设置
ERLANG_INSTALL_LIB_DIR|Erlang库根文件目录
ERLANG_INSTALL_LIB_DIR_LIBRARY|Erlang库文件目录
ERLANG_LIB_DIR|Erlang安装库的目录，由`AC_ERLANG_LIB_DIR`设置
ERLANG_LIB_DIR_LIBRARY|Erlang库目录
ERLANG_LIB_VER_LIBRARY|Erlang库版本
ERLANG_ROOT_DIR|Erlang安装的根目录，由`AC_ERLANG_ROOT_DIR`设置
ERLC|Erlang编译器命令，由`AC_ERLANG_PATH_ERLC`设置
ERLCFLAGS|Erlang编译器调试和优化选项
exec_prefix|体系相关文伯的安装目录，默认同prefix
EXEEXT|可执行代码的后缀
F77|Fortran77编译器命令，通常由`AC_PROG_F77`设置
FC|Fortran编译器命令，通常由`AC_PROG_FC`设置
FCFLAGS|Fortran编译器调试和优化选项，通常由`AC_PROG_FC`设置
FCLIBS|Fortran链接选项，通常由`AC_FC_LIBRARY_LDFLAGS`设置
FC_MODEXT|Fortran90模块文件后缀，由`AC_FC_MODULE_EXTENSION`设置
FC_MODINC|Fortran90模块导入选项，由`AC_FC_MODULE_FLAG`设置
FC_MODOUT|Fortran90模块导出选项，由`AC_FC_MODULE_OUTPUT_FLAG`设置
FFLAGS|Fortran77编译器调试和优化选项，通常由`AC_PROG_F77`设置
FGREP|fgrep命令，通常由`AC_PROG_FGREP`设置
FLIBS|Fortran77链接选项，通常由`AC_F77_LIBRARY_LDFLAGS`设置
GETGROUPS_LIBS|getgroups函数的获得途径，通常由`AC_FUNC_GETGROUPS`设置
GETLOADAVG_LIBS|getloadavg函数的获得途径，通常由`AC_FUNC_GETLOADAVG`设置
GOFLAGS|Go编译器调试和优化选项
GREP|grep命令，通常由`AC_PROG_GREP`设置
host|运行用系统的规范类型，通常由`AC_CANONICAL_HOST`设置
host_alias|运行用系统的（不一定规范）类型，由`--host`选项设置
host_cpu|运行用系统的规范类型，通常由`AC_CANONICAL_HOST`设置
host_os|运行用系统的规范类型，通常由`AC_CANONICAL_HOST`设置
host_vendor|运行用系统的规范类型，通常由`AC_CANONICAL_HOST`设置
htmldir|html文档文件目录
includedir|C头文件文件目录
infodir|info文档文件目录
INSTALL|install命令，通常由`AC_PROG_INSTALL`设置
INSTALL_DATA|用于安装数据文件的命令通常由`AC_PROG_INSTALL`设置为`${INSTALL} -m 644`
INSTALL_PROGRAM|用于安装程序文件的命令通常由`AC_PROG_INSTALL`设置为`${INSTALL}`
INSTALL_SCRIPT|用于安装脚本文件的命令通常由`AC_PROG_INSTALL`设置为`${INSTALL}`
KMEM_GROUP|安装包的组
LDFLAGS|链接选项
LEX|lex命令，通常由`AC_PROG_LEX`设置
LEXLIB|链接lex的选项，通常由`AC_PROG_LEX`设置
LEX_OUTPUT_ROOT|lex生成文件的前缀
libdir|库文件目录
libexecdir|供其它程序运行的可执行文件目录
LIBS|给链接器的`-l`选项
LN_S|`ln -s`命令，通常由`AC_PROG_LN_S`设置
localedir|本地化文件根目录（通常每个本地一个子目录）
localstatedir|可修改本机数据文件目录
mandir|man文档文件目录
MKDIR_P|`mkdir -p`命令，通常由`AC_PROG_MKDIR_P`设置
NEED_SETGID|需要设置安装包的组
OBJC|Objective C命令，通常由`AC_PROG_OBJC`设置
OBJCFLAGS|Objective-C编译器调试和优化选项
OBJCPP|Objective C预处理命令，通常由`AC_PROG_OBJCPP`设置
OBJCXX|Objective C++命令，通常由`AC_PROG_OBJCXX`设置
OBJCXXCPP|Objective C++预处理命令，通常由`AC_PROG_OBJCXXCPP`设置
OBJCXXFLAGS|Objective-C++编译器调试和优化选项
OBJEXT|编译后代码的后缀
oldincludedir|非GCC编译器C头文件目录
OPENMP_CFLAGS|OpenMP需要的C编译器选项，通常由`AC_OPENMP`设置
OPENMP_CXXFLAGS|OpenMP需要的C++编译器选项，通常由`AC_OPENMP`设置
OPENMP_FCFLAGS|OpenMP需要的Fortran编译器选项，通常由`AC_OPENMP`设置
OPENMP_FFLAGS|OpenMP需要的Fortran77编译器选项，通常由`AC_OPENMP`设置
PACKAGE_BUGREPORT|缺陷跟踪电邮地址或页面URL
PACKAGE_NAME|包名
PACKAGE_STRING|`PACKAGE VERSION`
PACKAGE_TARNAME|包的归档名，默认由包名去前缀`GNU `再把非数字字母的字符换成`-`得到
PACKAGE_URL|包URL，包名由`GNU `开始的话默认为`http://www.gnu.org/software/TARNAME/`
PACKAGE_VERSION|包版本号
pdfdir|pdf文档文件目录
POW_LIB|pow所在的库
prefix|根安装目录
program_transform_name|用于改名的sed命令序列
psdir|ps文档文件目录
RANLIB|ranlib命令，通常由`AC_PROG_RANLIB`设置
runstatedir|临时可修改本机数据文件目录
sbindir|高权限可执行文件目录
SED|sed命令，通常由`AC_PROG_SED`设置
SET_MAKE|一个用于设置`$(MAKE)`的宏定义
sharedstatedir|可修改体系无关数据文件目录
srcdir|单个makefile的源目录
subdirs|要处理的子目录列表
sysconfdir|只读本机数据文件目录
target|目标系统的规范类型，通常由`AC_CANONICAL_TARGET`设置
target_alias|目标系统的（不一定规范）类型，由`--target`选项设置
target_cpu|目标系统的规范类型，通常由`AC_CANONICAL_TARGET`设置
target_os|目标系统的规范类型，通常由`AC_CANONICAL_TARGET`设置
target_vendor|目标系统的规范类型，通常由`AC_CANONICAL_TARGET`设置
tmp|临时目录
top_builddir|顶级构建目录
top_build_prefix|顶级源目录的相对名
top_srcdir|顶级源目录
X_CFLAGS|X需要的C编译器选项
X_EXTRA_LIBS|链接X所需的其它库
X_LIBS|链接X的选项
X_PRE_LIBS|链接X前的选项
YACC|yacc命令，通常由`AC_PROG_YACC`设置

### automake

#### 宏

宏|说明
---|---
`AM_CONDITIONAL (CONDITIONAL, CONDITION)`|引入条件automake
`AM_COND_IF (CONDITIONAL, [IF-TRUE], [IF-FALSE])`|条件
`AM_GNU_GETTEXT`|确保包满足表gettext要求
`AM_GNU_GETTEXT_INTL_SUBDIR`|要求构建子目录`intl/`
`AM_INIT_AUTOMAKE([OPTIONS])`|初始化automake
`AM_MAINTAINER_MODE([DEFAULT-MODE])`|设置维护者模式
`AM_MISSING_PROG(NAME, PROGRAM)`|把指定程序位置写到指定环境变量
`AM_PATH_LISPDIR`|设置`lispdir`
`AM_PATH_PYTHON ([VERSION], [ACTION-IF-FOUND], [ACTION-IF-NOT-FOUND])`|搜索Python
`AM_PROG_AR([ACT-IF-FAIL])`|指定处理非常规归档的命令
`AM_PROG_AS`|设置`CCAS`和`CCASFLAGS`
`AM_PROG_GCJ`|设置`GCJ`和`GCJFLAGS`
`AM_PROG_LEX`|
`AM_PROG_UPC([COMPILER-SEARCH-LIST])`|设置`UPC`
`AM_PROG_VALACAM_PROG_VALAC ([MINIMUM-VERSION], [ACTION-IF-FOUND], [ACTION-IF-NOT-FOUND])`|
`AM_SILENT_RULES`|精简输出
`AM_SUBST_NOTMAKE(VAR)`|防止定义变量
`AM_WITH_DMALLOC`|支持Dmalloc

#### 变量

automake主要用变量的值决定做什么，虽然变量繁多，但有一些规则：
- 一个变量有`AM_`前缀版本，这时`AM_`前缀的由开发者设置，没有的由用户设置
- 一些前缀有特殊意义：
    - `no_base`表示不压平目录结构
    - `dist`表示指定要发布的文件
    - `no_dist`表示指定不要发布的文件
    - `no_inst`表示指定要发布但不安装的文件（通常因为只在安装时用到）
    - 其它前缀表示对应子目录
- 后缀`PROGRAMS`、`LIBRARIES`、`LTLIBRARIES`、`LISP`、`PYTHON`、`JAVA`、`SCRIPTS`、`DATA`、`HEADERS`、`MANS`、`TEXINFOS`分别表示各类文件

变量|说明
---|---
`_DATA`|参考无前缀形式
`_HEADERS`|参考无前缀形式
`_LIBRARIES`|参考无前缀形式
`_LISP`|参考无前缀形式
`_LOG_COMPILE`|参考无前缀形式
`_LOG_COMPILER`|参考无前缀形式
`_LOG_DRIVER`|参考无前缀形式
`_LOG_DRIVER_FLAGS`|参考无前缀形式
`_LOG_FLAGS`|参考无前缀形式
`_LTLIBRARIES`|参考无前缀形式
`_MANS`|参考无前缀形式
`_PROGRAMS`|参考无前缀形式
`_PYTHON`|参考无前缀形式
`_SCRIPTS`|参考无前缀形式
`_SOURCES`|参考无前缀形式
`_TEXINFOS`|参考无前缀形式
`AM_CCASFLAGS`|汇编器选项
`AM_CFLAGS`|额外的C编译器选项
`AM_COLOR_TESTS`|结果是否用彩色表示
`AM_CPPFLAGS`|C预处理选项
`AM_CXXFLAGS`|C++编译器选项
`AM_DEFAULT_SOURCE_EXT`|源文件的默认后缀
`AM_DISTCHECK_CONFIGURE_FLAGS`|额外configure选项
`AM_ETAGSFLAGS`|etags选项
`AM_EXT_LOG_DRIVER_FLAGS`|测试驱动器选项
`AM_EXT_LOG_FLAGS`|测试运行器参数
`AM_FCFLAGS`|Fortran 9x编译器选项
`AM_FFLAGS`|Fortran77编译器选项
`AM_GCJFLAGS`|GCJ选项
`AM_INSTALLCHECK_STD_OPTIONS_EXEMPT`|不检查可运行性的程序
`AM_JAVACFLAGS`|Java编译器选项
`AM_LDFLAGS`|额外链接选项
`AM_LFLAGS`|lex选项
`AM_LIBTOOLFLAGS`|Libtool选项
`AM_LOG_DRIVER_FLAGS`|测试驱动器选项
`AM_LOG_FLAGS`|测试运行器参数
`AM_MAKEFLAGS`|`make`选项
`AM_MAKEINFOFLAGS`|`makeinfo`选项
`AM_MAKEINFOHTMLFLAGS`|`makeinfo`选项
`AM_OBJCFLAGS`|Objective C编译器选项
`AM_OBJCXXFLAGS`|Objective C++编译器选项
`AM_RFLAGS`|Ratfor编译器选项
`AM_RUNTESTFLAGS`|DejaGnu测试选项
`AM_TESTS_ENVIRONMENT`|测试前的预备代码
`AM_TESTS_FD_REDIRECT`|测试中文件重定向
`AM_UPCFLAGS`|统一并行C选项
`AM_UPDATE_INFO_DIR`|是否在安装info页时更新索引
`AM_VALAFLAGS`|vala选项
`AM_V_at`|用于安静模式下抑制输出的命令前缀
`AM_V_GEN`|用于安静模式下输出状态行的命令前缀
`AM_YFLAGS`|yacc选项
`AR`|`ar`命令
`AUTOCONF`|autoconf命令
`AUTOM4TE`|aclocal命令
`AUTOMAKE_JOBS`|最大并发的perl线程数
`AUTOMAKE_OPTIONS`|automake选项
`bin_PROGRAMS`|需要安装到`bin`目录的程序
`bin_SCRIPTS`|需要安装到`bin`目录的脚本
`build_triplet`|构建机类型
`BUILT_SOURCES`|放在指定地方的源文件
`BZIP2`|bzip2选项
`CC`|继承自autoconf
`CCAS`|汇编器
`CCASFLAGS`|汇编器选项
`CFLAGS`|继承自autoconf
`check_LTLIBRARIES`|放在指定地方的Libtool库
`check_PROGRAMS`|放在指定地方的程序
`check_SCRIPTS`|放在指定地方的脚本
`CLASSPATH_ENV`|用于设置CLASSPATH环境变量的shell表达式
`CLEANFILES`|目标`clean`应清除的文件
`COMPILE`|编译C源文件的命令
`CONFIGURE_DEPENDENCIES`|`configure`的依赖项
`CONFIG_STATUS_DEPENDENCIES`|`config.status`的依赖项
`CPPFLAGS`|继承自autoconf
`CXX`|C++编译器
`CXXCOMPILE`|编译C++的命令
`CXXFLAGS`|C++编译器选项
`CXXLINK`|链接C++程序的命令
`DATA`|数据文件
`data_DATA`|放到指定地方的数据文件
`DEFS`|继承自autoconf
`DEJATOOL`|给`--tool`的参数
`DESTDIR`|发布目录
`DISABLE_HARD_ERRORS`|把硬错误视为普通失败
`DISTCHECK_CONFIGURE_FLAGS`|额外configure选项
`distcleancheck_listfiles`|检查构建树已经清空的命令
`DISTCLEANFILES`|目标`distclean`应清除的文件
`distdir`|发布目录
`distuninstallcheck_listfiles`|检查安装树已经清空的命令
`dist_lisp_LISP`|要发布到指定处的Lisp程序
`dist_noinst_LISP`|要发布但不安装的Lisp程序
`DIST_SUBDIRS`|`AM_CONDITIONAL`中用的子目录
`DVIPS`|把dvi文件转换为ps文件的命令
`EMACS`|Emacs命令
`ETAGSFLAGS`|etags选项
`ETAGS_ARGS`|etags参数
`EXPECT`|
`EXTRA_DIST`|额外安装的文件
`EXTRA_maude_DEPENDENCIES`|由configure决定是否链接的依赖
`EXTRA_maude_SOURCES`|由configure决定是否编译的源文件
`EXTRA_PROGRAMS`|由configure决定是否编译和链接的程序
`EXT_LOG_COMPILE`|测试运行器
`EXT_LOG_COMPILER`|测试运行器
`EXT_LOG_DRIVER`|测试驱动器
`EXT_LOG_DRIVER_FLAGS`|测试驱动器选项
`EXT_LOG_FLAGS`|测试运行器参数
`F77`|Fortran77编译器
`F77COMPILE`|编译Fortran77源的命令
`F77LINK`|链接Fortran77程序的链接器
`FC`|Fortran 9x编译器
`FCCOMPILE`|Fortran 9x编译命令
`FCFLAGS`|Fortran 9x编译选项
`FCLINK`|Fortran 9x链接命令
`FFLAGS`|Fortran77编译器选项
`FLIBS`|Fortran77链接器额外选项
`FLINK`|Fortran77链接器命令
`GCJ`|GCJ命令
`GCJFLAGS`|GCJ选项
`GCJLINK`|GCJ链接命令
`GTAGS_ARGS`|gtags参数
`GZIP_ENV`|gzip选项
`HEADERS`|要安装的头文件
`host_triplet`|运行机类型
`INCLUDES`|`AC_CPPFLAGS`的旧名
`include_HEADERS`|要安装到指定地方的头文件
`info_TEXINFOS`|在指定地方的info页
`JAVA`|Java源文件
`JAVAC`|Java编译器，默认`javac`
`JAVACFLAGS`|Java编译器选项
`JAVAROOT`|作为Java编译器的`-d`选项，默认`$(top_builddir)`
`LDADD`|指定要链接的额外库
`LDFLAGS`|继承自autoconf
`LFLAGS`|lex选项
`libexec_PROGRAMS`|放到指定地方的程序
`libexec_SCRIPTS`|放到指定地方的脚本
`LIBRARIES`|要构建的库文件
`LIBS`|继承自autoconf
`LIBTOOLFLAGS`|Libtool选项
`lib_LIBRARIES`|要构建的库文件
`lib_LTLIBRARIES`|要构建的Libtool库
`LINK`|链接C程序的命令
`LISP`|要构建的Lisp源文件
`lispdir`|emacs位置
`lisp_LISP`|Lisp源文件
`localstate_DATA`|放到指定地方的数据文件
`LOG_COMPILE`|测试运行器
`LOG_COMPILER`|测试运行器
`LOG_DRIVER`|测试驱动器
`LOG_DRIVER_FLAGS`|测试驱动器选项
`LOG_FLAGS`|测试运行器参数
`LTLIBRARIES`|Libtool库
`MAINTAINERCLEANFILES`|目标`maintainer-clean`应清除的文件
`MAKE`|`make`命令
`MAKEINFO`|`makeinfo`命令
`MAKEINFOFLAGS`|`makeinfo`选项
`MAKEINFOHTML`|`makeinfo`选项
`MANS`|man文档页
`man_MANS`|man文档页
`maude_AR`|生成静态库的命令
`maude_CCASFLAGS`|目标特定的链接选项
`maude_CFLAGS`|目标特定的C编译选项
`maude_CPPFLAGS`|目标特定的预处理选项
`maude_CXXFLAGS`|目标特定的C++编译器选项
`maude_DEPENDENCIES`|不属于目标的依赖文件
`maude_FFLAGS`|目标特定的Fortran编译选项
`maude_GCJFLAGS`|目标特定的GCJ选项
`maude_LDADD`|加到库的额外对象或库
`maude_LDFLAGS`|程序或共享库的额外链接选项
`maude_LFLAGS`|目标特定的lex相关编译选项
`maude_LIBADD`|加到库的额外对象
`maude_LIBTOOLFLAGS`|libtool的额外选项
`maude_LINK`|程序特定的链接命令
`maude_OBJCFLAGS`|目标特定的Objective C编译选项
`maude_OBJCXXFLAGS`|目标特定的Objective C++编译选项
`maude_RFLAGS`|目标特定的Ratfor编译选项
`maude_SHORTNAME`|中间文件的短名
`maude_SOURCES`|构建程序所需的源文件
`maude_UPCFLAGS`|目标特定的统一并行C编译选项
`maude_YFLAGS`|目标特定的yacc相关编译选项
`MOSTLYCLEANFILES`|目标`mostlyclean`应清除的文件
`noinst_HEADERS`|构建但不安装的头文件
`noinst_LIBRARIES`|构建但不安装的库
`noinst_LISP`|构建但不安装的Lisp
`noinst_LTLIBRARIES`|构建但不安装的Libtool库
`noinst_PROGRAMS`|构建但不安装的程序
`noinst_SCRIPTS`|构建但不安装的脚本
`notrans_`|指定不用改名的man页
`OBJC`|Objective C编译器
`OBJCCOMPILE`|Objective C编译命令
`OBJCFLAGS`|Objective C编译器选项
`OBJCLINK`|Objective C链接命令
`OBJCXX`|Objective C++编译器
`OBJCXXCOMPILE`|Objective C++编译命令
`OBJCXXFLAGS`|Objective C++编译器选项
`OBJCXXLINK`|Objective C++链接命令
`oldinclude_HEADERS`|放到指定地方的头文件
`PACKAGE`|要构建的包名
`pkgdatadir`|数据文件的安装目录
`pkgdata_DATA`|放到指定地方的数据文件
`pkgdata_SCRIPTS`|放到指定地方的脚本
`pkgincludedir`|头文件的安装目录
`pkginclude_HEADERS`|放到指定地方的头文件
`pkglibdir`|库的安装目录
`pkglibexecdir`|可执行文件的安装目录
`pkglibexec_PROGRAMS`|放到指定地方的程序
`pkglibexec_SCRIPTS`|放到指定地方的脚本
`pkglib_LIBRARIES`|放到指定地方的库
`pkglib_LTLIBRARIES`|放到指定地方的Libtool库
`pkgpyexecdir`|Python扩展模块的安装目录
`pkgpythondir`|同`$(pythondir)/$(PACKAGE)`
`PROGRAMS`|需要编译和链接的程序
`pyexecdir`|同`$(pyexecdir)/$(PACKAGE)`
`PYTHON`|要构建的Python程序
`pythondir`|Python安装树的`site-packages`子目录
`PYTHON_EXEC_PREFIX`|同`${exec_prefix}`
`PYTHON_PLATFORM`|Python用的操作系统名
`PYTHON_PREFIX`|同`${prefix}`
`PYTHON_VERSION`|Python版本
`RECHECK_LOGS`|需要删除的删除日志文件
`RFLAGS`|Ratfor编译器选项
`RUNTEST`|
`RUNTESTDEFAULTFLAGS`|默认的`--tool`、`--srcdir`选项
`RUNTESTFLAGS`|测试选项
`sbin_PROGRAMS`|要安装到`sbin`目录的程序
`sbin_SCRIPTS`|要安装到`sbin`目录的脚本
`SCRIPTS`|脚本文件
`sharedstate_DATA`|放到指定地方的数据文件
`SOURCES`|源文件
`SUBDIRS`|需要构建的子目录
`SUFFIXES`|后缀转换列表
`sysconf_DATA`|放到指定地方的数据文件
`TAGS_DEPENDENCIES`|标签的依赖项
`target_triplet`|目标机类型
`TESTS`|测试脚本
`TESTS_ENVIRONMENT`|测试前的预备代码
`TEST_EXTENSIONS`|测试的后缀列表
`TEST_LOGS`|测试日志文件列表
`TEST_SUITE_LOG`|测试结果总结文件
`TEXI2DVI`|把texi文件转换为dvi文件的命令
`TEXI2PDF`|把texi文件转换为pdf文件的命令
`TEXINFOS`|texinfo文件
`TEXINFO_TEX`|`texinfo.tex`的位置
`top_distdir`|发布树的根
`UPC`|统一并行C编译器
`UPCCOMPILE`|统一并行C编译命令
`UPCFLAGS`|统一并行C编译选项
`UPCLINK`|统一并行C链接命令
`V`|详细级别
`VALAC`|vala编译器
`VALAFLAGS`|vala选项
`VERBOSE`|输出失败测试的输出
`VERSION`|要构建的包版本
`WARNINGS`|启用警告类别列表
`WITH_DMALLOC`|支持Dmalloc包
`XFAIL_TESTS`|预期失败的测试
`XZ_OPT`|xz选项
`YACC`|yacc命令
`YFLAGS`|yacc选项
